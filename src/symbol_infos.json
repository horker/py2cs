[
  {
    "Name": "_CustomFunction",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_CustomFunction",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_CachedOp",
    "Description": "",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "input data list"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_CachedOp",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_cvimdecode",
    "Description": "Decode image with OpenCV. \nNote: return image in RGB by default, instead of OpenCV's default BGR.",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "buf",
        "TypeInfo": "NDArray",
        "Description": "Buffer containing binary encoded image"
      },
      {
        "Name": "flag",
        "TypeInfo": "int, optional, default='1'",
        "Description": "Convert decoded image to grayscale (0) or color (1)."
      },
      {
        "Name": "to_rgb",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "Whether to convert decoded image to mxnet's default RGB format (instead of opencv's default BGR)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_cvimread",
    "Description": "Read and decode image with OpenCV. \nNote: return image in RGB by default, instead of OpenCV's default BGR.",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "filename",
        "TypeInfo": "string, required",
        "Description": "Name of the image file to be loaded."
      },
      {
        "Name": "flag",
        "TypeInfo": "int, optional, default='1'",
        "Description": "Convert decoded image to grayscale (0) or color (1)."
      },
      {
        "Name": "to_rgb",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "Whether to convert decoded image to mxnet's default RGB format (instead of opencv's default BGR)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_cvimresize",
    "Description": "Resize image with OpenCV. \n",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "src",
        "TypeInfo": "NDArray",
        "Description": "source image"
      },
      {
        "Name": "w",
        "TypeInfo": "int, required",
        "Description": "Width of resized image."
      },
      {
        "Name": "h",
        "TypeInfo": "int, required",
        "Description": "Height of resized image."
      },
      {
        "Name": "interp",
        "TypeInfo": "int, optional, default='1'",
        "Description": "Interpolation method (default=cv2.INTER_LINEAR)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_cvcopyMakeBorder",
    "Description": "Pad image border with OpenCV. \n",
    "NumArgs": 8,
    "Arguments": [
      {
        "Name": "src",
        "TypeInfo": "NDArray",
        "Description": "source image"
      },
      {
        "Name": "top",
        "TypeInfo": "int, required",
        "Description": "Top margin."
      },
      {
        "Name": "bot",
        "TypeInfo": "int, required",
        "Description": "Bottom margin."
      },
      {
        "Name": "left",
        "TypeInfo": "int, required",
        "Description": "Left margin."
      },
      {
        "Name": "right",
        "TypeInfo": "int, required",
        "Description": "Right margin."
      },
      {
        "Name": "type",
        "TypeInfo": "int, optional, default='0'",
        "Description": "Filling type (default=cv2.BORDER_CONSTANT)."
      },
      {
        "Name": "value",
        "TypeInfo": "double, optional, default=0",
        "Description": "(Deprecated! Use ``values`` instead.) Fill with single value."
      },
      {
        "Name": "values",
        "TypeInfo": ", optional, default=[]",
        "Description": "Fill with value(RGB[A] or gray), up to 4 channels."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_copyto",
    "Description": "",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray",
        "Description": "input data"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_NoGradient",
    "Description": "Place holder for variable who cannot perform gradient",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "BatchNorm_v1",
    "Description": "Batch normalization.\n\nThis operator is DEPRECATED. Perform BatchNorm on the input.\n\nNormalizes a data batch by mean and variance, and applies a scale ``gamma`` as\nwell as offset ``beta``.\n\nAssume the input has more than one dimension and we normalize along axis 1.\nWe first compute the mean and variance along this axis:\n\n.. math::\n\n  data\\_mean[i] = mean(data[:,i,:,...]) \\\\\n  data\\_var[i] = var(data[:,i,:,...])\n\nThen compute the normalized output, which has the same shape as input, as following:\n\n.. math::\n\n  out[:,i,:,...] = \\frac{data[:,i,:,...] - data\\_mean[i]}{\\sqrt{data\\_var[i]+\\epsilon}} * gamma[i] + beta[i]\n\nBoth *mean* and *var* returns a scalar by treating the input as a vector.\n\nAssume the input has size *k* on axis 1, then both ``gamma`` and ``beta``\nhave shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and\n``data_var`` as well, which are needed for the backward pass.\n\nBesides the inputs and the outputs, this operator accepts two auxiliary\nstates, ``moving_mean`` and ``moving_var``, which are *k*-length\nvectors. They are global statistics for the whole dataset, which are updated\nby::\n\n  moving_mean = moving_mean * momentum + data_mean * (1 - momentum)\n  moving_var = moving_var * momentum + data_var * (1 - momentum)\n\nIf ``use_global_stats`` is set to be true, then ``moving_mean`` and\n``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute\nthe output. It is often used during inference.\n\nBoth ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,\nthen set ``gamma`` to 1 and its gradient to 0.\n\nThere's no sparse support for this operator, and it will exhibit problematic behavior if used with\nsparse tensors.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\batch_norm_v1.cc:L95",
    "NumArgs": 8,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data to batch normalization"
      },
      {
        "Name": "gamma",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "gamma array"
      },
      {
        "Name": "beta",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "beta array"
      },
      {
        "Name": "eps",
        "TypeInfo": "float, optional, default=0.00100000005",
        "Description": "Epsilon to prevent div 0"
      },
      {
        "Name": "momentum",
        "TypeInfo": "float, optional, default=0.899999976",
        "Description": "Momentum for moving average"
      },
      {
        "Name": "fix_gamma",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "Fix gamma while training"
      },
      {
        "Name": "use_global_stats",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator."
      },
      {
        "Name": "output_mean_var",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Output All,normal mean and var"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_mp_adamw_update",
    "Description": "Update function for multi-precision AdamW optimizer.\n\nAdamW is seen as a modification of Adam by decoupling the weight decay from the\noptimization steps taken w.r.t. the loss function.\n\nAdam update consists of the following steps, where g represents gradient and m, v\nare 1st and 2nd order moment estimates (mean and variance).\n\n.. math::\n\n g_t = \\nabla J(W_{t-1})\\\\\n m_t = \\beta_1 m_{t-1} + (1 - \\beta_1) g_t\\\\\n v_t = \\beta_2 v_{t-1} + (1 - \\beta_2) g_t^2\\\\\n W_t = W_{t-1} - \\eta_t (\\alpha \\frac{ m_t }{ \\sqrt{ v_t } + \\epsilon } + wd W_{t-1})\n\nIt updates the weights using::\n\n m = beta1*m + (1-beta1)*grad\n v = beta2*v + (1-beta2)*(grad**2)\n w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)\n\nNote that gradient is rescaled to grad = rescale_grad * grad. If rescale_grad is NaN, Inf, or 0,\nthe update is skipped.\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\adamw.cc:L77",
    "NumArgs": 13,
    "Arguments": [
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight"
      },
      {
        "Name": "grad",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Gradient"
      },
      {
        "Name": "mean",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Moving mean"
      },
      {
        "Name": "var",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Moving variance"
      },
      {
        "Name": "weight32",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight32"
      },
      {
        "Name": "rescale_grad",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Rescale gradient to rescale_grad * grad. If NaN, Inf, or 0, the update is skipped."
      },
      {
        "Name": "lr",
        "TypeInfo": "float, required",
        "Description": "Learning rate"
      },
      {
        "Name": "beta1",
        "TypeInfo": "float, optional, default=0.899999976",
        "Description": "The decay rate for the 1st moment estimates."
      },
      {
        "Name": "beta2",
        "TypeInfo": "float, optional, default=0.999000013",
        "Description": "The decay rate for the 2nd moment estimates."
      },
      {
        "Name": "epsilon",
        "TypeInfo": "float, optional, default=9.99999994e-09",
        "Description": "A small constant for numerical stability."
      },
      {
        "Name": "wd",
        "TypeInfo": "float, optional, default=0",
        "Description": "Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight."
      },
      {
        "Name": "eta",
        "TypeInfo": "float, required",
        "Description": "Learning rate schedule multiplier"
      },
      {
        "Name": "clip_gradient",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_adamw_update",
    "Description": "Update function for AdamW optimizer. AdamW is seen as a modification of\nAdam by decoupling the weight decay from the optimization steps taken w.r.t. the loss function.\n\nAdam update consists of the following steps, where g represents gradient and m, v\nare 1st and 2nd order moment estimates (mean and variance).\n\n.. math::\n\n g_t = \\nabla J(W_{t-1})\\\\\n m_t = \\beta_1 m_{t-1} + (1 - \\beta_1) g_t\\\\\n v_t = \\beta_2 v_{t-1} + (1 - \\beta_2) g_t^2\\\\\n W_t = W_{t-1} - \\eta_t (\\alpha \\frac{ m_t }{ \\sqrt{ v_t } + \\epsilon } + wd W_{t-1})\n\nIt updates the weights using::\n\n m = beta1*m + (1-beta1)*grad\n v = beta2*v + (1-beta2)*(grad**2)\n w -= eta * (learning_rate * m / (sqrt(v) + epsilon) + w * wd)\n\nNote that gradient is rescaled to grad = rescale_grad * grad. If rescale_grad is NaN, Inf, or 0,\nthe update is skipped.\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\adamw.cc:L120",
    "NumArgs": 12,
    "Arguments": [
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight"
      },
      {
        "Name": "grad",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Gradient"
      },
      {
        "Name": "mean",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Moving mean"
      },
      {
        "Name": "var",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Moving variance"
      },
      {
        "Name": "rescale_grad",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Rescale gradient to rescale_grad * grad. If NaN, Inf, or 0, the update is skipped."
      },
      {
        "Name": "lr",
        "TypeInfo": "float, required",
        "Description": "Learning rate"
      },
      {
        "Name": "beta1",
        "TypeInfo": "float, optional, default=0.899999976",
        "Description": "The decay rate for the 1st moment estimates."
      },
      {
        "Name": "beta2",
        "TypeInfo": "float, optional, default=0.999000013",
        "Description": "The decay rate for the 2nd moment estimates."
      },
      {
        "Name": "epsilon",
        "TypeInfo": "float, optional, default=9.99999994e-09",
        "Description": "A small constant for numerical stability."
      },
      {
        "Name": "wd",
        "TypeInfo": "float, optional, default=0",
        "Description": "Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight."
      },
      {
        "Name": "eta",
        "TypeInfo": "float, required",
        "Description": "Learning rate schedule multiplier"
      },
      {
        "Name": "clip_gradient",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_AdaptiveAvgPooling2D",
    "Description": "\nApplies a 2D adaptive average pooling over a 4D input with the shape of (NCHW).\nThe pooling kernel and stride sizes are automatically chosen for desired output sizes.\n\n- If a single integer is provided for output_size, the output size is \\\n  (N x C x output_size x output_size) for any input (NCHW).\n\n- If a tuple of integers (height, width) are provided for output_size, the output size is \\\n  (N x C x height x width) for any input (NCHW).\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\adaptive_avg_pooling.cc:L214",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data"
      },
      {
        "Name": "output_size",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "int (output size) or a tuple of int for output (height, width)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_contrib_AdaptiveAvgPooling2D",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "all_finite",
    "Description": "Check if all the float numbers in the array are finite (used for AMP)\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\all_finite.cc:L101",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray",
        "Description": "Array"
      },
      {
        "Name": "init_output",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "Initialize output to 1."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "multi_all_finite",
    "Description": "Check if all the float numbers in all the arrays are finite (used for AMP)\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\all_finite.cc:L133",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "Arrays"
      },
      {
        "Name": "num_arrays",
        "TypeInfo": "int, optional, default='1'",
        "Description": "Number of arrays."
      },
      {
        "Name": "init_output",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "Initialize output to 1."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_BilinearResize2D",
    "Description": "\nPerform 2D resizing (upsampling or downsampling) for 4D input using bilinear interpolation.\n\nExpected input is a 4 dimensional NDArray (NCHW) and the output\nwith the shape of (N x C x height x width). \nThe key idea of bilinear interpolation is to perform linear interpolation\nfirst in one direction, and then again in the other direction. See the wikipedia of\n`Bilinear interpolation  <https://en.wikipedia.org/wiki/Bilinear_interpolation>`_\nfor more details.\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\bilinear_resize.cc:L193",
    "NumArgs": 7,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data"
      },
      {
        "Name": "like",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Resize data to it's shape"
      },
      {
        "Name": "height",
        "TypeInfo": "int, optional, default='1'",
        "Description": "output height (required, but ignored if scale_height is defined or mode is not \"size\")"
      },
      {
        "Name": "width",
        "TypeInfo": "int, optional, default='1'",
        "Description": "output width (required, but ignored if scale_width is defined or mode is not \"size\")"
      },
      {
        "Name": "scale_height",
        "TypeInfo": "float or None, optional, default=None",
        "Description": "sampling scale of the height (optional, used in modes \"scale\" and \"odd_scale\")"
      },
      {
        "Name": "scale_width",
        "TypeInfo": "float or None, optional, default=None",
        "Description": "sampling scale of the width (optional, used in modes \"scale\" and \"odd_scale\")"
      },
      {
        "Name": "mode",
        "TypeInfo": "{'like', 'odd_scale', 'size', 'to_even_down', 'to_even_up', 'to_odd_down', 'to_odd_up'},optional, default='size'",
        "Description": "resizing mode. \"simple\" - output height equals parameter \"height\" if \"scale_height\" parameter is not defined or input height multiplied by \"scale_height\" otherwise. Same for width;\"odd_scale\" - if original height or width is odd, then result height is calculated like result_h = (original_h - 1) * scale + 1; for scale > 1 the result shape would be like if we did deconvolution with kernel = (1, 1) and stride = (height_scale, width_scale); and for scale < 1 shape would be like we did convolution with kernel = (1, 1) and stride = (int(1 / height_scale), int( 1/ width_scale);\"like\" - resize first input to the height and width of second input; \"to_even_down\" - resize input to nearest lower even height and width (if original height is odd then result height = original height - 1);\"to_even_up\" - resize input to nearest bigger even height and width (if original height is odd then result height = original height + 1);\"to_odd_down\" - resize input to nearest odd height and width (if original height is odd then result height = original height - 1);\"to_odd_up\" - resize input to nearest odd height and width (if original height is odd then result height = original height + 1);"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_contrib_BilinearResize2D",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_boolean_mask",
    "Description": "\nGiven an n-d NDArray data, and a 1-d NDArray index,\nthe operator produces an un-predeterminable shaped n-d NDArray out,\nwhich stands for the rows in x where the corresonding element in index is non-zero.\n\n>>> data = mx.nd.array([[1, 2, 3],[4, 5, 6],[7, 8, 9]])\n>>> index = mx.nd.array([0, 1, 0])\n>>> out = mx.nd.contrib.boolean_mask(data, index)\n>>> out\n\n[[4. 5. 6.]]\n<NDArray 1x3 @cpu(0)>\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\boolean_mask.cc:L211",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Data"
      },
      {
        "Name": "index",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Mask"
      },
      {
        "Name": "axis",
        "TypeInfo": "int, optional, default='0'",
        "Description": "An integer that represents the axis in NDArray to mask from."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_contrib_boolean_mask",
    "Description": "",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "axis",
        "TypeInfo": "int, optional, default='0'",
        "Description": "An integer that represents the axis in NDArray to mask from."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_box_nms",
    "Description": "Apply non-maximum suppression to input.\n\nThe output will be sorted in descending order according to `score`. Boxes with\noverlaps larger than `overlap_thresh`, smaller scores and background boxes\nwill be removed and filled with -1, the corresponding position will be recorded\nfor backward propogation.\n\nDuring back-propagation, the gradient will be copied to the original\nposition according to the input index. For positions that have been suppressed,\nthe in_grad will be assigned 0.\nIn summary, gradients are sticked to its boxes, will either be moved or discarded\naccording to its original index in input.\n\nInput requirements::\n\n  1. Input tensor have at least 2 dimensions, (n, k), any higher dims will be regarded\n  as batch, e.g. (a, b, c, d, n, k) == (a*b*c*d, n, k)\n  2. n is the number of boxes in each batch\n  3. k is the width of each box item.\n\nBy default, a box is [id, score, xmin, ymin, xmax, ymax, ...],\nadditional elements are allowed.\n\n- `id_index`: optional, use -1 to ignore, useful if `force_suppress=False`, which means\n  we will skip highly overlapped boxes if one is `apple` while the other is `car`.\n\n- `background_id`: optional, default=-1, class id for background boxes, useful\n  when `id_index >= 0` which means boxes with background id will be filtered before nms.\n\n- `coord_start`: required, default=2, the starting index of the 4 coordinates.\n  Two formats are supported:\n\n    - `corner`: [xmin, ymin, xmax, ymax]\n\n    - `center`: [x, y, width, height]\n\n- `score_index`: required, default=1, box score/confidence.\n  When two boxes overlap IOU > `overlap_thresh`, the one with smaller score will be suppressed.\n\n- `in_format` and `out_format`: default='corner', specify in/out box formats.\n\nExamples::\n\n  x = [[0, 0.5, 0.1, 0.1, 0.2, 0.2], [1, 0.4, 0.1, 0.1, 0.2, 0.2],\n       [0, 0.3, 0.1, 0.1, 0.14, 0.14], [2, 0.6, 0.5, 0.5, 0.7, 0.8]]\n  box_nms(x, overlap_thresh=0.1, coord_start=2, score_index=1, id_index=0,\n      force_suppress=True, in_format='corner', out_typ='corner') =\n      [[2, 0.6, 0.5, 0.5, 0.7, 0.8], [0, 0.5, 0.1, 0.1, 0.2, 0.2],\n       [-1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1]]\n  out_grad = [[0.1, 0.1, 0.1, 0.1, 0.1, 0.1], [0.2, 0.2, 0.2, 0.2, 0.2, 0.2],\n              [0.3, 0.3, 0.3, 0.3, 0.3, 0.3], [0.4, 0.4, 0.4, 0.4, 0.4, 0.4]]\n  # exe.backward\n  in_grad = [[0.2, 0.2, 0.2, 0.2, 0.2, 0.2], [0, 0, 0, 0, 0, 0],\n             [0, 0, 0, 0, 0, 0], [0.1, 0.1, 0.1, 0.1, 0.1, 0.1]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\bounding_box.cc:L93",
    "NumArgs": 11,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      },
      {
        "Name": "overlap_thresh",
        "TypeInfo": "float, optional, default=0.5",
        "Description": "Overlapping(IoU) threshold to suppress object with smaller score."
      },
      {
        "Name": "valid_thresh",
        "TypeInfo": "float, optional, default=0",
        "Description": "Filter input boxes to those whose scores greater than valid_thresh."
      },
      {
        "Name": "topk",
        "TypeInfo": "int, optional, default='-1'",
        "Description": "Apply nms to topk boxes with descending scores, -1 to no restriction."
      },
      {
        "Name": "coord_start",
        "TypeInfo": "int, optional, default='2'",
        "Description": "Start index of the consecutive 4 coordinates."
      },
      {
        "Name": "score_index",
        "TypeInfo": "int, optional, default='1'",
        "Description": "Index of the scores/confidence of boxes."
      },
      {
        "Name": "id_index",
        "TypeInfo": "int, optional, default='-1'",
        "Description": "Optional, index of the class categories, -1 to disable."
      },
      {
        "Name": "background_id",
        "TypeInfo": "int, optional, default='-1'",
        "Description": "Optional, id of the background class which will be ignored in nms."
      },
      {
        "Name": "force_suppress",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Optional, if set false and id_index is provided, nms will only apply to boxes belongs to the same category"
      },
      {
        "Name": "in_format",
        "TypeInfo": "{'center', 'corner'},optional, default='corner'",
        "Description": "The input box encoding type. \n \"corner\" means boxes are encoded as [xmin, ymin, xmax, ymax], \"center\" means boxes are encodes as [x, y, width, height]."
      },
      {
        "Name": "out_format",
        "TypeInfo": "{'center', 'corner'},optional, default='corner'",
        "Description": "The output box encoding type. \n \"corner\" means boxes are encoded as [xmin, ymin, xmax, ymax], \"center\" means boxes are encodes as [x, y, width, height]."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_contrib_box_nms",
    "Description": "",
    "NumArgs": 10,
    "Arguments": [
      {
        "Name": "overlap_thresh",
        "TypeInfo": "float, optional, default=0.5",
        "Description": "Overlapping(IoU) threshold to suppress object with smaller score."
      },
      {
        "Name": "valid_thresh",
        "TypeInfo": "float, optional, default=0",
        "Description": "Filter input boxes to those whose scores greater than valid_thresh."
      },
      {
        "Name": "topk",
        "TypeInfo": "int, optional, default='-1'",
        "Description": "Apply nms to topk boxes with descending scores, -1 to no restriction."
      },
      {
        "Name": "coord_start",
        "TypeInfo": "int, optional, default='2'",
        "Description": "Start index of the consecutive 4 coordinates."
      },
      {
        "Name": "score_index",
        "TypeInfo": "int, optional, default='1'",
        "Description": "Index of the scores/confidence of boxes."
      },
      {
        "Name": "id_index",
        "TypeInfo": "int, optional, default='-1'",
        "Description": "Optional, index of the class categories, -1 to disable."
      },
      {
        "Name": "background_id",
        "TypeInfo": "int, optional, default='-1'",
        "Description": "Optional, id of the background class which will be ignored in nms."
      },
      {
        "Name": "force_suppress",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Optional, if set false and id_index is provided, nms will only apply to boxes belongs to the same category"
      },
      {
        "Name": "in_format",
        "TypeInfo": "{'center', 'corner'},optional, default='corner'",
        "Description": "The input box encoding type. \n \"corner\" means boxes are encoded as [xmin, ymin, xmax, ymax], \"center\" means boxes are encodes as [x, y, width, height]."
      },
      {
        "Name": "out_format",
        "TypeInfo": "{'center', 'corner'},optional, default='corner'",
        "Description": "The output box encoding type. \n \"corner\" means boxes are encoded as [xmin, ymin, xmax, ymax], \"center\" means boxes are encodes as [x, y, width, height]."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_box_iou",
    "Description": "Bounding box overlap of two arrays.\n  The overlap is defined as Intersection-over-Union, aka, IOU.\n  - lhs: (a_1, a_2, ..., a_n, 4) array\n  - rhs: (b_1, b_2, ..., b_n, 4) array\n  - output: (a_1, a_2, ..., a_n, b_1, b_2, ..., b_n) array\n\n  Note::\n\n    Zero gradients are back-propagated in this op for now.\n\n  Example::\n\n    x = [[0.5, 0.5, 1.0, 1.0], [0.0, 0.0, 0.5, 0.5]]\n    y = [[0.25, 0.25, 0.75, 0.75]]\n    box_iou(x, y, format='corner') = [[0.1428], [0.1428]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\bounding_box.cc:L134",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The second input"
      },
      {
        "Name": "format",
        "TypeInfo": "{'center', 'corner'},optional, default='corner'",
        "Description": "The box encoding type. \n \"corner\" means boxes are encoded as [xmin, ymin, xmax, ymax], \"center\" means boxes are encodes as [x, y, width, height]."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_contrib_box_iou",
    "Description": "",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "format",
        "TypeInfo": "{'center', 'corner'},optional, default='corner'",
        "Description": "The box encoding type. \n \"corner\" means boxes are encoded as [xmin, ymin, xmax, ymax], \"center\" means boxes are encodes as [x, y, width, height]."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_bipartite_matching",
    "Description": "Compute bipartite matching.\n  The matching is performed on score matrix with shape [B, N, M]\n  - B: batch_size\n  - N: number of rows to match\n  - M: number of columns as reference to be matched against.\n\n  Returns:\n  x : matched column indices. -1 indicating non-matched elements in rows.\n  y : matched row indices.\n\n  Note::\n\n    Zero gradients are back-propagated in this op for now.\n\n  Example::\n\n    s = [[0.5, 0.6], [0.1, 0.2], [0.3, 0.4]]\n    x, y = bipartite_matching(x, threshold=1e-12, is_ascend=False)\n    x = [1, -1, 0]\n    y = [2, 0]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\bounding_box.cc:L180",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      },
      {
        "Name": "is_ascend",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Use ascend order for scores instead of descending. Please set threshold accordingly."
      },
      {
        "Name": "threshold",
        "TypeInfo": "float, required",
        "Description": "Ignore matching when score < thresh, if is_ascend=false, or ignore score > thresh, if is_ascend=true."
      },
      {
        "Name": "topk",
        "TypeInfo": "int, optional, default='-1'",
        "Description": "Limit the number of matches to topk, set -1 for no limit"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_contrib_bipartite_matching",
    "Description": "",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "is_ascend",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Use ascend order for scores instead of descending. Please set threshold accordingly."
      },
      {
        "Name": "threshold",
        "TypeInfo": "float, required",
        "Description": "Ignore matching when score < thresh, if is_ascend=false, or ignore score > thresh, if is_ascend=true."
      },
      {
        "Name": "topk",
        "TypeInfo": "int, optional, default='-1'",
        "Description": "Limit the number of matches to topk, set -1 for no limit"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_dgl_csr_neighbor_uniform_sample",
    "Description": "This operator samples sub-graphs from a csr graph via an\nuniform probability. The operator is designed for DGL.\n\nThe operator outputs three sets of NDArrays to represent the sampled results\n(the number of NDArrays in each set is the same as the number of seed NDArrays):\n1) a set of 1D NDArrays containing the sampled vertices, 2) a set of CSRNDArrays representing\nthe sampled edges, 3) a set of 1D NDArrays indicating the layer where a vertex is sampled.\nThe first set of 1D NDArrays have a length of max_num_vertices+1. The last element in an NDArray\nindicate the acutal number of vertices in a subgraph. The third set of NDArrays have a length\nof max_num_vertices, and the valid number of vertices is the same as the ones in the first set.\n\nExample:\n\n   .. code:: python\n\n  shape = (5, 5)\n  data_np = np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], dtype=np.int64)\n  indices_np = np.array([1,2,3,4,0,2,3,4,0,1,3,4,0,1,2,4,0,1,2,3], dtype=np.int64)\n  indptr_np = np.array([0,4,8,12,16,20], dtype=np.int64)\n  a = mx.nd.sparse.csr_matrix((data_np, indices_np, indptr_np), shape=shape)\n  a.asnumpy()\n  seed = mx.nd.array([0,1,2,3,4], dtype=np.int64)\n  out = mx.nd.contrib.dgl_csr_neighbor_uniform_sample(a, seed, num_args=2, num_hops=1, num_neighbor=2, max_num_vertices=5)\n\n  out[0]\n  [0 1 2 3 4 5]\n  <NDArray 6 @cpu(0)>\n\n  out[1].asnumpy()\n  array([[ 0,  1,  0,  3,  0],\n         [ 5,  0,  0,  7,  0],\n         [ 9,  0,  0, 11,  0],\n         [13,  0, 15,  0,  0],\n         [17,  0, 19,  0,  0]])\n\n  out[2]\n  [0 0 0 0 0]\n  <NDArray 5 @cpu(0)>\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\dgl_graph.cc:L784",
    "NumArgs": 6,
    "Arguments": [
      {
        "Name": "csr_matrix",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "csr matrix"
      },
      {
        "Name": "seed_arrays",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "seed vertices"
      },
      {
        "Name": "num_args",
        "TypeInfo": "int, required",
        "Description": "Number of input NDArray."
      },
      {
        "Name": "num_hops",
        "TypeInfo": ", optional, default=1",
        "Description": "Number of hops."
      },
      {
        "Name": "num_neighbor",
        "TypeInfo": ", optional, default=2",
        "Description": "Number of neighbor."
      },
      {
        "Name": "max_num_vertices",
        "TypeInfo": ", optional, default=100",
        "Description": "Max number of vertices."
      }
    ],
    "KeyVarNumArgs": "num_args",
    "ReturnType": null
  },
  {
    "Name": "_contrib_dgl_csr_neighbor_non_uniform_sample",
    "Description": "This operator samples sub-graph from a csr graph via an\nnon-uniform probability. The operator is designed for DGL.\n\nThe operator outputs four sets of NDArrays to represent the sampled results\n(the number of NDArrays in each set is the same as the number of seed NDArrays):\n1) a set of 1D NDArrays containing the sampled vertices, 2) a set of CSRNDArrays representing\nthe sampled edges, 3) a set of 1D NDArrays with the probability that vertices are sampled,\n4) a set of 1D NDArrays indicating the layer where a vertex is sampled.\nThe first set of 1D NDArrays have a length of max_num_vertices+1. The last element in an NDArray\nindicate the acutal number of vertices in a subgraph. The third and fourth set of NDArrays have a length\nof max_num_vertices, and the valid number of vertices is the same as the ones in the first set.\n\nExample:\n\n   .. code:: python\n\n  shape = (5, 5)\n  prob = mx.nd.array([0.9, 0.8, 0.2, 0.4, 0.1], dtype=np.float32)\n  data_np = np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], dtype=np.int64)\n  indices_np = np.array([1,2,3,4,0,2,3,4,0,1,3,4,0,1,2,4,0,1,2,3], dtype=np.int64)\n  indptr_np = np.array([0,4,8,12,16,20], dtype=np.int64)\n  a = mx.nd.sparse.csr_matrix((data_np, indices_np, indptr_np), shape=shape)\n  seed = mx.nd.array([0,1,2,3,4], dtype=np.int64)\n  out = mx.nd.contrib.dgl_csr_neighbor_non_uniform_sample(a, prob, seed, num_args=3, num_hops=1, num_neighbor=2, max_num_vertices=5)\n\n  out[0]\n  [0 1 2 3 4 5]\n  <NDArray 6 @cpu(0)>\n\n  out[1].asnumpy()\n  array([[ 0,  1,  2,  0,  0],\n         [ 5,  0,  6,  0,  0],\n         [ 9, 10,  0,  0,  0],\n         [13, 14,  0,  0,  0],\n         [ 0, 18, 19,  0,  0]])\n\n  out[2]\n  [0.9 0.8 0.2 0.4 0.1]\n  <NDArray 5 @cpu(0)>\n\n  out[3]\n  [0 0 0 0 0]\n  <NDArray 5 @cpu(0)>\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\dgl_graph.cc:L883",
    "NumArgs": 7,
    "Arguments": [
      {
        "Name": "csr_matrix",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "csr matrix"
      },
      {
        "Name": "probability",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "probability vector"
      },
      {
        "Name": "seed_arrays",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "seed vertices"
      },
      {
        "Name": "num_args",
        "TypeInfo": "int, required",
        "Description": "Number of input NDArray."
      },
      {
        "Name": "num_hops",
        "TypeInfo": ", optional, default=1",
        "Description": "Number of hops."
      },
      {
        "Name": "num_neighbor",
        "TypeInfo": ", optional, default=2",
        "Description": "Number of neighbor."
      },
      {
        "Name": "max_num_vertices",
        "TypeInfo": ", optional, default=100",
        "Description": "Max number of vertices."
      }
    ],
    "KeyVarNumArgs": "num_args",
    "ReturnType": null
  },
  {
    "Name": "_contrib_dgl_subgraph",
    "Description": "This operator constructs an induced subgraph for\na given set of vertices from a graph. The operator accepts multiple\nsets of vertices as input. For each set of vertices, it returns a pair\nof CSR matrices if return_mapping is True: the first matrix contains edges\nwith new edge Ids, the second matrix contains edges with the original\nedge Ids.\n\nExample:\n\n   .. code:: python\n\n     x=[[1, 0, 0, 2],\n       [3, 0, 4, 0],\n       [0, 5, 0, 0],\n       [0, 6, 7, 0]]\n     v = [0, 1, 2]\n     dgl_subgraph(x, v, return_mapping=True) =\n       [[1, 0, 0],\n        [2, 0, 3],\n        [0, 4, 0]],\n       [[1, 0, 0],\n        [3, 0, 4],\n        [0, 5, 0]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\dgl_graph.cc:L1140",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "graph",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input graph where we sample vertices."
      },
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "The input arrays that include data arrays and states."
      },
      {
        "Name": "num_args",
        "TypeInfo": "int, required",
        "Description": "Number of input arguments, including all symbol inputs."
      },
      {
        "Name": "return_mapping",
        "TypeInfo": "boolean, required",
        "Description": "Return mapping of vid and eid between the subgraph and the parent graph."
      }
    ],
    "KeyVarNumArgs": "num_args",
    "ReturnType": null
  },
  {
    "Name": "_contrib_edge_id",
    "Description": "This operator implements the edge_id function for a graph\nstored in a CSR matrix (the value of the CSR stores the edge Id of the graph).\noutput[i] = input[u[i], v[i]] if there is an edge between u[i] and v[i]],\notherwise output[i] will be -1. Both u and v should be 1D vectors.\n\nExample:\n\n   .. code:: python\n\n      x = [[ 1, 0, 0 ],\n           [ 0, 2, 0 ],\n           [ 0, 0, 3 ]]\n      u = [ 0, 0, 1, 1, 2, 2 ]\n      v = [ 0, 1, 1, 2, 0, 2 ]\n      edge_id(x, u, v) = [ 1, -1, 2, -1, -1, 3 ]\n\nThe storage type of ``edge_id`` output depends on storage types of inputs\n  - edge_id(csr, default, default) = default\n  - default and rsp inputs are not supported\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\dgl_graph.cc:L1321",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input ndarray"
      },
      {
        "Name": "u",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "u ndarray"
      },
      {
        "Name": "v",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "v ndarray"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_dgl_adjacency",
    "Description": "This operator converts a CSR matrix whose values are edge Ids\nto an adjacency matrix whose values are ones. The output CSR matrix always has\nthe data value of float32.\n\nExample:\n\n   .. code:: python\n\n  x = [[ 1, 0, 0 ],\n       [ 0, 2, 0 ],\n       [ 0, 0, 3 ]]\n  dgl_adjacency(x) =\n      [[ 1, 0, 0 ],\n       [ 0, 1, 0 ],\n       [ 0, 0, 1 ]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\dgl_graph.cc:L1393",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input ndarray"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_dgl_graph_compact",
    "Description": "This operator compacts a CSR matrix generated by\ndgl_csr_neighbor_uniform_sample and dgl_csr_neighbor_non_uniform_sample.\nThe CSR matrices generated by these two operators may have many empty\nrows at the end and many empty columns. This operator removes these\nempty rows and empty columns.\n\nExample:\n\n   .. code:: python\n\n  shape = (5, 5)\n  data_np = np.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], dtype=np.int64)\n  indices_np = np.array([1,2,3,4,0,2,3,4,0,1,3,4,0,1,2,4,0,1,2,3], dtype=np.int64)\n  indptr_np = np.array([0,4,8,12,16,20], dtype=np.int64)\n  a = mx.nd.sparse.csr_matrix((data_np, indices_np, indptr_np), shape=shape)\n  seed = mx.nd.array([0,1,2,3,4], dtype=np.int64)\n  out = mx.nd.contrib.dgl_csr_neighbor_uniform_sample(a, seed, num_args=2, num_hops=1,\n          num_neighbor=2, max_num_vertices=6)\n  subg_v = out[0]\n  subg = out[1]\n  compact = mx.nd.contrib.dgl_graph_compact(subg, subg_v,\n          graph_sizes=(subg_v[-1].asnumpy()[0]), return_mapping=False)\n\n  compact.asnumpy()\n  array([[0, 0, 0, 1, 0],\n         [2, 0, 3, 0, 0],\n         [0, 4, 0, 0, 5],\n         [0, 6, 0, 0, 7],\n         [8, 9, 0, 0, 0]])\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\dgl_graph.cc:L1582",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "graph_data",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "Input graphs and input vertex Ids."
      },
      {
        "Name": "num_args",
        "TypeInfo": "int, required",
        "Description": "Number of input arguments."
      },
      {
        "Name": "return_mapping",
        "TypeInfo": "boolean, required",
        "Description": "Return mapping of vid and eid between the subgraph and the parent graph."
      },
      {
        "Name": "graph_sizes",
        "TypeInfo": ", required",
        "Description": "the number of vertices in each graph."
      }
    ],
    "KeyVarNumArgs": "num_args",
    "ReturnType": null
  },
  {
    "Name": "_contrib_gradientmultiplier",
    "Description": "This operator implements the gradient multiplier function.\nIn forward pass it acts as an identity transform. During backpropagation it\nmultiplies the gradient from the subsequent level by a scalar factor lambda and passes it to\nthe preceding layer.\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\gradient_multiplier_op.cc:L78",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "lambda multiplier"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_backward_gradientmultiplier",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_hawkesll",
    "Description": "Computes the log likelihood of a univariate Hawkes process.\n\nThe log likelihood is calculated on point process observations represented\nas *ragged* matrices for *lags* (interarrival times w.r.t. the previous point),\nand *marks* (identifiers for the process ID). Note that each mark is considered independent,\ni.e., computes the joint likelihood of a set of Hawkes processes determined by the conditional intensity:\n\n.. math::\n\n  \\lambda_k^*(t) = \\lambda_k + \\alpha_k \\sum_{\\{t_i < t, y_i = k\\}} \\beta_k \\exp(-\\beta_k (t - t_i))\n\nwhere :math:`\\lambda_k` specifies the background intensity ``lda``, :math:`\\alpha_k` specifies the *branching ratio* or ``alpha``, and :math:`\\beta_k` the delay density parameter ``beta``.\n\n``lags`` and ``marks`` are two NDArrays of shape (N, T) and correspond to the representation of the point process observation, the first dimension corresponds to the batch index, and the second to the sequence. These are \"left-aligned\" *ragged* matrices (the first index of the second dimension is the beginning of every sequence. The length of each sequence is given by ``valid_length``, of shape (N,) where ``valid_length[i]`` corresponds to the number of valid points in ``lags[i, :]`` and ``marks[i, :]``.\n\n``max_time`` is the length of the observation period of the point process. That is, specifying ``max_time[i] = 5`` computes the likelihood of the i-th sample as observed on the time interval :math:`(0, 5]`. Naturally, the sum of all valid ``lags[i, :valid_length[i]]`` must be less than or equal to 5.\n\nThe input ``state`` specifies the *memory* of the Hawkes process. Invoking the memoryless property of exponential decays, we compute the *memory* as\n\n.. math::\n\n    s_k(t) = \\sum_{t_i < t} \\exp(-\\beta_k (t - t_i)).\n\nThe ``state`` to be provided is :math:`s_k(0)` and carries the added intensity due to past events before the current batch. :math:`s_k(T)` is returned from the function where :math:`T` is ``max_time[T]``.\n\nExample::\n\n  # define the Hawkes process parameters\n  lda = nd.array([1.5, 2.0, 3.0]).tile((N, 1))\n  alpha = nd.array([0.2, 0.3, 0.4])  # branching ratios should be < 1\n  beta = nd.array([1.0, 2.0, 3.0])\n\n  # the \"data\", or observations\n  ia_times = nd.array([[6, 7, 8, 9], [1, 2, 3, 4], [3, 4, 5, 6], [8, 9, 10, 11]])\n  marks = nd.zeros((N, T)).astype(np.int32)\n\n  # starting \"state\" of the process\n  states = nd.zeros((N, K))\n\n  valid_length = nd.array([1, 2, 3, 4])  # number of valid points in each sequence\n  max_time = nd.ones((N,)) * 100.0  # length of the observation period\n\n  A = nd.contrib.hawkesll(\n      lda, alpha, beta, states, ia_times, marks, valid_length, max_time\n  )\n\nReferences:\n\n-  Bacry, E., Mastromatteo, I., & Muzy, J. F. (2015).\n   Hawkes processes in finance. Market Microstructure and Liquidity\n   , 1(01), 1550005.\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\hawkes_ll.cc:L84",
    "NumArgs": 8,
    "Arguments": [
      {
        "Name": "lda",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Shape (N, K) The intensity for each of the K processes, for each sample"
      },
      {
        "Name": "alpha",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Shape (K,) The infectivity factor (branching ratio) for each process"
      },
      {
        "Name": "beta",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Shape (K,) The decay parameter for each process"
      },
      {
        "Name": "state",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Shape (N, K) the Hawkes state for each process"
      },
      {
        "Name": "lags",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Shape (N, T) the interarrival times"
      },
      {
        "Name": "marks",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Shape (N, T) the marks (process ids)"
      },
      {
        "Name": "valid_length",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The number of valid points in the process"
      },
      {
        "Name": "max_time",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "the length of the interval where the processes were sampled"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_backward_hawkesll",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_index_array",
    "Description": "Returns an array of indexes of the input array.\n\nFor an input array with shape  :math:`(d_1, d_2, ..., d_n)`, `index_array` returns a\n:math:`(d_1, d_2, ..., d_n, n)` array `idx`, where\n:math:`idx[i_1, i_2, ..., i_n, :] = [i_1, i_2, ..., i_n]`.\n\nAdditionally, when the parameter `axes` is specified, `idx` will be a\n:math:`(d_1, d_2, ..., d_n, m)` array where `m` is the length of `axes`, and the following\nequality will hold: :math:`idx[i_1, i_2, ..., i_n, j] = i_{axes[j]}`.\n\nExamples::\n\n    x = mx.nd.ones((3, 2))\n\n    mx.nd.contrib.index_array(x) = [[[0 0]\n                                     [0 1]]\n\n                                    [[1 0]\n                                     [1 1]]\n\n                                    [[2 0]\n                                     [2 1]]]\n\n    x = mx.nd.ones((3, 2, 2))\n\n    mx.nd.contrib.index_array(x, axes=(1, 0)) = [[[[0 0]\n                                                   [0 0]]\n\n                                                  [[1 0]\n                                                   [1 0]]]\n\n\n                                                 [[[0 1]\n                                                   [0 1]]\n\n                                                  [[1 1]\n                                                   [1 1]]]\n\n\n                                                 [[[0 2]\n                                                   [0 2]]\n\n                                                  [[1 2]\n                                                   [1 2]]]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\index_array.cc:L118",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data"
      },
      {
        "Name": "axes",
        "TypeInfo": "Shape or None, optional, default=None",
        "Description": "The axes to include in the index array. Supports negative values."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_index_copy",
    "Description": "Copies the elements of a `new_tensor` into the `old_tensor`.\n\nThis operator copies the elements by selecting the indices in the order given in `index`.\nThe output will be a new tensor containing the rest elements of old tensor and\nthe copied elements of new tensor.\nFor example, if `index[i] == j`, then the `i` th row of `new_tensor` is copied to the\n`j` th row of output.\n\nThe `index` must be a vector and it must have the same size with the `0` th dimension of\n`new_tensor`. Also, the `0` th dimension of old_tensor must `>=` the `0` th dimension of\n`new_tensor`, or an error will be raised.\n\nExamples::\n\n    x = mx.nd.zeros((5,3))\n    t = mx.nd.array([[1,2,3],[4,5,6],[7,8,9]])\n    index = mx.nd.array([0,4,2])\n\n    mx.nd.contrib.index_copy(x, index, t)\n\n    [[1. 2. 3.]\n     [0. 0. 0.]\n     [7. 8. 9.]\n     [0. 0. 0.]\n     [4. 5. 6.]]\n    <NDArray 5x3 @cpu(0)>\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\index_copy.cc:L183",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "old_tensor",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Old tensor"
      },
      {
        "Name": "index_vector",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Index vector"
      },
      {
        "Name": "new_tensor",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "New tensor to be copied"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_backward_index_copy",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "khatri_rao",
    "Description": "Computes the Khatri-Rao product of the input matrices.\n\nGiven a collection of :math:`n` input matrices,\n\n.. math::\n   A_1 \\in \\mathbb{R}^{M_1 \\times M}, \\ldots, A_n \\in \\mathbb{R}^{M_n \\times N},\n\nthe (column-wise) Khatri-Rao product is defined as the matrix,\n\n.. math::\n   X = A_1 \\otimes \\cdots \\otimes A_n \\in \\mathbb{R}^{(M_1 \\cdots M_n) \\times N},\n\nwhere the :math:`k` th column is equal to the column-wise outer product\n:math:`{A_1}_k \\otimes \\cdots \\otimes {A_n}_k` where :math:`{A_i}_k` is the kth\ncolumn of the ith matrix.\n\nExample::\n\n  >>> A = mx.nd.array([[1, -1],\n  >>>                  [2, -3]])\n  >>> B = mx.nd.array([[1, 4],\n  >>>                  [2, 5],\n  >>>                  [3, 6]])\n  >>> C = mx.nd.khatri_rao(A, B)\n  >>> print(C.asnumpy())\n  [[  1.  -4.]\n   [  2.  -5.]\n   [  3.  -6.]\n   [  2. -12.]\n   [  4. -15.]\n   [  6. -18.]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\krprod.cc:L108",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "args",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "Positional input matrices"
      }
    ],
    "KeyVarNumArgs": "num_args",
    "ReturnType": null
  },
  {
    "Name": "_contrib_getnnz",
    "Description": "Number of stored values for a sparse tensor, including explicit zeros.\n\nThis operator only supports CSR matrix on CPU.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\nnz.cc:L177",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input"
      },
      {
        "Name": "axis",
        "TypeInfo": "int or None, optional, default='None'",
        "Description": "Select between the number of values across the whole matrix, in each column, or in each row."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_group_adagrad_update",
    "Description": "Update function for Group AdaGrad optimizer.\n\nReferenced from *Adaptive Subgradient Methods for Online Learning and Stochastic Optimization*,\nand available at http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf but\nuses only a single learning rate for every row of the parameter array.\n\nUpdates are applied by::\n\n    grad = clip(grad * rescale_grad, clip_gradient)\n    history += mean(square(grad), axis=1, keepdims=True)\n    div = grad / sqrt(history + float_stable_eps)\n    weight -= div * lr\n\nWeights are updated lazily if the gradient is sparse.\n\nNote that non-zero values for the weight decay option are not supported.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\optimizer_op.cc:L71",
    "NumArgs": 7,
    "Arguments": [
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight"
      },
      {
        "Name": "grad",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Gradient"
      },
      {
        "Name": "history",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "History"
      },
      {
        "Name": "lr",
        "TypeInfo": "float, required",
        "Description": "Learning rate"
      },
      {
        "Name": "rescale_grad",
        "TypeInfo": "float, optional, default=1",
        "Description": "Rescale gradient to grad = rescale_grad*grad."
      },
      {
        "Name": "clip_gradient",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient)."
      },
      {
        "Name": "epsilon",
        "TypeInfo": "float, optional, default=9.99999975e-06",
        "Description": "Epsilon for numerical stability"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_quadratic",
    "Description": "This operators implements the quadratic function.\n\n.. math::\n    f(x) = ax^2+bx+c\n\nwhere :math:`x` is an input tensor and all operations\nin the function are element-wise.\n\nExample::\n\n  x = [[1, 2], [3, 4]]\n  y = quadratic(data=x, a=1, b=2, c=3)\n  y = [[6, 11], [18, 27]]\n\nThe storage type of ``quadratic`` output depends on storage types of inputs\n  - quadratic(csr, a, b, 0) = csr\n  - quadratic(default, a, b, c) = default\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\quadratic_op.cc:L50",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input ndarray"
      },
      {
        "Name": "a",
        "TypeInfo": "float, optional, default=0",
        "Description": "Coefficient of the quadratic term in the quadratic function."
      },
      {
        "Name": "b",
        "TypeInfo": "float, optional, default=0",
        "Description": "Coefficient of the linear term in the quadratic function."
      },
      {
        "Name": "c",
        "TypeInfo": "float, optional, default=0",
        "Description": "Constant term in the quadratic function."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_backward_quadratic",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_ROIAlign",
    "Description": "\nThis operator takes a 4D feature map as an input array and region proposals as `rois`,\nthen align the feature map over sub-regions of input and produces a fixed-sized output array.\nThis operator is typically used in Faster R-CNN & Mask R-CNN networks.\n\nDifferent from ROI pooling, ROI Align removes the harsh quantization, properly aligning\nthe extracted features with the input. RoIAlign computes the value of each sampling point\nby bilinear interpolation from the nearby grid points on the feature map. No quantization is\nperformed on any coordinates involved in the RoI, its bins, or the sampling points.\nBilinear interpolation is used to compute the exact values of the\ninput features at four regularly sampled locations in each RoI bin.\nThen the feature map can be aggregated by avgpooling.\n\n\nReferences\n----------\n\nHe, Kaiming, et al. \"Mask R-CNN.\" ICCV, 2017\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\roi_align.cc:L538",
    "NumArgs": 6,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data to the pooling operator, a 4D Feature maps"
      },
      {
        "Name": "rois",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Bounding box coordinates, a 2D array"
      },
      {
        "Name": "pooled_size",
        "TypeInfo": "Shape(tuple), required",
        "Description": "ROI Align output roi feature map height and width: (h, w)"
      },
      {
        "Name": "spatial_scale",
        "TypeInfo": "float, required",
        "Description": "Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers"
      },
      {
        "Name": "sample_ratio",
        "TypeInfo": "int, optional, default='-1'",
        "Description": "Optional sampling ratio of ROI align, using adaptive size by default."
      },
      {
        "Name": "position_sensitive",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether to perform position-sensitive RoI pooling. PSRoIPooling is first proposaled by R-FCN and it can reduce the input channels by ph*pw times, where (ph, pw) is the pooled_size"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_ROIAlign",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_SyncBatchNorm",
    "Description": "Batch normalization.\n\nNormalizes a data batch by mean and variance, and applies a scale ``gamma`` as\nwell as offset ``beta``.\nStandard BN [1]_ implementation only normalize the data within each device.\nSyncBN normalizes the input within the whole mini-batch.\nWe follow the sync-onece implmentation described in the paper [2]_.\n\nAssume the input has more than one dimension and we normalize along axis 1.\nWe first compute the mean and variance along this axis:\n\n.. math::\n\n  data\\_mean[i] = mean(data[:,i,:,...]) \\\\\n  data\\_var[i] = var(data[:,i,:,...])\n\nThen compute the normalized output, which has the same shape as input, as following:\n\n.. math::\n\n  out[:,i,:,...] = \\frac{data[:,i,:,...] - data\\_mean[i]}{\\sqrt{data\\_var[i]+\\epsilon}} * gamma[i] + beta[i]\n\nBoth *mean* and *var* returns a scalar by treating the input as a vector.\n\nAssume the input has size *k* on axis 1, then both ``gamma`` and ``beta``\nhave shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and\n``data_var`` as well, which are needed for the backward pass.\n\nBesides the inputs and the outputs, this operator accepts two auxiliary\nstates, ``moving_mean`` and ``moving_var``, which are *k*-length\nvectors. They are global statistics for the whole dataset, which are updated\nby::\n\n  moving_mean = moving_mean * momentum + data_mean * (1 - momentum)\n  moving_var = moving_var * momentum + data_var * (1 - momentum)\n\nIf ``use_global_stats`` is set to be true, then ``moving_mean`` and\n``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute\nthe output. It is often used during inference.\n\nBoth ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,\nthen set ``gamma`` to 1 and its gradient to 0.\n\nReference:\n  .. [1] Ioffe, Sergey, and Christian Szegedy. \"Batch normalization: Accelerating \\\n    deep network training by reducing internal covariate shift.\" *ICML 2015*\n  .. [2] Hang Zhang, Kristin Dana, Jianping Shi, Zhongyue Zhang, Xiaogang Wang, \\\n    Ambrish Tyagi, and Amit Agrawal. \"Context Encoding for Semantic Segmentation.\" *CVPR 2018*\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\sync_batch_norm.cc:L97",
    "NumArgs": 12,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data to batch normalization"
      },
      {
        "Name": "gamma",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "gamma array"
      },
      {
        "Name": "beta",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "beta array"
      },
      {
        "Name": "moving_mean",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "running mean of input"
      },
      {
        "Name": "moving_var",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "running variance of input"
      },
      {
        "Name": "eps",
        "TypeInfo": "float, optional, default=0.00100000005",
        "Description": "Epsilon to prevent div 0"
      },
      {
        "Name": "momentum",
        "TypeInfo": "float, optional, default=0.899999976",
        "Description": "Momentum for moving average"
      },
      {
        "Name": "fix_gamma",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "Fix gamma while training"
      },
      {
        "Name": "use_global_stats",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator."
      },
      {
        "Name": "output_mean_var",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Output All,normal mean and var"
      },
      {
        "Name": "ndev",
        "TypeInfo": "int, optional, default='1'",
        "Description": "The count of GPU devices"
      },
      {
        "Name": "key",
        "TypeInfo": "string, required",
        "Description": "Hash key for synchronization, please set the same hash key for same layer, Block.prefix is typically used as in :class:`gluon.nn.contrib.SyncBatchNorm`."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_div_sqrt_dim",
    "Description": "Rescale the input by the square root of the channel dimension.\n\n   out = data / sqrt(data.shape[-1])\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\transformer.cc:L38",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_foreach",
    "Description": "Run a for loop over an NDArray with user-defined computation\n\nFrom:C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\control_flow.cc:1090",
    "NumArgs": 8,
    "Arguments": [
      {
        "Name": "fn",
        "TypeInfo": "Symbol",
        "Description": "Input graph."
      },
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "The input arrays that include data arrays and states."
      },
      {
        "Name": "num_args",
        "TypeInfo": "int, required",
        "Description": "Number of inputs."
      },
      {
        "Name": "num_outputs",
        "TypeInfo": "int, required",
        "Description": "The number of outputs of the subgraph."
      },
      {
        "Name": "num_out_data",
        "TypeInfo": "int, required",
        "Description": "The number of output data of the subgraph."
      },
      {
        "Name": "in_state_locs",
        "TypeInfo": ", required",
        "Description": "The locations of loop states among the inputs."
      },
      {
        "Name": "in_data_locs",
        "TypeInfo": ", required",
        "Description": "The locations of input data among the inputs."
      },
      {
        "Name": "remain_locs",
        "TypeInfo": ", required",
        "Description": "The locations of remaining data among the inputs."
      }
    ],
    "KeyVarNumArgs": "num_args",
    "ReturnType": null
  },
  {
    "Name": "_backward_foreach",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_while_loop",
    "Description": "Run a while loop over with user-defined condition and computation\n\nFrom:C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\control_flow.cc:1151",
    "NumArgs": 10,
    "Arguments": [
      {
        "Name": "cond",
        "TypeInfo": "Symbol",
        "Description": "Input graph for the loop condition."
      },
      {
        "Name": "func",
        "TypeInfo": "Symbol",
        "Description": "Input graph for the loop body."
      },
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "The input arrays that include data arrays and states."
      },
      {
        "Name": "num_args",
        "TypeInfo": "int, required",
        "Description": "Number of input arguments, including cond and func as two symbol inputs."
      },
      {
        "Name": "num_outputs",
        "TypeInfo": "int, required",
        "Description": "The number of outputs of the subgraph."
      },
      {
        "Name": "num_out_data",
        "TypeInfo": "int, required",
        "Description": "The number of outputs from the function body."
      },
      {
        "Name": "max_iterations",
        "TypeInfo": "int, required",
        "Description": "Maximum number of iterations."
      },
      {
        "Name": "cond_input_locs",
        "TypeInfo": ", required",
        "Description": "The locations of cond's inputs in the given inputs."
      },
      {
        "Name": "func_input_locs",
        "TypeInfo": ", required",
        "Description": "The locations of func's inputs in the given inputs."
      },
      {
        "Name": "func_var_locs",
        "TypeInfo": ", required",
        "Description": "The locations of loop_vars among func's inputs."
      }
    ],
    "KeyVarNumArgs": "num_args",
    "ReturnType": null
  },
  {
    "Name": "_backward_while_loop",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_cond",
    "Description": "Run a if-then-else using user-defined condition and computation\n\nFrom:C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\control_flow.cc:1212",
    "NumArgs": 9,
    "Arguments": [
      {
        "Name": "cond",
        "TypeInfo": "Symbol",
        "Description": "Input graph for the condition."
      },
      {
        "Name": "then_branch",
        "TypeInfo": "Symbol",
        "Description": "Input graph for the then branch."
      },
      {
        "Name": "else_branch",
        "TypeInfo": "Symbol",
        "Description": "Input graph for the else branch."
      },
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "The input arrays that include data arrays and states."
      },
      {
        "Name": "num_args",
        "TypeInfo": "int, required",
        "Description": "Number of input arguments, including cond, then and else as three symbol inputs."
      },
      {
        "Name": "num_outputs",
        "TypeInfo": "int, required",
        "Description": "The number of outputs of the subgraph."
      },
      {
        "Name": "cond_input_locs",
        "TypeInfo": ", required",
        "Description": "The locations of cond's inputs in the given inputs."
      },
      {
        "Name": "then_input_locs",
        "TypeInfo": ", required",
        "Description": "The locations of then's inputs in the given inputs."
      },
      {
        "Name": "else_input_locs",
        "TypeInfo": ", required",
        "Description": "The locations of else's inputs in the given inputs."
      }
    ],
    "KeyVarNumArgs": "num_args",
    "ReturnType": null
  },
  {
    "Name": "_backward_cond",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "Custom",
    "Description": "Apply a custom operator implemented in a frontend language (like Python).\n\nCustom operators should override required methods like `forward` and `backward`.\nThe custom operator must be registered before it can be used.\nPlease check the tutorial here: http://mxnet.io/faq/new_op.html.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\custom\\custom.cc:L546",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "Input data for the custom operator."
      },
      {
        "Name": "op_type",
        "TypeInfo": "string",
        "Description": "Name of the custom operator. This is the name that is passed to `mx.operator.register` to register the operator."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_Custom",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "IdentityAttachKLSparseReg",
    "Description": "Apply a sparse regularization to the output a sigmoid activation function.",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data."
      },
      {
        "Name": "sparseness_target",
        "TypeInfo": "float, optional, default=0.100000001",
        "Description": "The sparseness target"
      },
      {
        "Name": "penalty",
        "TypeInfo": "float, optional, default=0.00100000005",
        "Description": "The tradeoff parameter for the sparseness penalty"
      },
      {
        "Name": "momentum",
        "TypeInfo": "float, optional, default=0.899999976",
        "Description": "The momentum for running average"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_image_crop",
    "Description": "Crop an image NDArray of shape (H x W x C) or (N x H x W x C) \nto the given size.\nExample:\n    .. code-block:: python\n        image = mx.nd.random.uniform(0, 255, (4, 2, 3)).astype(dtype=np.uint8)\n        mx.nd.image.crop(image, 1, 1, 2, 2)\n            [[[144  34   4]\n              [ 82 157  38]]\n\n             [[156 111 230]\n              [177  25  15]]]\n            <NDArray 2x2x3 @cpu(0)>\n        image = mx.nd.random.uniform(0, 255, (2, 4, 2, 3)).astype(dtype=np.uint8)\n        mx.nd.image.crop(image, 1, 1, 2, 2)            \n            [[[[ 35 198  50]\n               [242  94 168]]\n\n              [[223 119 129]\n               [249  14 154]]]\n\n\n              [[[137 215 106]\n                [ 79 174 133]]\n\n               [[116 142 109]\n                [ 35 239  50]]]]\n            <NDArray 2x2x2x3 @cpu(0)>\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\image\\crop.cc:L65",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input."
      },
      {
        "Name": "x",
        "TypeInfo": "int, required",
        "Description": "Left boundary of the cropping area."
      },
      {
        "Name": "y",
        "TypeInfo": "int, required",
        "Description": "Top boundary of the cropping area."
      },
      {
        "Name": "width",
        "TypeInfo": "int, required",
        "Description": "Width of the cropping area."
      },
      {
        "Name": "height",
        "TypeInfo": "int, required",
        "Description": "Height of the cropping area."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_image_crop",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_image_to_tensor",
    "Description": "Converts an image NDArray of shape (H x W x C) or (N x H x W x C) \nwith values in the range [0, 255] to a tensor NDArray of shape (C x H x W) or (N x C x H x W)\nwith values in the range [0, 1]\n\nExample:\n    .. code-block:: python\n        image = mx.nd.random.uniform(0, 255, (4, 2, 3)).astype(dtype=np.uint8)\n        to_tensor(image)\n            [[[ 0.85490197  0.72156864]\n              [ 0.09019608  0.74117649]\n              [ 0.61960787  0.92941177]\n              [ 0.96470588  0.1882353 ]]\n             [[ 0.6156863   0.73725492]\n              [ 0.46666667  0.98039216]\n              [ 0.44705883  0.45490196]\n              [ 0.01960784  0.8509804 ]]\n             [[ 0.39607844  0.03137255]\n              [ 0.72156864  0.52941179]\n              [ 0.16470589  0.7647059 ]\n              [ 0.05490196  0.70588237]]]\n             <NDArray 3x4x2 @cpu(0)>\n\n        image = mx.nd.random.uniform(0, 255, (2, 4, 2, 3)).astype(dtype=np.uint8)\n        to_tensor(image)\n            [[[[0.11764706 0.5803922 ]\n               [0.9411765  0.10588235]\n               [0.2627451  0.73333335]\n               [0.5647059  0.32156864]]\n              [[0.7176471  0.14117648]\n               [0.75686276 0.4117647 ]\n               [0.18431373 0.45490196]\n               [0.13333334 0.6156863 ]]\n              [[0.6392157  0.5372549 ]\n               [0.52156866 0.47058824]\n               [0.77254903 0.21568628]\n               [0.01568628 0.14901961]]]\n             [[[0.6117647  0.38431373]\n               [0.6784314  0.6117647 ]\n               [0.69411767 0.96862745]\n               [0.67058825 0.35686275]]\n              [[0.21960784 0.9411765 ]\n               [0.44705883 0.43529412]\n               [0.09803922 0.6666667 ]\n               [0.16862746 0.1254902 ]]\n              [[0.6156863  0.9019608 ]\n               [0.35686275 0.9019608 ]\n               [0.05882353 0.6509804 ]\n               [0.20784314 0.7490196 ]]]]\n            <NDArray 2x3x4x2 @cpu(0)>\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\image\\image_random.cc:L91",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input ndarray"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_image_normalize",
    "Description": "Normalize an tensor of shape (C x H x W) or (N x C x H x W) with mean and\n    standard deviation.\n\n    Given mean `(m1, ..., mn)` and std `(s\\ :sub:`1`\\ , ..., s\\ :sub:`n`)` for `n` channels,\n    this transform normalizes each channel of the input tensor with:\n\n.. math::\n\n        output[i] = (input[i] - m\\ :sub:`i`\\ ) / s\\ :sub:`i`\n\n    If mean or std is scalar, the same value will be applied to all channels.\n\n    Default value for mean is 0.0 and stand deviation is 1.0.\n\nExample:\n\n    .. code-block:: python\n        image = mx.nd.random.uniform(0, 1, (3, 4, 2))\n        normalize(image, mean=(0, 1, 2), std=(3, 2, 1))\n            [[[ 0.18293785  0.19761486]\n              [ 0.23839645  0.28142193]\n              [ 0.20092112  0.28598186]\n              [ 0.18162774  0.28241724]]\n             [[-0.2881726  -0.18821815]\n              [-0.17705294 -0.30780914]\n              [-0.2812064  -0.3512327 ]\n              [-0.05411351 -0.4716435 ]]\n             [[-1.0363373  -1.7273437 ]\n              [-1.6165586  -1.5223348 ]\n              [-1.208275   -1.1878313 ]\n              [-1.4711051  -1.5200229 ]]]\n            <NDArray 3x4x2 @cpu(0)>\n\n        image = mx.nd.random.uniform(0, 1, (2, 3, 4, 2))\n        normalize(image, mean=(0, 1, 2), std=(3, 2, 1))\n            [[[[ 0.18934818  0.13092826]\n               [ 0.3085322   0.27869293]\n               [ 0.02367868  0.11246539]\n               [ 0.0290431   0.2160573 ]]\n              [[-0.4898908  -0.31587923]\n               [-0.08369008 -0.02142242]\n               [-0.11092162 -0.42982462]\n               [-0.06499392 -0.06495637]]\n              [[-1.0213816  -1.526392  ]\n               [-1.2008414  -1.1990893 ]\n               [-1.5385206  -1.4795225 ]\n               [-1.2194707  -1.3211205 ]]]\n             [[[ 0.03942481  0.24021089]\n               [ 0.21330701  0.1940066 ]\n               [ 0.04778443  0.17912441]\n               [ 0.31488964  0.25287187]]\n              [[-0.23907584 -0.4470462 ]\n               [-0.29266903 -0.2631998 ]\n               [-0.3677222  -0.40683383]\n               [-0.11288315 -0.13154092]]\n              [[-1.5438497  -1.7834496 ]\n               [-1.431566   -1.8647819 ]\n               [-1.9812102  -1.675859  ]\n               [-1.3823645  -1.8503251 ]]]]\n            <NDArray 2x3x4x2 @cpu(0)>\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\image\\image_random.cc:L165",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input ndarray"
      },
      {
        "Name": "mean",
        "TypeInfo": ", optional, default=[0,0,0,0]",
        "Description": "Sequence of means for each channel. Default value is 0."
      },
      {
        "Name": "std",
        "TypeInfo": ", optional, default=[1,1,1,1]",
        "Description": "Sequence of standard deviations for each channel. Default value is 1."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_image_normalize",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_image_flip_left_right",
    "Description": "\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\image\\image_random.cc:L192",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_image_random_flip_left_right",
    "Description": "\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\image\\image_random.cc:L196",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_image_flip_top_bottom",
    "Description": "\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\image\\image_random.cc:L200",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_image_random_flip_top_bottom",
    "Description": "\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\image\\image_random.cc:L204",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_image_random_brightness",
    "Description": "\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\image\\image_random.cc:L208",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input."
      },
      {
        "Name": "min_factor",
        "TypeInfo": "float, required",
        "Description": "Minimum factor."
      },
      {
        "Name": "max_factor",
        "TypeInfo": "float, required",
        "Description": "Maximum factor."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_image_random_contrast",
    "Description": "\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\image\\image_random.cc:L214",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input."
      },
      {
        "Name": "min_factor",
        "TypeInfo": "float, required",
        "Description": "Minimum factor."
      },
      {
        "Name": "max_factor",
        "TypeInfo": "float, required",
        "Description": "Maximum factor."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_image_random_saturation",
    "Description": "\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\image\\image_random.cc:L221",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input."
      },
      {
        "Name": "min_factor",
        "TypeInfo": "float, required",
        "Description": "Minimum factor."
      },
      {
        "Name": "max_factor",
        "TypeInfo": "float, required",
        "Description": "Maximum factor."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_image_random_hue",
    "Description": "\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\image\\image_random.cc:L228",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input."
      },
      {
        "Name": "min_factor",
        "TypeInfo": "float, required",
        "Description": "Minimum factor."
      },
      {
        "Name": "max_factor",
        "TypeInfo": "float, required",
        "Description": "Maximum factor."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_image_random_color_jitter",
    "Description": "\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\image\\image_random.cc:L235",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input."
      },
      {
        "Name": "brightness",
        "TypeInfo": "float, required",
        "Description": "How much to jitter brightness."
      },
      {
        "Name": "contrast",
        "TypeInfo": "float, required",
        "Description": "How much to jitter contrast."
      },
      {
        "Name": "saturation",
        "TypeInfo": "float, required",
        "Description": "How much to jitter saturation."
      },
      {
        "Name": "hue",
        "TypeInfo": "float, required",
        "Description": "How much to jitter hue."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_image_adjust_lighting",
    "Description": "Adjust the lighting level of the input. Follow the AlexNet style.\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\image\\image_random.cc:L242",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input."
      },
      {
        "Name": "alpha",
        "TypeInfo": ", required",
        "Description": "The lighting alphas for the R, G, B channels."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_image_random_lighting",
    "Description": "Randomly add PCA noise. Follow the AlexNet style.\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\image\\image_random.cc:L249",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input."
      },
      {
        "Name": "alpha_std",
        "TypeInfo": "float, optional, default=0.0500000007",
        "Description": "Level of the lighting noise."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_image_resize",
    "Description": "Resize an image NDArray of shape (H x W x C) or (N x H x W x C) \nto the given size\nExample:\n    .. code-block:: python\n        image = mx.nd.random.uniform(0, 255, (4, 2, 3)).astype(dtype=np.uint8)\n        mx.nd.image.resize(image, (3, 3))\n            [[[124 111 197]\n              [158  80 155]\n              [193  50 112]]\n\n             [[110 100 113]\n              [134 165 148]\n              [157 231 182]]\n\n             [[202 176 134]\n              [174 191 149]\n              [147 207 164]]]\n            <NDArray 3x3x3 @cpu(0)>\n        image = mx.nd.random.uniform(0, 255, (2, 4, 2, 3)).astype(dtype=np.uint8)\n        mx.nd.image.resize(image, (2, 2))            \n            [[[[ 59 133  80]\n               [187 114 153]]\n\n              [[ 38 142  39]\n               [207 131 124]]]\n\n\n              [[[117 125 136]\n               [191 166 150]]\n\n              [[129  63 113]\n               [182 109  48]]]]\n            <NDArray 2x2x2x3 @cpu(0)>\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\image\\resize.cc:L70",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input."
      },
      {
        "Name": "size",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "Size of new image. Could be (width, height) or (size)"
      },
      {
        "Name": "keep_ratio",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether to resize the short edge or both edges to `size`, if size is give as an integer."
      },
      {
        "Name": "interp",
        "TypeInfo": "int, optional, default='1'",
        "Description": "Interpolation method for resizing. By default uses bilinear interpolationOptions are INTER_NEAREST - a nearest-neighbor interpolationINTER_LINEAR - a bilinear interpolationINTER_AREA - resampling using pixel area relationINTER_CUBIC - a bicubic interpolation over 4x4 pixel neighborhoodINTER_LANCZOS4 - a Lanczos interpolation over 8x8 pixel neighborhoodNote that the GPU version only support bilinear interpolation(1) and the result on cpu would be slightly different from gpu.It uses opencv resize function which tend to align center on cpuwhile using contrib.bilinearResize2D which aligns corner on gpu"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "LeakyReLU",
    "Description": "Applies Leaky rectified linear unit activation element-wise to the input.\n\nLeaky ReLUs attempt to fix the \"dying ReLU\" problem by allowing a small `slope`\nwhen the input is negative and has a slope of one when input is positive.\n\nThe following modified ReLU Activation functions are supported:\n\n- *elu*: Exponential Linear Unit. `y = x > 0 ? x : slope * (exp(x)-1)`\n- *selu*: Scaled Exponential Linear Unit. `y = lambda * (x > 0 ? x : alpha * (exp(x) - 1))` where\n  *lambda = 1.0507009873554804934193349852946* and *alpha = 1.6732632423543772848170429916717*.\n- *leaky*: Leaky ReLU. `y = x > 0 ? x : slope * x`\n- *prelu*: Parametric ReLU. This is same as *leaky* except that `slope` is learnt during training.\n- *rrelu*: Randomized ReLU. same as *leaky* but the `slope` is uniformly and randomly chosen from\n  *[lower_bound, upper_bound)* for training, while fixed to be\n  *(lower_bound+upper_bound)/2* for inference.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\leaky_relu.cc:L65",
    "NumArgs": 6,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data to activation function."
      },
      {
        "Name": "gamma",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Slope parameter for PReLU. Only required when act_type is 'prelu'. It should be either a vector of size 1, or the same size as the second dimension of data."
      },
      {
        "Name": "act_type",
        "TypeInfo": "{'elu', 'gelu', 'leaky', 'prelu', 'rrelu', 'selu'},optional, default='leaky'",
        "Description": "Activation function to be applied."
      },
      {
        "Name": "slope",
        "TypeInfo": "float, optional, default=0.25",
        "Description": "Init slope for the activation. (For leaky and elu only)"
      },
      {
        "Name": "lower_bound",
        "TypeInfo": "float, optional, default=0.125",
        "Description": "Lower bound of random slope. (For rrelu only)"
      },
      {
        "Name": "upper_bound",
        "TypeInfo": "float, optional, default=0.333999991",
        "Description": "Upper bound of random slope. (For rrelu only)"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "softmax_cross_entropy",
    "Description": "Calculate cross entropy of softmax output and one-hot label.\n\n- This operator computes the cross entropy in two steps:\n  - Applies softmax function on the input array.\n  - Computes and returns the cross entropy loss between the softmax output and the labels.\n\n- The softmax function and cross entropy loss is given by:\n\n  - Softmax Function:\n\n  .. math:: \\text{softmax}(x)_i = \\frac{exp(x_i)}{\\sum_j exp(x_j)}\n\n  - Cross Entropy Function:\n\n  .. math:: \\text{CE(label, output)} = - \\sum_i \\text{label}_i \\log(\\text{output}_i)\n\nExample::\n\n  x = [[1, 2, 3],\n       [11, 7, 5]]\n\n  label = [2, 0]\n\n  softmax(x) = [[0.09003057, 0.24472848, 0.66524094],\n                [0.97962922, 0.01794253, 0.00242826]]\n\n  softmax_cross_entropy(data, label) = - log(0.66524084) - log(0.97962922) = 0.4281871\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\loss_binary_op.cc:L59",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data"
      },
      {
        "Name": "label",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input label"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_softmax_cross_entropy",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "Activation",
    "Description": "Applies an activation function element-wise to the input.\n\nThe following activation functions are supported:\n\n- `relu`: Rectified Linear Unit, :math:`y = max(x, 0)`\n- `sigmoid`: :math:`y = \\frac{1}{1 + exp(-x)}`\n- `tanh`: Hyperbolic tangent, :math:`y = \\frac{exp(x) - exp(-x)}{exp(x) + exp(-x)}`\n- `softrelu`: Soft ReLU, or SoftPlus, :math:`y = log(1 + exp(x))`\n- `softsign`: :math:`y = \\frac{x}{1 + abs(x)}`\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\nn\\activation.cc:L167",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      },
      {
        "Name": "act_type",
        "TypeInfo": "{'relu', 'sigmoid', 'softrelu', 'softsign', 'tanh'}, required",
        "Description": "Activation function to be applied."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_Activation",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "BatchNorm",
    "Description": "Batch normalization.\n\nNormalizes a data batch by mean and variance, and applies a scale ``gamma`` as\nwell as offset ``beta``.\n\nAssume the input has more than one dimension and we normalize along axis 1.\nWe first compute the mean and variance along this axis:\n\n.. math::\n\n  data\\_mean[i] = mean(data[:,i,:,...]) \\\\\n  data\\_var[i] = var(data[:,i,:,...])\n\nThen compute the normalized output, which has the same shape as input, as following:\n\n.. math::\n\n  out[:,i,:,...] = \\frac{data[:,i,:,...] - data\\_mean[i]}{\\sqrt{data\\_var[i]+\\epsilon}} * gamma[i] + beta[i]\n\nBoth *mean* and *var* returns a scalar by treating the input as a vector.\n\nAssume the input has size *k* on axis 1, then both ``gamma`` and ``beta``\nhave shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and\nthe inverse of ``data_var``, which are needed for the backward pass. Note that gradient of these\ntwo outputs are blocked.\n\nBesides the inputs and the outputs, this operator accepts two auxiliary\nstates, ``moving_mean`` and ``moving_var``, which are *k*-length\nvectors. They are global statistics for the whole dataset, which are updated\nby::\n\n  moving_mean = moving_mean * momentum + data_mean * (1 - momentum)\n  moving_var = moving_var * momentum + data_var * (1 - momentum)\n\nIf ``use_global_stats`` is set to be true, then ``moving_mean`` and\n``moving_var`` are used instead of ``data_mean`` and ``data_var`` to compute\nthe output. It is often used during inference.\n\nThe parameter ``axis`` specifies which axis of the input shape denotes\nthe 'channel' (separately normalized groups).  The default is 1.  Specifying -1 sets the channel\naxis to be the last item in the input shape.\n\nBoth ``gamma`` and ``beta`` are learnable parameters. But if ``fix_gamma`` is true,\nthen set ``gamma`` to 1 and its gradient to 0.\n\n.. Note::\n  When ``fix_gamma`` is set to True, no sparse support is provided. If ``fix_gamma is`` set to False,\n  the sparse tensors will fallback.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\nn\\batch_norm.cc:L572",
    "NumArgs": 12,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data to batch normalization"
      },
      {
        "Name": "gamma",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "gamma array"
      },
      {
        "Name": "beta",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "beta array"
      },
      {
        "Name": "moving_mean",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "running mean of input"
      },
      {
        "Name": "moving_var",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "running variance of input"
      },
      {
        "Name": "eps",
        "TypeInfo": "double, optional, default=0.0010000000474974513",
        "Description": "Epsilon to prevent div 0. Must be no less than CUDNN_BN_MIN_EPSILON defined in cudnn.h when using cudnn (usually 1e-5)"
      },
      {
        "Name": "momentum",
        "TypeInfo": "float, optional, default=0.899999976",
        "Description": "Momentum for moving average"
      },
      {
        "Name": "fix_gamma",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "Fix gamma while training"
      },
      {
        "Name": "use_global_stats",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether use global moving statistics instead of local batch-norm. This will force change batch-norm into a scale shift operator."
      },
      {
        "Name": "output_mean_var",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Output the mean and inverse std "
      },
      {
        "Name": "axis",
        "TypeInfo": "int, optional, default='1'",
        "Description": "Specify which shape axis the channel is specified"
      },
      {
        "Name": "cudnn_off",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Do not select CUDNN operator, if available"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_BatchNorm",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "Concat",
    "Description": "Joins input arrays along a given axis.\n\n.. note:: `Concat` is deprecated. Use `concat` instead.\n\nThe dimensions of the input arrays should be the same except the axis along\nwhich they will be concatenated.\nThe dimension of the output array along the concatenated axis will be equal\nto the sum of the corresponding dimensions of the input arrays.\n\nThe storage type of ``concat`` output depends on storage types of inputs\n\n- concat(csr, csr, ..., csr, dim=0) = csr\n- otherwise, ``concat`` generates output with default storage\n\nExample::\n\n   x = [[1,1],[2,2]]\n   y = [[3,3],[4,4],[5,5]]\n   z = [[6,6], [7,7],[8,8]]\n\n   concat(x,y,z,dim=0) = [[ 1.,  1.],\n                          [ 2.,  2.],\n                          [ 3.,  3.],\n                          [ 4.,  4.],\n                          [ 5.,  5.],\n                          [ 6.,  6.],\n                          [ 7.,  7.],\n                          [ 8.,  8.]]\n\n   Note that you cannot concat x,y,z along dimension 1 since dimension\n   0 is not the same for all the input arrays.\n\n   concat(y,z,dim=1) = [[ 3.,  3.,  6.,  6.],\n                         [ 4.,  4.,  7.,  7.],\n                         [ 5.,  5.,  8.,  8.]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\nn\\concat.cc:L371",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "List of arrays to concatenate"
      },
      {
        "Name": "num_args",
        "TypeInfo": "int, required",
        "Description": "Number of inputs to be concated."
      },
      {
        "Name": "dim",
        "TypeInfo": "int, optional, default='1'",
        "Description": "the dimension to be concated."
      }
    ],
    "KeyVarNumArgs": "num_args",
    "ReturnType": null
  },
  {
    "Name": "_backward_Concat",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_rnn_param_concat",
    "Description": "",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "List of arrays to concatenate"
      },
      {
        "Name": "num_args",
        "TypeInfo": "int, required",
        "Description": "Number of inputs to be concated."
      },
      {
        "Name": "dim",
        "TypeInfo": "int, optional, default='1'",
        "Description": "the dimension to be concated."
      }
    ],
    "KeyVarNumArgs": "num_args",
    "ReturnType": null
  },
  {
    "Name": "Convolution",
    "Description": "Compute *N*-D convolution on *(N+2)*-D input.\n\nIn the 2-D convolution, given input data with shape *(batch_size,\nchannel, height, width)*, the output is computed by\n\n.. math::\n\n   out[n,i,:,:] = bias[i] + \\sum_{j=0}^{channel} data[n,j,:,:] \\star\n   weight[i,j,:,:]\n\nwhere :math:`\\star` is the 2-D cross-correlation operator.\n\nFor general 2-D convolution, the shapes are\n\n- **data**: *(batch_size, channel, height, width)*\n- **weight**: *(num_filter, channel, kernel[0], kernel[1])*\n- **bias**: *(num_filter,)*\n- **out**: *(batch_size, num_filter, out_height, out_width)*.\n\nDefine::\n\n  f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1\n\nthen we have::\n\n  out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])\n  out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])\n\nIf ``no_bias`` is set to be true, then the ``bias`` term is ignored.\n\nThe default data ``layout`` is *NCHW*, namely *(batch_size, channel, height,\nwidth)*. We can choose other layouts such as *NWC*.\n\nIf ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``\nevenly into *g* parts along the channel axis, and also evenly split ``weight``\nalong the first dimension. Next compute the convolution on the *i*-th part of\nthe data with the *i*-th weight part. The output is obtained by concatenating all\nthe *g* results.\n\n1-D convolution does not have *height* dimension but only *width* in space.\n\n- **data**: *(batch_size, channel, width)*\n- **weight**: *(num_filter, channel, kernel[0])*\n- **bias**: *(num_filter,)*\n- **out**: *(batch_size, num_filter, out_width)*.\n\n3-D convolution adds an additional *depth* dimension besides *height* and\n*width*. The shapes are\n\n- **data**: *(batch_size, channel, depth, height, width)*\n- **weight**: *(num_filter, channel, kernel[0], kernel[1], kernel[2])*\n- **bias**: *(num_filter,)*\n- **out**: *(batch_size, num_filter, out_depth, out_height, out_width)*.\n\nBoth ``weight`` and ``bias`` are learnable parameters.\n\nThere are other options to tune the performance.\n\n- **cudnn_tune**: enable this option leads to higher startup time but may give\n  faster speed. Options are\n\n  - **off**: no tuning\n  - **limited_workspace**:run test and pick the fastest algorithm that doesn't\n    exceed workspace limit.\n  - **fastest**: pick the fastest algorithm and ignore workspace limit.\n  - **None** (default): the behavior is determined by environment variable\n    ``MXNET_CUDNN_AUTOTUNE_DEFAULT``. 0 for off, 1 for limited workspace\n    (default), 2 for fastest.\n\n- **workspace**: A large number leads to more (GPU) memory usage but may improve\n  the performance.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\nn\\convolution.cc:L472",
    "NumArgs": 14,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data to the ConvolutionOp."
      },
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight matrix."
      },
      {
        "Name": "bias",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Bias parameter."
      },
      {
        "Name": "kernel",
        "TypeInfo": "Shape(tuple), required",
        "Description": "Convolution kernel size: (w,), (h, w) or (d, h, w)"
      },
      {
        "Name": "stride",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension."
      },
      {
        "Name": "dilate",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension."
      },
      {
        "Name": "pad",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding."
      },
      {
        "Name": "num_filter",
        "TypeInfo": "int (non-negative), required",
        "Description": "Convolution filter(channel) number"
      },
      {
        "Name": "num_group",
        "TypeInfo": "int (non-negative), optional, default=1",
        "Description": "Number of group partitions."
      },
      {
        "Name": "workspace",
        "TypeInfo": "long (non-negative), optional, default=1024",
        "Description": "Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used."
      },
      {
        "Name": "no_bias",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether to disable bias parameter."
      },
      {
        "Name": "cudnn_tune",
        "TypeInfo": "{None, 'fastest', 'limited_workspace', 'off'},optional, default='None'",
        "Description": "Whether to pick convolution algo by running performance test."
      },
      {
        "Name": "cudnn_off",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Turn off cudnn for this layer."
      },
      {
        "Name": "layout",
        "TypeInfo": "{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC'},optional, default='None'",
        "Description": "Set layout for input, output and weight. Empty for\n    default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_Convolution",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "CTCLoss",
    "Description": "Connectionist Temporal Classification Loss.\n\n.. note:: The existing alias ``contrib_CTCLoss`` is deprecated.\n\nThe shapes of the inputs and outputs:\n\n- **data**: `(sequence_length, batch_size, alphabet_size)`\n- **label**: `(batch_size, label_sequence_length)`\n- **out**: `(batch_size)`\n\nThe `data` tensor consists of sequences of activation vectors (without applying softmax),\nwith i-th channel in the last dimension corresponding to i-th label\nfor i between 0 and alphabet_size-1 (i.e always 0-indexed).\nAlphabet size should include one additional value reserved for blank label.\nWhen `blank_label` is ``\"first\"``, the ``0``-th channel is be reserved for\nactivation of blank label, or otherwise if it is \"last\", ``(alphabet_size-1)``-th channel should be\nreserved for blank label.\n\n``label`` is an index matrix of integers. When `blank_label` is ``\"first\"``,\nthe value 0 is then reserved for blank label, and should not be passed in this matrix. Otherwise,\nwhen `blank_label` is ``\"last\"``, the value `(alphabet_size-1)` is reserved for blank label.\n\nIf a sequence of labels is shorter than *label_sequence_length*, use the special\npadding value at the end of the sequence to conform it to the correct\nlength. The padding value is `0` when `blank_label` is ``\"first\"``, and `-1` otherwise.\n\nFor example, suppose the vocabulary is `[a, b, c]`, and in one batch we have three sequences\n'ba', 'cbb', and 'abac'. When `blank_label` is ``\"first\"``, we can index the labels as\n`{'a': 1, 'b': 2, 'c': 3}`, and we reserve the 0-th channel for blank label in data tensor.\nThe resulting `label` tensor should be padded to be::\n\n  [[2, 1, 0, 0], [3, 2, 2, 0], [1, 2, 1, 3]]\n\nWhen `blank_label` is ``\"last\"``, we can index the labels as\n`{'a': 0, 'b': 1, 'c': 2}`, and we reserve the channel index 3 for blank label in data tensor.\nThe resulting `label` tensor should be padded to be::\n\n  [[1, 0, -1, -1], [2, 1, 1, -1], [0, 1, 0, 2]]\n\n``out`` is a list of CTC loss values, one per example in the batch.\n\nSee *Connectionist Temporal Classification: Labelling Unsegmented\nSequence Data with Recurrent Neural Networks*, A. Graves *et al*. for more\ninformation on the definition and the algorithm.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\nn\\ctc_loss.cc:L100",
    "NumArgs": 7,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input ndarray"
      },
      {
        "Name": "label",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Ground-truth labels for the loss."
      },
      {
        "Name": "data_lengths",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Lengths of data for each of the samples. Only required when use_data_lengths is true."
      },
      {
        "Name": "label_lengths",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Lengths of labels for each of the samples. Only required when use_label_lengths is true."
      },
      {
        "Name": "use_data_lengths",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether the data lenghts are decided by `data_lengths`. If false, the lengths are equal to the max sequence length."
      },
      {
        "Name": "use_label_lengths",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether the label lenghts are decided by `label_lengths`, or derived from `padding_mask`. If false, the lengths are derived from the first occurrence of the value of `padding_mask`. The value of `padding_mask` is ``0`` when first CTC label is reserved for blank, and ``-1`` when last label is reserved for blank. See `blank_label`."
      },
      {
        "Name": "blank_label",
        "TypeInfo": "{'first', 'last'},optional, default='first'",
        "Description": "Set the label that is reserved for blank label.If \"first\", 0-th label is reserved, and label values for tokens in the vocabulary are between ``1`` and ``alphabet_size-1``, and the padding mask is ``-1``. If \"last\", last label value ``alphabet_size-1`` is reserved for blank label instead, and label values for tokens in the vocabulary are between ``0`` and ``alphabet_size-2``, and the padding mask is ``0``."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_ctc_loss",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "Deconvolution",
    "Description": "Computes 1D or 2D transposed convolution (aka fractionally strided convolution) of the input tensor. This operation can be seen as the gradient of Convolution operation with respect to its input. Convolution usually reduces the size of the input. Transposed convolution works the other way, going from a smaller input to a larger output while preserving the connectivity pattern.",
    "NumArgs": 16,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input tensor to the deconvolution operation."
      },
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weights representing the kernel."
      },
      {
        "Name": "bias",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Bias added to the result after the deconvolution operation."
      },
      {
        "Name": "kernel",
        "TypeInfo": "Shape(tuple), required",
        "Description": "Deconvolution kernel size: (w,), (h, w) or (d, h, w). This is same as the kernel size used for the corresponding convolution"
      },
      {
        "Name": "stride",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "The stride used for the corresponding convolution: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension."
      },
      {
        "Name": "dilate",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "Dilation factor for each dimension of the input: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension."
      },
      {
        "Name": "pad",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "The amount of implicit zero padding added during convolution for each dimension of the input: (w,), (h, w) or (d, h, w). ``(kernel-1)/2`` is usually a good choice. If `target_shape` is set, `pad` will be ignored and a padding that will generate the target shape will be used. Defaults to no padding."
      },
      {
        "Name": "adj",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "Adjustment for output shape: (w,), (h, w) or (d, h, w). If `target_shape` is set, `adj` will be ignored and computed accordingly."
      },
      {
        "Name": "target_shape",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "Shape of the output tensor: (w,), (h, w) or (d, h, w)."
      },
      {
        "Name": "num_filter",
        "TypeInfo": "int (non-negative), required",
        "Description": "Number of output filters."
      },
      {
        "Name": "num_group",
        "TypeInfo": "int (non-negative), optional, default=1",
        "Description": "Number of groups partition."
      },
      {
        "Name": "workspace",
        "TypeInfo": "long (non-negative), optional, default=512",
        "Description": "Maximum temporary workspace allowed (MB) in deconvolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the deconvolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used."
      },
      {
        "Name": "no_bias",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "Whether to disable bias parameter."
      },
      {
        "Name": "cudnn_tune",
        "TypeInfo": "{None, 'fastest', 'limited_workspace', 'off'},optional, default='None'",
        "Description": "Whether to pick convolution algorithm by running performance test."
      },
      {
        "Name": "cudnn_off",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Turn off cudnn for this layer."
      },
      {
        "Name": "layout",
        "TypeInfo": "{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC'},optional, default='None'",
        "Description": "Set layout for input, output and weight. Empty for default layout, NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_Deconvolution",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "Dropout",
    "Description": "Applies dropout operation to input array.\n\n- During training, each element of the input is set to zero with probability p.\n  The whole array is rescaled by :math:`1/(1-p)` to keep the expected\n  sum of the input unchanged.\n\n- During testing, this operator does not change the input if mode is 'training'.\n  If mode is 'always', the same computaion as during training will be applied.\n\nExample::\n\n  random.seed(998)\n  input_array = array([[3., 0.5,  -0.5,  2., 7.],\n                      [2., -0.4,   7.,  3., 0.2]])\n  a = symbol.Variable('a')\n  dropout = symbol.Dropout(a, p = 0.2)\n  executor = dropout.simple_bind(a = input_array.shape)\n\n  ## If training\n  executor.forward(is_train = True, a = input_array)\n  executor.outputs\n  [[ 3.75   0.625 -0.     2.5    8.75 ]\n   [ 2.5   -0.5    8.75   3.75   0.   ]]\n\n  ## If testing\n  executor.forward(is_train = False, a = input_array)\n  executor.outputs\n  [[ 3.     0.5   -0.5    2.     7.   ]\n   [ 2.    -0.4    7.     3.     0.2  ]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\nn\\dropout.cc:L97",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input array to which dropout will be applied."
      },
      {
        "Name": "p",
        "TypeInfo": "float, optional, default=0.5",
        "Description": "Fraction of the input that gets dropped out during training time."
      },
      {
        "Name": "mode",
        "TypeInfo": "{'always', 'training'},optional, default='training'",
        "Description": "Whether to only turn on dropout during training or to also turn on for inference."
      },
      {
        "Name": "axes",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "Axes for variational dropout kernel."
      },
      {
        "Name": "cudnn_off",
        "TypeInfo": "boolean or None, optional, default=0",
        "Description": "Whether to turn off cudnn in dropout operator. This option is ignored if axes is specified."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_Dropout",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "FullyConnected",
    "Description": "Applies a linear transformation: :math:`Y = XW^T + b`.\n\nIf ``flatten`` is set to be true, then the shapes are:\n\n- **data**: `(batch_size, x1, x2, ..., xn)`\n- **weight**: `(num_hidden, x1 * x2 * ... * xn)`\n- **bias**: `(num_hidden,)`\n- **out**: `(batch_size, num_hidden)`\n\nIf ``flatten`` is set to be false, then the shapes are:\n\n- **data**: `(x1, x2, ..., xn, input_dim)`\n- **weight**: `(num_hidden, input_dim)`\n- **bias**: `(num_hidden,)`\n- **out**: `(x1, x2, ..., xn, num_hidden)`\n\nThe learnable parameters include both ``weight`` and ``bias``.\n\nIf ``no_bias`` is set to be true, then the ``bias`` term is ignored.\n\n.. Note::\n\n    The sparse support for FullyConnected is limited to forward evaluation with `row_sparse`\n    weight and bias, where the length of `weight.indices` and `bias.indices` must be equal\n    to `num_hidden`. This could be useful for model inference with `row_sparse` weights\n    trained with importance sampling or noise contrastive estimation.\n\n    To compute linear transformation with 'csr' sparse data, sparse.dot is recommended instead\n    of sparse.FullyConnected.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\nn\\fully_connected.cc:L277",
    "NumArgs": 6,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data."
      },
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight matrix."
      },
      {
        "Name": "bias",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Bias parameter."
      },
      {
        "Name": "num_hidden",
        "TypeInfo": "int, required",
        "Description": "Number of hidden nodes of the output."
      },
      {
        "Name": "no_bias",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether to disable bias parameter."
      },
      {
        "Name": "flatten",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "Whether to collapse all but the first axis of the input data tensor."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_FullyConnected",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "LayerNorm",
    "Description": "Layer normalization.\n\nNormalizes the channels of the input tensor by mean and variance, and applies a scale ``gamma`` as\nwell as offset ``beta``.\n\nAssume the input has more than one dimension and we normalize along axis 1.\nWe first compute the mean and variance along this axis and then \ncompute the normalized output, which has the same shape as input, as following:\n\n.. math::\n\n  out = \\frac{data - mean(data, axis)}{\\sqrt{var(data, axis) + \\epsilon}} * gamma + beta\n\nBoth ``gamma`` and ``beta`` are learnable parameters.\n\nUnlike BatchNorm and InstanceNorm,  the *mean* and *var* are computed along the channel dimension.\n\nAssume the input has size *k* on axis 1, then both ``gamma`` and ``beta``\nhave shape *(k,)*. If ``output_mean_var`` is set to be true, then outputs both ``data_mean`` and\n``data_std``. Note that no gradient will be passed through these two outputs.\n\nThe parameter ``axis`` specifies which axis of the input shape denotes\nthe 'channel' (separately normalized groups).  The default is -1, which sets the channel\naxis to be the last item in the input shape.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\nn\\layer_norm.cc:L155",
    "NumArgs": 6,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data to layer normalization"
      },
      {
        "Name": "gamma",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "gamma array"
      },
      {
        "Name": "beta",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "beta array"
      },
      {
        "Name": "axis",
        "TypeInfo": "int, optional, default='-1'",
        "Description": "The axis to perform layer normalization. Usually, this should be be axis of the channel dimension. Negative values means indexing from right to left."
      },
      {
        "Name": "eps",
        "TypeInfo": "float, optional, default=9.99999975e-06",
        "Description": "An `epsilon` parameter to prevent division by 0."
      },
      {
        "Name": "output_mean_var",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Output the mean and std calculated along the given axis."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_LayerNorm",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "LRN",
    "Description": "Applies local response normalization to the input.\n\nThe local response normalization layer performs \"lateral inhibition\" by normalizing\nover local input regions.\n\nIf :math:`a_{x,y}^{i}` is the activity of a neuron computed by applying kernel :math:`i` at position\n:math:`(x, y)` and then applying the ReLU nonlinearity, the response-normalized\nactivity :math:`b_{x,y}^{i}` is given by the expression:\n\n.. math::\n   b_{x,y}^{i} = \\frac{a_{x,y}^{i}}{\\Bigg({k + \\frac{\\alpha}{n} \\sum_{j=max(0, i-\\frac{n}{2})}^{min(N-1, i+\\frac{n}{2})} (a_{x,y}^{j})^{2}}\\Bigg)^{\\beta}}\n\nwhere the sum runs over :math:`n` \"adjacent\" kernel maps at the same spatial position, and :math:`N` is the total\nnumber of kernels in the layer.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\nn\\lrn.cc:L164",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data to LRN"
      },
      {
        "Name": "alpha",
        "TypeInfo": "float, optional, default=9.99999975e-05",
        "Description": "The variance scaling parameter :math:`\u0007lpha` in the LRN expression."
      },
      {
        "Name": "beta",
        "TypeInfo": "float, optional, default=0.75",
        "Description": "The power parameter :math:`\beta` in the LRN expression."
      },
      {
        "Name": "knorm",
        "TypeInfo": "float, optional, default=2",
        "Description": "The parameter :math:`k` in the LRN expression."
      },
      {
        "Name": "nsize",
        "TypeInfo": "int (non-negative), required",
        "Description": "normalization window width in elements."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_LRN",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "moments",
    "Description": "\nCalculate the mean and variance of `data`.\n\nThe mean and variance are calculated by aggregating the contents of data across axes.\nIf x is 1-D and axes = [0] this is just the mean and variance of a vector.\n\nExample:\n\n     x = [[1, 2, 3], [4, 5, 6]]\n     mean, var = moments(data=x, axes=[0])\n     mean = [2.5, 3.5, 4.5]\n     var = [2.25, 2.25, 2.25]\n     mean, var = moments(data=x, axes=[1])\n     mean = [2.0, 5.0]\n     var = [0.66666667, 0.66666667]\n     mean, var = moments(data=x, axis=[0, 1])\n     mean = [3.5]\n     var = [2.9166667]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\nn\\moments.cc:L54",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input ndarray"
      },
      {
        "Name": "axes",
        "TypeInfo": "Shape or None, optional, default=None",
        "Description": "Array of ints. Axes along which to compute mean and variance."
      },
      {
        "Name": "keepdims",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "produce moments with the same dimensionality as the input."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_moments",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "Pooling",
    "Description": "Performs pooling on the input.\n\nThe shapes for 1-D pooling are\n\n- **data** and **out**: *(batch_size, channel, width)* (NCW layout) or\n  *(batch_size, width, channel)* (NWC layout),\n\nThe shapes for 2-D pooling are\n\n- **data** and **out**: *(batch_size, channel, height, width)* (NCHW layout) or\n  *(batch_size, height, width, channel)* (NHWC layout),\n\n    out_height = f(height, kernel[0], pad[0], stride[0])\n    out_width = f(width, kernel[1], pad[1], stride[1])\n\nThe definition of *f* depends on ``pooling_convention``, which has two options:\n\n- **valid** (default)::\n\n    f(x, k, p, s) = floor((x+2*p-k)/s)+1\n\n- **full**, which is compatible with Caffe::\n\n    f(x, k, p, s) = ceil((x+2*p-k)/s)+1\n\nBut ``global_pool`` is set to be true, then do a global pooling, namely reset\n``kernel=(height, width)``.\n\nThree pooling options are supported by ``pool_type``:\n\n- **avg**: average pooling\n- **max**: max pooling\n- **sum**: sum pooling\n- **lp**: Lp pooling\n\nFor 3-D pooling, an additional *depth* dimension is added before\n*height*. Namely the input data and output will have shape *(batch_size, channel, depth,\nheight, width)* (NCDHW layout) or *(batch_size, depth, height, width, channel)* (NDHWC layout).\n\nNotes on Lp pooling:\n\nLp pooling was first introduced by this paper: https://arxiv.org/pdf/1204.3968.pdf.\nL-1 pooling is simply sum pooling, while L-inf pooling is simply max pooling.\nWe can see that Lp pooling stands between those two, in practice the most common value for p is 2.\n\nFor each window ``X``, the mathematical expression for Lp pooling is:\n\n:math:`f(X) = \\sqrt[p]{\\sum_{x}^{X} x^p}`\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\nn\\pooling.cc:L416",
    "NumArgs": 11,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data to the pooling operator."
      },
      {
        "Name": "kernel",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "Pooling kernel size: (y, x) or (d, y, x)"
      },
      {
        "Name": "pool_type",
        "TypeInfo": "{'avg', 'lp', 'max', 'sum'},optional, default='max'",
        "Description": "Pooling type to be applied."
      },
      {
        "Name": "global_pool",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Ignore kernel size, do global pooling based on current input feature map. "
      },
      {
        "Name": "cudnn_off",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Turn off cudnn pooling and use MXNet pooling operator. "
      },
      {
        "Name": "pooling_convention",
        "TypeInfo": "{'full', 'same', 'valid'},optional, default='valid'",
        "Description": "Pooling convention to be applied."
      },
      {
        "Name": "stride",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "Stride: for pooling (y, x) or (d, y, x). Defaults to 1 for each dimension."
      },
      {
        "Name": "pad",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "Pad for pooling: (y, x) or (d, y, x). Defaults to no padding."
      },
      {
        "Name": "p_value",
        "TypeInfo": "int or None, optional, default='None'",
        "Description": "Value of p for Lp pooling, can be 1 or 2, required for Lp Pooling."
      },
      {
        "Name": "count_include_pad",
        "TypeInfo": "boolean or None, optional, default=None",
        "Description": "Only used for AvgPool, specify whether to count padding elements for averagecalculation. For example, with a 5*5 kernel on a 3*3 corner of a image,the sum of the 9 valid elements will be divided by 25 if this is set to true,or it will be divided by 9 if this is set to false. Defaults to true."
      },
      {
        "Name": "layout",
        "TypeInfo": "{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC', 'NWC'},optional, default='None'",
        "Description": "Set layout for input and output. Empty for\n    default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_Pooling",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "softmax",
    "Description": "Applies the softmax function.\n\nThe resulting array contains elements in the range (0,1) and the elements along the given axis sum up to 1.\n\n.. math::\n   softmax(\\mathbf{z/t})_j = \\frac{e^{z_j/t}}{\\sum_{k=1}^K e^{z_k/t}}\n\nfor :math:`j = 1, ..., K`\n\nt is the temperature parameter in softmax function. By default, t equals 1.0\n\nExample::\n\n  x = [[ 1.  1.  1.]\n       [ 1.  1.  1.]]\n\n  softmax(x,axis=0) = [[ 0.5  0.5  0.5]\n                       [ 0.5  0.5  0.5]]\n\n  softmax(x,axis=1) = [[ 0.33333334,  0.33333334,  0.33333334],\n                       [ 0.33333334,  0.33333334,  0.33333334]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\nn\\softmax.cc:L93",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      },
      {
        "Name": "axis",
        "TypeInfo": "int, optional, default='-1'",
        "Description": "The axis along which to compute softmax."
      },
      {
        "Name": "temperature",
        "TypeInfo": "double or None, optional, default=None",
        "Description": "Temperature parameter in softmax"
      },
      {
        "Name": "dtype",
        "TypeInfo": "{None, 'float16', 'float32', 'float64'},optional, default='None'",
        "Description": "DType of the output in case this can't be inferred. Defaults to the same as input's dtype if not defined (dtype=None)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_softmax",
    "Description": "",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "args",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "Positional input arguments"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "softmin",
    "Description": "Applies the softmin function.\n\nThe resulting array contains elements in the range (0,1) and the elements along the given axis sum\nup to 1.\n\n.. math::\n   softmin(\\mathbf{z/t})_j = \\frac{e^{-z_j/t}}{\\sum_{k=1}^K e^{-z_k/t}}\n\nfor :math:`j = 1, ..., K`\n\nt is the temperature parameter in softmax function. By default, t equals 1.0\n\nExample::\n\n  x = [[ 1.  2.  3.]\n       [ 3.  2.  1.]]\n\n  softmin(x,axis=0) = [[ 0.88079703,  0.5,  0.11920292],\n                       [ 0.11920292,  0.5,  0.88079703]]\n\n  softmin(x,axis=1) = [[ 0.66524094,  0.24472848,  0.09003057],\n                       [ 0.09003057,  0.24472848,  0.66524094]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\nn\\softmax.cc:L153",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      },
      {
        "Name": "axis",
        "TypeInfo": "int, optional, default='-1'",
        "Description": "The axis along which to compute softmax."
      },
      {
        "Name": "temperature",
        "TypeInfo": "double or None, optional, default=None",
        "Description": "Temperature parameter in softmax"
      },
      {
        "Name": "dtype",
        "TypeInfo": "{None, 'float16', 'float32', 'float64'},optional, default='None'",
        "Description": "DType of the output in case this can't be inferred. Defaults to the same as input's dtype if not defined (dtype=None)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_softmin",
    "Description": "",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "args",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "Positional input arguments"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "log_softmax",
    "Description": "Computes the log softmax of the input.\nThis is equivalent to computing softmax followed by log.\n\nExamples::\n\n  >>> x = mx.nd.array([1, 2, .1])\n  >>> mx.nd.log_softmax(x).asnumpy()\n  array([-1.41702998, -0.41702995, -2.31702995], dtype=float32)\n\n  >>> x = mx.nd.array( [[1, 2, .1],[.1, 2, 1]] )\n  >>> mx.nd.log_softmax(x, axis=0).asnumpy()\n  array([[-0.34115392, -0.69314718, -1.24115396],\n         [-1.24115396, -0.69314718, -0.34115392]], dtype=float32)\n\n\n",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      },
      {
        "Name": "axis",
        "TypeInfo": "int, optional, default='-1'",
        "Description": "The axis along which to compute softmax."
      },
      {
        "Name": "temperature",
        "TypeInfo": "double or None, optional, default=None",
        "Description": "Temperature parameter in softmax"
      },
      {
        "Name": "dtype",
        "TypeInfo": "{None, 'float16', 'float32', 'float64'},optional, default='None'",
        "Description": "DType of the output in case this can't be inferred. Defaults to the same as input's dtype if not defined (dtype=None)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_log_softmax",
    "Description": "",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "args",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "Positional input arguments"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "SoftmaxActivation",
    "Description": "Applies softmax activation to input. This is intended for internal layers.\n\n.. note::\n\n  This operator has been deprecated, please use `softmax`.\n\nIf `mode` = ``instance``, this operator will compute a softmax for each instance in the batch.\nThis is the default mode.\n\nIf `mode` = ``channel``, this operator will compute a k-class softmax at each position\nof each instance, where `k` = ``num_channel``. This mode can only be used when the input array\nhas at least 3 dimensions.\nThis can be used for `fully convolutional network`, `image segmentation`, etc.\n\nExample::\n\n  >>> input_array = mx.nd.array([[3., 0.5, -0.5, 2., 7.],\n  >>>                            [2., -.4, 7.,   3., 0.2]])\n  >>> softmax_act = mx.nd.SoftmaxActivation(input_array)\n  >>> print softmax_act.asnumpy()\n  [[  1.78322066e-02   1.46375655e-03   5.38485940e-04   6.56010211e-03   9.73605454e-01]\n   [  6.56221947e-03   5.95310994e-04   9.73919690e-01   1.78379621e-02   1.08472735e-03]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\nn\\softmax_activation.cc:L59",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      },
      {
        "Name": "mode",
        "TypeInfo": "{'channel', 'instance'},optional, default='instance'",
        "Description": "Specifies how to compute the softmax. If set to ``instance``, it computes softmax for each instance. If set to ``channel``, It computes cross channel softmax for each position of each instance."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_SoftmaxActivation",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "UpSampling",
    "Description": "Upsamples the given input data.\n\nTwo algorithms (``sample_type``) are available for upsampling:\n\n- Nearest Neighbor\n- Bilinear\n\n**Nearest Neighbor Upsampling**\n\nInput data is expected to be NCHW.\n\nExample::\n\n  x = [[[[1. 1. 1.]\n         [1. 1. 1.]\n         [1. 1. 1.]]]]\n\n  UpSampling(x, scale=2, sample_type='nearest') = [[[[1. 1. 1. 1. 1. 1.]\n                                                     [1. 1. 1. 1. 1. 1.]\n                                                     [1. 1. 1. 1. 1. 1.]\n                                                     [1. 1. 1. 1. 1. 1.]\n                                                     [1. 1. 1. 1. 1. 1.]\n                                                     [1. 1. 1. 1. 1. 1.]]]]\n\n**Bilinear Upsampling**\n\nUses `deconvolution` algorithm under the hood. You need provide both input data and the kernel.\n\nInput data is expected to be NCHW.\n\n`num_filter` is expected to be same as the number of channels.\n\nExample::\n\n  x = [[[[1. 1. 1.]\n         [1. 1. 1.]\n         [1. 1. 1.]]]]\n\n  w = [[[[1. 1. 1. 1.]\n         [1. 1. 1. 1.]\n         [1. 1. 1. 1.]\n         [1. 1. 1. 1.]]]]\n  \n  UpSampling(x, w, scale=2, sample_type='bilinear', num_filter=1) = [[[[1. 2. 2. 2. 2. 1.]\n                                                                       [2. 4. 4. 4. 4. 2.]\n                                                                       [2. 4. 4. 4. 4. 2.]\n                                                                       [2. 4. 4. 4. 4. 2.]\n                                                                       [2. 4. 4. 4. 4. 2.]\n                                                                       [1. 2. 2. 2. 2. 1.]]]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\nn\\upsampling.cc:L173",
    "NumArgs": 7,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "Array of tensors to upsample. For bilinear upsampling, there should be 2 inputs - 1 data and 1 weight."
      },
      {
        "Name": "scale",
        "TypeInfo": "int, required",
        "Description": "Up sampling scale"
      },
      {
        "Name": "num_filter",
        "TypeInfo": "int, optional, default='0'",
        "Description": "Input filter. Only used by bilinear sample_type.Since bilinear upsampling uses deconvolution, num_filters is set to the number of channels."
      },
      {
        "Name": "sample_type",
        "TypeInfo": "{'bilinear', 'nearest'}, required",
        "Description": "upsampling method"
      },
      {
        "Name": "multi_input_mode",
        "TypeInfo": "{'concat', 'sum'},optional, default='concat'",
        "Description": "How to handle multiple input. concat means concatenate upsampled images along the channel dimension. sum means add all images together, only available for nearest neighbor upsampling."
      },
      {
        "Name": "num_args",
        "TypeInfo": "int, required",
        "Description": "Number of inputs to be upsampled. For nearest neighbor upsampling, this can be 1-N; the size of output will be(scale*h_0,scale*w_0) and all other inputs will be upsampled to thesame size. For bilinear upsampling this must be 2; 1 input and 1 weight."
      },
      {
        "Name": "workspace",
        "TypeInfo": "long (non-negative), optional, default=512",
        "Description": "Tmp workspace for deconvolution (MB)"
      }
    ],
    "KeyVarNumArgs": "num_args",
    "ReturnType": null
  },
  {
    "Name": "_backward_UpSampling",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "signsgd_update",
    "Description": "Update function for SignSGD optimizer.\n\n.. math::\n\n g_t = \\nabla J(W_{t-1})\\\\\n W_t = W_{t-1} - \\eta_t \\text{sign}(g_t)\n\nIt updates the weights using::\n\n weight = weight - learning_rate * sign(gradient)\n\n.. note::\n   - sparse ndarray not supported for this optimizer yet.\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\optimizer_op.cc:L61",
    "NumArgs": 6,
    "Arguments": [
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight"
      },
      {
        "Name": "grad",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Gradient"
      },
      {
        "Name": "lr",
        "TypeInfo": "float, required",
        "Description": "Learning rate"
      },
      {
        "Name": "wd",
        "TypeInfo": "float, optional, default=0",
        "Description": "Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight."
      },
      {
        "Name": "rescale_grad",
        "TypeInfo": "float, optional, default=1",
        "Description": "Rescale gradient to grad = rescale_grad*grad."
      },
      {
        "Name": "clip_gradient",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "signum_update",
    "Description": "SIGN momentUM (Signum) optimizer.\n\n.. math::\n\n g_t = \\nabla J(W_{t-1})\\\\\n m_t = \\beta m_{t-1} + (1 - \\beta) g_t\\\\\n W_t = W_{t-1} - \\eta_t \\text{sign}(m_t)\n\nIt updates the weights using::\n state = momentum * state + (1-momentum) * gradient\n weight = weight - learning_rate * sign(state)\n\nWhere the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.\n\n.. note::\n   - sparse ndarray not supported for this optimizer yet.\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\optimizer_op.cc:L90",
    "NumArgs": 9,
    "Arguments": [
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight"
      },
      {
        "Name": "grad",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Gradient"
      },
      {
        "Name": "mom",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Momentum"
      },
      {
        "Name": "lr",
        "TypeInfo": "float, required",
        "Description": "Learning rate"
      },
      {
        "Name": "momentum",
        "TypeInfo": "float, optional, default=0",
        "Description": "The decay rate of momentum estimates at each epoch."
      },
      {
        "Name": "wd",
        "TypeInfo": "float, optional, default=0",
        "Description": "Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight."
      },
      {
        "Name": "rescale_grad",
        "TypeInfo": "float, optional, default=1",
        "Description": "Rescale gradient to grad = rescale_grad*grad."
      },
      {
        "Name": "clip_gradient",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient)."
      },
      {
        "Name": "wd_lh",
        "TypeInfo": "float, optional, default=0",
        "Description": "The amount of weight decay that does not go into gradient/momentum calculationsotherwise do weight decay algorithmically only."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "multi_sgd_update",
    "Description": "Update function for Stochastic Gradient Descent (SDG) optimizer.\n\nIt updates the weights using::\n\n weight = weight - learning_rate * (gradient + wd * weight)\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\optimizer_op.cc:L327",
    "NumArgs": 6,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "Weights"
      },
      {
        "Name": "lrs",
        "TypeInfo": ", required",
        "Description": "Learning rates."
      },
      {
        "Name": "wds",
        "TypeInfo": ", required",
        "Description": "Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight."
      },
      {
        "Name": "rescale_grad",
        "TypeInfo": "float, optional, default=1",
        "Description": "Rescale gradient to grad = rescale_grad*grad."
      },
      {
        "Name": "clip_gradient",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient)."
      },
      {
        "Name": "num_weights",
        "TypeInfo": "int, optional, default='1'",
        "Description": "Number of updated weights."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "multi_sgd_mom_update",
    "Description": "Momentum update function for Stochastic Gradient Descent (SGD) optimizer.\n\nMomentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:\n\n.. math::\n\n  v_1 = \\alpha * \\nabla J(W_0)\\\\\n  v_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\n  W_t = W_{t-1} + v_t\n\nIt updates the weights using::\n\n  v = momentum * v - learning_rate * gradient\n  weight += v\n\nWhere the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\optimizer_op.cc:L372",
    "NumArgs": 7,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "Weights, gradients and momentum"
      },
      {
        "Name": "lrs",
        "TypeInfo": ", required",
        "Description": "Learning rates."
      },
      {
        "Name": "wds",
        "TypeInfo": ", required",
        "Description": "Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight."
      },
      {
        "Name": "momentum",
        "TypeInfo": "float, optional, default=0",
        "Description": "The decay rate of momentum estimates at each epoch."
      },
      {
        "Name": "rescale_grad",
        "TypeInfo": "float, optional, default=1",
        "Description": "Rescale gradient to grad = rescale_grad*grad."
      },
      {
        "Name": "clip_gradient",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient)."
      },
      {
        "Name": "num_weights",
        "TypeInfo": "int, optional, default='1'",
        "Description": "Number of updated weights."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "multi_mp_sgd_update",
    "Description": "Update function for multi-precision Stochastic Gradient Descent (SDG) optimizer.\n\nIt updates the weights using::\n\n weight = weight - learning_rate * (gradient + wd * weight)\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\optimizer_op.cc:L415",
    "NumArgs": 6,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "Weights"
      },
      {
        "Name": "lrs",
        "TypeInfo": ", required",
        "Description": "Learning rates."
      },
      {
        "Name": "wds",
        "TypeInfo": ", required",
        "Description": "Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight."
      },
      {
        "Name": "rescale_grad",
        "TypeInfo": "float, optional, default=1",
        "Description": "Rescale gradient to grad = rescale_grad*grad."
      },
      {
        "Name": "clip_gradient",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient)."
      },
      {
        "Name": "num_weights",
        "TypeInfo": "int, optional, default='1'",
        "Description": "Number of updated weights."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "multi_mp_sgd_mom_update",
    "Description": "Momentum update function for multi-precision Stochastic Gradient Descent (SGD) optimizer.\n\nMomentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:\n\n.. math::\n\n  v_1 = \\alpha * \\nabla J(W_0)\\\\\n  v_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\n  W_t = W_{t-1} + v_t\n\nIt updates the weights using::\n\n  v = momentum * v - learning_rate * gradient\n  weight += v\n\nWhere the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\optimizer_op.cc:L470",
    "NumArgs": 7,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "Weights"
      },
      {
        "Name": "lrs",
        "TypeInfo": ", required",
        "Description": "Learning rates."
      },
      {
        "Name": "wds",
        "TypeInfo": ", required",
        "Description": "Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight."
      },
      {
        "Name": "momentum",
        "TypeInfo": "float, optional, default=0",
        "Description": "The decay rate of momentum estimates at each epoch."
      },
      {
        "Name": "rescale_grad",
        "TypeInfo": "float, optional, default=1",
        "Description": "Rescale gradient to grad = rescale_grad*grad."
      },
      {
        "Name": "clip_gradient",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient)."
      },
      {
        "Name": "num_weights",
        "TypeInfo": "int, optional, default='1'",
        "Description": "Number of updated weights."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "sgd_update",
    "Description": "Update function for Stochastic Gradient Descent (SGD) optimizer.\n\nIt updates the weights using::\n\n weight = weight - learning_rate * (gradient + wd * weight)\n\nHowever, if gradient is of ``row_sparse`` storage type and ``lazy_update`` is True,\nonly the row slices whose indices appear in grad.indices are updated::\n\n for row in gradient.indices:\n     weight[row] = weight[row] - learning_rate * (gradient[row] + wd * weight[row])\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\optimizer_op.cc:L522",
    "NumArgs": 7,
    "Arguments": [
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight"
      },
      {
        "Name": "grad",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Gradient"
      },
      {
        "Name": "lr",
        "TypeInfo": "float, required",
        "Description": "Learning rate"
      },
      {
        "Name": "wd",
        "TypeInfo": "float, optional, default=0",
        "Description": "Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight."
      },
      {
        "Name": "rescale_grad",
        "TypeInfo": "float, optional, default=1",
        "Description": "Rescale gradient to grad = rescale_grad*grad."
      },
      {
        "Name": "clip_gradient",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient)."
      },
      {
        "Name": "lazy_update",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "If true, lazy updates are applied if gradient's stype is row_sparse."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "sgd_mom_update",
    "Description": "Momentum update function for Stochastic Gradient Descent (SGD) optimizer.\n\nMomentum update has better convergence rates on neural networks. Mathematically it looks\nlike below:\n\n.. math::\n\n  v_1 = \\alpha * \\nabla J(W_0)\\\\\n  v_t = \\gamma v_{t-1} - \\alpha * \\nabla J(W_{t-1})\\\\\n  W_t = W_{t-1} + v_t\n\nIt updates the weights using::\n\n  v = momentum * v - learning_rate * gradient\n  weight += v\n\nWhere the parameter ``momentum`` is the decay rate of momentum estimates at each epoch.\n\nHowever, if grad's storage type is ``row_sparse``, ``lazy_update`` is True and weight's storage\ntype is the same as momentum's storage type,\nonly the row slices whose indices appear in grad.indices are updated (for both weight and momentum)::\n\n  for row in gradient.indices:\n      v[row] = momentum[row] * v[row] - learning_rate * gradient[row]\n      weight[row] += v[row]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\optimizer_op.cc:L563",
    "NumArgs": 9,
    "Arguments": [
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight"
      },
      {
        "Name": "grad",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Gradient"
      },
      {
        "Name": "mom",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Momentum"
      },
      {
        "Name": "lr",
        "TypeInfo": "float, required",
        "Description": "Learning rate"
      },
      {
        "Name": "momentum",
        "TypeInfo": "float, optional, default=0",
        "Description": "The decay rate of momentum estimates at each epoch."
      },
      {
        "Name": "wd",
        "TypeInfo": "float, optional, default=0",
        "Description": "Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight."
      },
      {
        "Name": "rescale_grad",
        "TypeInfo": "float, optional, default=1",
        "Description": "Rescale gradient to grad = rescale_grad*grad."
      },
      {
        "Name": "clip_gradient",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient)."
      },
      {
        "Name": "lazy_update",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "If true, lazy updates are applied if gradient's stype is row_sparse and both weight and momentum have the same stype"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "mp_sgd_update",
    "Description": "Updater function for multi-precision sgd optimizer",
    "NumArgs": 8,
    "Arguments": [
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight"
      },
      {
        "Name": "grad",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "gradient"
      },
      {
        "Name": "weight32",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight32"
      },
      {
        "Name": "lr",
        "TypeInfo": "float, required",
        "Description": "Learning rate"
      },
      {
        "Name": "wd",
        "TypeInfo": "float, optional, default=0",
        "Description": "Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight."
      },
      {
        "Name": "rescale_grad",
        "TypeInfo": "float, optional, default=1",
        "Description": "Rescale gradient to grad = rescale_grad*grad."
      },
      {
        "Name": "clip_gradient",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient)."
      },
      {
        "Name": "lazy_update",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "If true, lazy updates are applied if gradient's stype is row_sparse."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "mp_sgd_mom_update",
    "Description": "Updater function for multi-precision sgd optimizer",
    "NumArgs": 10,
    "Arguments": [
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight"
      },
      {
        "Name": "grad",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Gradient"
      },
      {
        "Name": "mom",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Momentum"
      },
      {
        "Name": "weight32",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight32"
      },
      {
        "Name": "lr",
        "TypeInfo": "float, required",
        "Description": "Learning rate"
      },
      {
        "Name": "momentum",
        "TypeInfo": "float, optional, default=0",
        "Description": "The decay rate of momentum estimates at each epoch."
      },
      {
        "Name": "wd",
        "TypeInfo": "float, optional, default=0",
        "Description": "Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight."
      },
      {
        "Name": "rescale_grad",
        "TypeInfo": "float, optional, default=1",
        "Description": "Rescale gradient to grad = rescale_grad*grad."
      },
      {
        "Name": "clip_gradient",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient)."
      },
      {
        "Name": "lazy_update",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "If true, lazy updates are applied if gradient's stype is row_sparse and both weight and momentum have the same stype"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "ftml_update",
    "Description": "The FTML optimizer described in\n*FTML - Follow the Moving Leader in Deep Learning*,\navailable at http://proceedings.mlr.press/v70/zheng17a/zheng17a.pdf.\n\n.. math::\n\n g_t = \\nabla J(W_{t-1})\\\\\n v_t = \\beta_2 v_{t-1} + (1 - \\beta_2) g_t^2\\\\\n d_t = \\frac{ 1 - \\beta_1^t }{ \\eta_t } (\\sqrt{ \\frac{ v_t }{ 1 - \\beta_2^t } } + \\epsilon)\n \\sigma_t = d_t - \\beta_1 d_{t-1}\n z_t = \\beta_1 z_{ t-1 } + (1 - \\beta_1^t) g_t - \\sigma_t W_{t-1}\n W_t = - \\frac{ z_t }{ d_t }\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\optimizer_op.cc:L638",
    "NumArgs": 13,
    "Arguments": [
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight"
      },
      {
        "Name": "grad",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Gradient"
      },
      {
        "Name": "d",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Internal state ``d_t``"
      },
      {
        "Name": "v",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Internal state ``v_t``"
      },
      {
        "Name": "z",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Internal state ``z_t``"
      },
      {
        "Name": "lr",
        "TypeInfo": "float, required",
        "Description": "Learning rate."
      },
      {
        "Name": "beta1",
        "TypeInfo": "float, optional, default=0.600000024",
        "Description": "Generally close to 0.5."
      },
      {
        "Name": "beta2",
        "TypeInfo": "float, optional, default=0.999000013",
        "Description": "Generally close to 1."
      },
      {
        "Name": "epsilon",
        "TypeInfo": "double, optional, default=9.9999999392252903e-09",
        "Description": "Epsilon to prevent div 0."
      },
      {
        "Name": "t",
        "TypeInfo": "int, required",
        "Description": "Number of update."
      },
      {
        "Name": "wd",
        "TypeInfo": "float, optional, default=0",
        "Description": "Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight."
      },
      {
        "Name": "rescale_grad",
        "TypeInfo": "float, optional, default=1",
        "Description": "Rescale gradient to grad = rescale_grad*grad."
      },
      {
        "Name": "clip_grad",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "adam_update",
    "Description": "Update function for Adam optimizer. Adam is seen as a generalization\nof AdaGrad.\n\nAdam update consists of the following steps, where g represents gradient and m, v\nare 1st and 2nd order moment estimates (mean and variance).\n\n.. math::\n\n g_t = \\nabla J(W_{t-1})\\\\\n m_t = \\beta_1 m_{t-1} + (1 - \\beta_1) g_t\\\\\n v_t = \\beta_2 v_{t-1} + (1 - \\beta_2) g_t^2\\\\\n W_t = W_{t-1} - \\alpha \\frac{ m_t }{ \\sqrt{ v_t } + \\epsilon }\n\nIt updates the weights using::\n\n m = beta1*m + (1-beta1)*grad\n v = beta2*v + (1-beta2)*(grad**2)\n w += - learning_rate * m / (sqrt(v) + epsilon)\n\nHowever, if grad's storage type is ``row_sparse``, ``lazy_update`` is True and the storage\ntype of weight is the same as those of m and v,\nonly the row slices whose indices appear in grad.indices are updated (for w, m and v)::\n\n for row in grad.indices:\n     m[row] = beta1*m[row] + (1-beta1)*grad[row]\n     v[row] = beta2*v[row] + (1-beta2)*(grad[row]**2)\n     w[row] += - learning_rate * m[row] / (sqrt(v[row]) + epsilon)\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\optimizer_op.cc:L686",
    "NumArgs": 12,
    "Arguments": [
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight"
      },
      {
        "Name": "grad",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Gradient"
      },
      {
        "Name": "mean",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Moving mean"
      },
      {
        "Name": "var",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Moving variance"
      },
      {
        "Name": "lr",
        "TypeInfo": "float, required",
        "Description": "Learning rate"
      },
      {
        "Name": "beta1",
        "TypeInfo": "float, optional, default=0.899999976",
        "Description": "The decay rate for the 1st moment estimates."
      },
      {
        "Name": "beta2",
        "TypeInfo": "float, optional, default=0.999000013",
        "Description": "The decay rate for the 2nd moment estimates."
      },
      {
        "Name": "epsilon",
        "TypeInfo": "float, optional, default=9.99999994e-09",
        "Description": "A small constant for numerical stability."
      },
      {
        "Name": "wd",
        "TypeInfo": "float, optional, default=0",
        "Description": "Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight."
      },
      {
        "Name": "rescale_grad",
        "TypeInfo": "float, optional, default=1",
        "Description": "Rescale gradient to grad = rescale_grad*grad."
      },
      {
        "Name": "clip_gradient",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient)."
      },
      {
        "Name": "lazy_update",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "If true, lazy updates are applied if gradient's stype is row_sparse and all of w, m and v have the same stype"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "nag_mom_update",
    "Description": "Update function for Nesterov Accelerated Gradient( NAG) optimizer.\nIt updates the weights using the following formula,\n\n.. math::\n  v_t = \\gamma v_{t-1} + \\eta * \\nabla J(W_{t-1} - \\gamma v_{t-1})\\\\\n  W_t = W_{t-1} - v_t\n\nWhere \n:math:`\\eta` is the learning rate of the optimizer\n:math:`\\gamma` is the decay rate of the momentum estimate\n:math:`\\v_t` is the update vector at time step `t`\n:math:`\\W_t` is the weight vector at time step `t`\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\optimizer_op.cc:L724",
    "NumArgs": 8,
    "Arguments": [
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight"
      },
      {
        "Name": "grad",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Gradient"
      },
      {
        "Name": "mom",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Momentum"
      },
      {
        "Name": "lr",
        "TypeInfo": "float, required",
        "Description": "Learning rate"
      },
      {
        "Name": "momentum",
        "TypeInfo": "float, optional, default=0",
        "Description": "The decay rate of momentum estimates at each epoch."
      },
      {
        "Name": "wd",
        "TypeInfo": "float, optional, default=0",
        "Description": "Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight."
      },
      {
        "Name": "rescale_grad",
        "TypeInfo": "float, optional, default=1",
        "Description": "Rescale gradient to grad = rescale_grad*grad."
      },
      {
        "Name": "clip_gradient",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "mp_nag_mom_update",
    "Description": "Update function for multi-precision Nesterov Accelerated Gradient( NAG) optimizer.\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\optimizer_op.cc:L743",
    "NumArgs": 9,
    "Arguments": [
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight"
      },
      {
        "Name": "grad",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Gradient"
      },
      {
        "Name": "mom",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Momentum"
      },
      {
        "Name": "weight32",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight32"
      },
      {
        "Name": "lr",
        "TypeInfo": "float, required",
        "Description": "Learning rate"
      },
      {
        "Name": "momentum",
        "TypeInfo": "float, optional, default=0",
        "Description": "The decay rate of momentum estimates at each epoch."
      },
      {
        "Name": "wd",
        "TypeInfo": "float, optional, default=0",
        "Description": "Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight."
      },
      {
        "Name": "rescale_grad",
        "TypeInfo": "float, optional, default=1",
        "Description": "Rescale gradient to grad = rescale_grad*grad."
      },
      {
        "Name": "clip_gradient",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "rmsprop_update",
    "Description": "Update function for `RMSProp` optimizer.\n\n`RMSprop` is a variant of stochastic gradient descent where the gradients are\ndivided by a cache which grows with the sum of squares of recent gradients?\n\n`RMSProp` is similar to `AdaGrad`, a popular variant of `SGD` which adaptively\ntunes the learning rate of each parameter. `AdaGrad` lowers the learning rate for\neach parameter monotonically over the course of training.\nWhile this is analytically motivated for convex optimizations, it may not be ideal\nfor non-convex problems. `RMSProp` deals with this heuristically by allowing the\nlearning rates to rebound as the denominator decays over time.\n\nDefine the Root Mean Square (RMS) error criterion of the gradient as\n:math:`RMS[g]_t = \\sqrt{E[g^2]_t + \\epsilon}`, where :math:`g` represents\ngradient and :math:`E[g^2]_t` is the decaying average over past squared gradient.\n\nThe :math:`E[g^2]_t` is given by:\n\n.. math::\n  E[g^2]_t = \\gamma * E[g^2]_{t-1} + (1-\\gamma) * g_t^2\n\nThe update step is\n\n.. math::\n  \\theta_{t+1} = \\theta_t - \\frac{\\eta}{RMS[g]_t} g_t\n\nThe RMSProp code follows the version in\nhttp://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf\nTieleman & Hinton, 2012.\n\nHinton suggests the momentum term :math:`\\gamma` to be 0.9 and the learning rate\n:math:`\\eta` to be 0.001.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\optimizer_op.cc:L795",
    "NumArgs": 10,
    "Arguments": [
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight"
      },
      {
        "Name": "grad",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Gradient"
      },
      {
        "Name": "n",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "n"
      },
      {
        "Name": "lr",
        "TypeInfo": "float, required",
        "Description": "Learning rate"
      },
      {
        "Name": "gamma1",
        "TypeInfo": "float, optional, default=0.949999988",
        "Description": "The decay rate of momentum estimates."
      },
      {
        "Name": "epsilon",
        "TypeInfo": "float, optional, default=9.99999994e-09",
        "Description": "A small constant for numerical stability."
      },
      {
        "Name": "wd",
        "TypeInfo": "float, optional, default=0",
        "Description": "Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight."
      },
      {
        "Name": "rescale_grad",
        "TypeInfo": "float, optional, default=1",
        "Description": "Rescale gradient to grad = rescale_grad*grad."
      },
      {
        "Name": "clip_gradient",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient)."
      },
      {
        "Name": "clip_weights",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Clip weights to the range of [-clip_weights, clip_weights] If clip_weights <= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "rmspropalex_update",
    "Description": "Update function for RMSPropAlex optimizer.\n\n`RMSPropAlex` is non-centered version of `RMSProp`.\n\nDefine :math:`E[g^2]_t` is the decaying average over past squared gradient and\n:math:`E[g]_t` is the decaying average over past gradient.\n\n.. math::\n  E[g^2]_t = \\gamma_1 * E[g^2]_{t-1} + (1 - \\gamma_1) * g_t^2\\\\\n  E[g]_t = \\gamma_1 * E[g]_{t-1} + (1 - \\gamma_1) * g_t\\\\\n  \\Delta_t = \\gamma_2 * \\Delta_{t-1} - \\frac{\\eta}{\\sqrt{E[g^2]_t - E[g]_t^2 + \\epsilon}} g_t\\\\\n\nThe update step is\n\n.. math::\n  \\theta_{t+1} = \\theta_t + \\Delta_t\n\nThe RMSPropAlex code follows the version in\nhttp://arxiv.org/pdf/1308.0850v5.pdf Eq(38) - Eq(45) by Alex Graves, 2013.\n\nGraves suggests the momentum term :math:`\\gamma_1` to be 0.95, :math:`\\gamma_2`\nto be 0.9 and the learning rate :math:`\\eta` to be 0.0001.\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\optimizer_op.cc:L834",
    "NumArgs": 13,
    "Arguments": [
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight"
      },
      {
        "Name": "grad",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Gradient"
      },
      {
        "Name": "n",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "n"
      },
      {
        "Name": "g",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "g"
      },
      {
        "Name": "delta",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "delta"
      },
      {
        "Name": "lr",
        "TypeInfo": "float, required",
        "Description": "Learning rate"
      },
      {
        "Name": "gamma1",
        "TypeInfo": "float, optional, default=0.949999988",
        "Description": "Decay rate."
      },
      {
        "Name": "gamma2",
        "TypeInfo": "float, optional, default=0.899999976",
        "Description": "Decay rate."
      },
      {
        "Name": "epsilon",
        "TypeInfo": "float, optional, default=9.99999994e-09",
        "Description": "A small constant for numerical stability."
      },
      {
        "Name": "wd",
        "TypeInfo": "float, optional, default=0",
        "Description": "Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight."
      },
      {
        "Name": "rescale_grad",
        "TypeInfo": "float, optional, default=1",
        "Description": "Rescale gradient to grad = rescale_grad*grad."
      },
      {
        "Name": "clip_gradient",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient)."
      },
      {
        "Name": "clip_weights",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Clip weights to the range of [-clip_weights, clip_weights] If clip_weights <= 0, weight clipping is turned off. weights = max(min(weights, clip_weights), -clip_weights)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "ftrl_update",
    "Description": "Update function for Ftrl optimizer.\nReferenced from *Ad Click Prediction: a View from the Trenches*, available at\nhttp://dl.acm.org/citation.cfm?id=2488200.\n\nIt updates the weights using::\n\n rescaled_grad = clip(grad * rescale_grad, clip_gradient)\n z += rescaled_grad - (sqrt(n + rescaled_grad**2) - sqrt(n)) * weight / learning_rate\n n += rescaled_grad**2\n w = (sign(z) * lamda1 - z) / ((beta + sqrt(n)) / learning_rate + wd) * (abs(z) > lamda1)\n\nIf w, z and n are all of ``row_sparse`` storage type,\nonly the row slices whose indices appear in grad.indices are updated (for w, z and n)::\n\n for row in grad.indices:\n     rescaled_grad[row] = clip(grad[row] * rescale_grad, clip_gradient)\n     z[row] += rescaled_grad[row] - (sqrt(n[row] + rescaled_grad[row]**2) - sqrt(n[row])) * weight[row] / learning_rate\n     n[row] += rescaled_grad[row]**2\n     w[row] = (sign(z[row]) * lamda1 - z[row]) / ((beta + sqrt(n[row])) / learning_rate + wd) * (abs(z[row]) > lamda1)\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\optimizer_op.cc:L874",
    "NumArgs": 10,
    "Arguments": [
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight"
      },
      {
        "Name": "grad",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Gradient"
      },
      {
        "Name": "z",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "z"
      },
      {
        "Name": "n",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Square of grad"
      },
      {
        "Name": "lr",
        "TypeInfo": "float, required",
        "Description": "Learning rate"
      },
      {
        "Name": "lamda1",
        "TypeInfo": "float, optional, default=0.00999999978",
        "Description": "The L1 regularization coefficient."
      },
      {
        "Name": "beta",
        "TypeInfo": "float, optional, default=1",
        "Description": "Per-Coordinate Learning Rate beta."
      },
      {
        "Name": "wd",
        "TypeInfo": "float, optional, default=0",
        "Description": "Weight decay augments the objective function with a regularization term that penalizes large weights. The penalty scales with the square of the magnitude of each weight."
      },
      {
        "Name": "rescale_grad",
        "TypeInfo": "float, optional, default=1",
        "Description": "Rescale gradient to grad = rescale_grad*grad."
      },
      {
        "Name": "clip_gradient",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_sparse_adagrad_update",
    "Description": "Update function for AdaGrad optimizer.\n\nReferenced from *Adaptive Subgradient Methods for Online Learning and Stochastic Optimization*,\nand available at http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf.\n\nUpdates are applied by::\n\n    rescaled_grad = clip(grad * rescale_grad, clip_gradient)\n    history = history + square(rescaled_grad)\n    w = w - learning_rate * rescaled_grad / sqrt(history + epsilon)\n\nNote that non-zero values for the weight decay option are not supported.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\optimizer_op.cc:L907",
    "NumArgs": 8,
    "Arguments": [
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight"
      },
      {
        "Name": "grad",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Gradient"
      },
      {
        "Name": "history",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "History"
      },
      {
        "Name": "lr",
        "TypeInfo": "float, required",
        "Description": "Learning rate"
      },
      {
        "Name": "epsilon",
        "TypeInfo": "float, optional, default=1.00000001e-07",
        "Description": "epsilon"
      },
      {
        "Name": "wd",
        "TypeInfo": "float, optional, default=0",
        "Description": "weight decay"
      },
      {
        "Name": "rescale_grad",
        "TypeInfo": "float, optional, default=1",
        "Description": "Rescale gradient to grad = rescale_grad*grad."
      },
      {
        "Name": "clip_gradient",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Clip gradient to the range of [-clip_gradient, clip_gradient] If clip_gradient <= 0, gradient clipping is turned off. grad = max(min(grad, clip_gradient), -clip_gradient)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "Pad",
    "Description": "Pads an input array with a constant or edge values of the array.\n\n.. note:: `Pad` is deprecated. Use `pad` instead.\n\n.. note:: Current implementation only supports 4D and 5D input arrays with padding applied\n   only on axes 1, 2 and 3. Expects axes 4 and 5 in `pad_width` to be zero.\n\nThis operation pads an input array with either a `constant_value` or edge values\nalong each axis of the input array. The amount of padding is specified by `pad_width`.\n\n`pad_width` is a tuple of integer padding widths for each axis of the format\n``(before_1, after_1, ... , before_N, after_N)``. The `pad_width` should be of length ``2*N``\nwhere ``N`` is the number of dimensions of the array.\n\nFor dimension ``N`` of the input array, ``before_N`` and ``after_N`` indicates how many values\nto add before and after the elements of the array along dimension ``N``.\nThe widths of the higher two dimensions ``before_1``, ``after_1``, ``before_2``,\n``after_2`` must be 0.\n\nExample::\n\n   x = [[[[  1.   2.   3.]\n          [  4.   5.   6.]]\n\n         [[  7.   8.   9.]\n          [ 10.  11.  12.]]]\n\n\n        [[[ 11.  12.  13.]\n          [ 14.  15.  16.]]\n\n         [[ 17.  18.  19.]\n          [ 20.  21.  22.]]]]\n\n   pad(x,mode=\"edge\", pad_width=(0,0,0,0,1,1,1,1)) =\n\n         [[[[  1.   1.   2.   3.   3.]\n            [  1.   1.   2.   3.   3.]\n            [  4.   4.   5.   6.   6.]\n            [  4.   4.   5.   6.   6.]]\n\n           [[  7.   7.   8.   9.   9.]\n            [  7.   7.   8.   9.   9.]\n            [ 10.  10.  11.  12.  12.]\n            [ 10.  10.  11.  12.  12.]]]\n\n\n          [[[ 11.  11.  12.  13.  13.]\n            [ 11.  11.  12.  13.  13.]\n            [ 14.  14.  15.  16.  16.]\n            [ 14.  14.  15.  16.  16.]]\n\n           [[ 17.  17.  18.  19.  19.]\n            [ 17.  17.  18.  19.  19.]\n            [ 20.  20.  21.  22.  22.]\n            [ 20.  20.  21.  22.  22.]]]]\n\n   pad(x, mode=\"constant\", constant_value=0, pad_width=(0,0,0,0,1,1,1,1)) =\n\n         [[[[  0.   0.   0.   0.   0.]\n            [  0.   1.   2.   3.   0.]\n            [  0.   4.   5.   6.   0.]\n            [  0.   0.   0.   0.   0.]]\n\n           [[  0.   0.   0.   0.   0.]\n            [  0.   7.   8.   9.   0.]\n            [  0.  10.  11.  12.   0.]\n            [  0.   0.   0.   0.   0.]]]\n\n\n          [[[  0.   0.   0.   0.   0.]\n            [  0.  11.  12.  13.   0.]\n            [  0.  14.  15.  16.   0.]\n            [  0.   0.   0.   0.   0.]]\n\n           [[  0.   0.   0.   0.   0.]\n            [  0.  17.  18.  19.   0.]\n            [  0.  20.  21.  22.   0.]\n            [  0.   0.   0.   0.   0.]]]]\n\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\pad.cc:L766",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "An n-dimensional input array."
      },
      {
        "Name": "mode",
        "TypeInfo": "{'constant', 'edge', 'reflect'}, required",
        "Description": "Padding type to use. \"constant\" pads with `constant_value` \"edge\" pads using the edge values of the input array \"reflect\" pads by reflecting values with respect to the edges."
      },
      {
        "Name": "pad_width",
        "TypeInfo": "Shape(tuple), required",
        "Description": "Widths of the padding regions applied to the edges of each axis. It is a tuple of integer padding widths for each axis of the format ``(before_1, after_1, ... , before_N, after_N)``. It should be of length ``2*N`` where ``N`` is the number of dimensions of the array.This is equivalent to pad_width in numpy.pad, but flattened."
      },
      {
        "Name": "constant_value",
        "TypeInfo": "double, optional, default=0",
        "Description": "The value used for padding when `mode` is \"constant\"."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_dequantize",
    "Description": "Dequantize the input tensor into a float tensor.\nmin_range and max_range are scalar floats that specify the range for\nthe output data.\n\nWhen input data type is `uint8`, the output is calculated using the following equation:\n\n`out[i] = in[i] * (max_range - min_range) / 255.0`,\n\nWhen input data type is `int8`, the output is calculate using the following equation\nby keep zero centered for the quantized value:\n\n`out[i] = in[i] * MaxAbs(min_range, max_range) / 127.0`,\n\n.. Note::\n    This operator only supports forward propogation. DO NOT use it in training.\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\quantization\\dequantize.cc:L83",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "A ndarray/symbol of type `uint8`"
      },
      {
        "Name": "min_range",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The minimum scalar value possibly produced for the input in float32"
      },
      {
        "Name": "max_range",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The maximum scalar value possibly produced for the input in float32"
      },
      {
        "Name": "out_type",
        "TypeInfo": "{'float32'},optional, default='float32'",
        "Description": "Output data type."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_quantize",
    "Description": "Quantize a input tensor from float to `out_type`,\nwith user-specified `min_range` and `max_range`.\n\nmin_range and max_range are scalar floats that specify the range for\nthe input data.\n\nWhen out_type is `uint8`, the output is calculated using the following equation:\n\n`out[i] = (in[i] - min_range) * range(OUTPUT_TYPE) / (max_range - min_range) + 0.5`,\n\nwhere `range(T) = numeric_limits<T>::max() - numeric_limits<T>::min()`.\n\nWhen out_type is `int8`, the output is calculate using the following equation\nby keep zero centered for the quantized value:\n\n`out[i] = sign(in[i]) * min(abs(in[i] * scale + 0.5f, quantized_range)`,\n\nwhere\n`quantized_range = MinAbs(max(int8), min(int8))` and\n`scale = quantized_range / MaxAbs(min_range, max_range).`\n\n.. Note::\n    This operator only supports forward propagation. DO NOT use it in training.\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\quantization\\quantize.cc:L74",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "A ndarray/symbol of type `float32`"
      },
      {
        "Name": "min_range",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The minimum scalar value possibly produced for the input"
      },
      {
        "Name": "max_range",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The maximum scalar value possibly produced for the input"
      },
      {
        "Name": "out_type",
        "TypeInfo": "{'int8', 'uint8'},optional, default='uint8'",
        "Description": "Output data type."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_quantize_v2",
    "Description": "Quantize a input tensor from float to `out_type`,\nwith user-specified `min_calib_range` and `max_calib_range` or the input range collected at runtime.\n\nOutput `min_range` and `max_range` are scalar floats that specify the range for the input data.\n\nWhen out_type is `uint8`, the output is calculated using the following equation:\n\n`out[i] = (in[i] - min_range) * range(OUTPUT_TYPE) / (max_range - min_range) + 0.5`,\n\nwhere `range(T) = numeric_limits<T>::max() - numeric_limits<T>::min()`.\n\nWhen out_type is `int8`, the output is calculate using the following equation\nby keep zero centered for the quantized value:\n\n`out[i] = sign(in[i]) * min(abs(in[i] * scale + 0.5f, quantized_range)`,\n\nwhere\n`quantized_range = MinAbs(max(int8), min(int8))` and\n`scale = quantized_range / MaxAbs(min_range, max_range).`\n\nWhen out_type is `auto`, the output type is automatically determined by min_calib_range if presented.\nIf min_calib_range < 0.0f, the output type will be int8, otherwise will be uint8.\nIf min_calib_range isn't presented, the output type will be int8.\n\n.. Note::\n    This operator only supports forward propagation. DO NOT use it in training.\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\quantization\\quantize_v2.cc:L92",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "A ndarray/symbol of type `float32`"
      },
      {
        "Name": "out_type",
        "TypeInfo": "{'auto', 'int8', 'uint8'},optional, default='int8'",
        "Description": "Output data type. `auto` can be specified to automatically determine output type according to min_calib_range."
      },
      {
        "Name": "min_calib_range",
        "TypeInfo": "float or None, optional, default=None",
        "Description": "The minimum scalar value in the form of float32. If present, it will be used to quantize the fp32 data into int8 or uint8."
      },
      {
        "Name": "max_calib_range",
        "TypeInfo": "float or None, optional, default=None",
        "Description": "The maximum scalar value in the form of float32. If present, it will be used to quantize the fp32 data into int8 or uint8."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_quantized_act",
    "Description": "Activation operator for input and output data type of int8.\nThe input and output data comes with min and max thresholds for quantizing\nthe float32 data into int8.\n\n.. Note::\n     This operator only supports forward propogation. DO NOT use it in training.\n     This operator only supports `relu`\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\quantization\\quantized_activation.cc:L91",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data."
      },
      {
        "Name": "min_data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Minimum value of data."
      },
      {
        "Name": "max_data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Maximum value of data."
      },
      {
        "Name": "act_type",
        "TypeInfo": "{'relu', 'sigmoid', 'softrelu', 'softsign', 'tanh'}, required",
        "Description": "Activation function to be applied."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_quantized_concat",
    "Description": "Joins input arrays along a given axis.\n\nThe dimensions of the input arrays should be the same except the axis along\nwhich they will be concatenated.\nThe dimension of the output array along the concatenated axis will be equal\nto the sum of the corresponding dimensions of the input arrays.\nAll inputs with different min/max will be rescaled by using largest [min, max] pairs.\nIf any input holds int8, then the output will be int8. Otherwise output will be uint8.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\quantization\\quantized_concat.cc:L108",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "List of arrays to concatenate"
      },
      {
        "Name": "num_args",
        "TypeInfo": "int, required",
        "Description": "Number of inputs to be concated."
      },
      {
        "Name": "dim",
        "TypeInfo": "int, optional, default='1'",
        "Description": "the dimension to be concated."
      }
    ],
    "KeyVarNumArgs": "num_args",
    "ReturnType": null
  },
  {
    "Name": "_contrib_quantized_conv",
    "Description": "Convolution operator for input, weight and bias data type of int8,\nand accumulates in type int32 for the output. For each argument, two more arguments of type\nfloat32 must be provided representing the thresholds of quantizing argument from data\ntype float32 to int8. The final outputs contain the convolution result in int32, and min\nand max thresholds representing the threholds for quantizing the float32 output into int32.\n\n.. Note::\n    This operator only supports forward propogation. DO NOT use it in training.\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\quantization\\quantized_conv.cc:L137",
    "NumArgs": 20,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data."
      },
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "weight."
      },
      {
        "Name": "bias",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "bias."
      },
      {
        "Name": "min_data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Minimum value of data."
      },
      {
        "Name": "max_data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Maximum value of data."
      },
      {
        "Name": "min_weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Minimum value of weight."
      },
      {
        "Name": "max_weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Maximum value of weight."
      },
      {
        "Name": "min_bias",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Minimum value of bias."
      },
      {
        "Name": "max_bias",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Maximum value of bias."
      },
      {
        "Name": "kernel",
        "TypeInfo": "Shape(tuple), required",
        "Description": "Convolution kernel size: (w,), (h, w) or (d, h, w)"
      },
      {
        "Name": "stride",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "Convolution stride: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension."
      },
      {
        "Name": "dilate",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "Convolution dilate: (w,), (h, w) or (d, h, w). Defaults to 1 for each dimension."
      },
      {
        "Name": "pad",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "Zero pad for convolution: (w,), (h, w) or (d, h, w). Defaults to no padding."
      },
      {
        "Name": "num_filter",
        "TypeInfo": "int (non-negative), required",
        "Description": "Convolution filter(channel) number"
      },
      {
        "Name": "num_group",
        "TypeInfo": "int (non-negative), optional, default=1",
        "Description": "Number of group partitions."
      },
      {
        "Name": "workspace",
        "TypeInfo": "long (non-negative), optional, default=1024",
        "Description": "Maximum temporary workspace allowed (MB) in convolution.This parameter has two usages. When CUDNN is not used, it determines the effective batch size of the convolution kernel. When CUDNN is used, it controls the maximum temporary storage used for tuning the best CUDNN kernel when `limited_workspace` strategy is used."
      },
      {
        "Name": "no_bias",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether to disable bias parameter."
      },
      {
        "Name": "cudnn_tune",
        "TypeInfo": "{None, 'fastest', 'limited_workspace', 'off'},optional, default='None'",
        "Description": "Whether to pick convolution algo by running performance test."
      },
      {
        "Name": "cudnn_off",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Turn off cudnn for this layer."
      },
      {
        "Name": "layout",
        "TypeInfo": "{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC'},optional, default='None'",
        "Description": "Set layout for input, output and weight. Empty for\n    default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d.NHWC and NDHWC are only supported on GPU."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_quantized_elemwise_add",
    "Description": "elemwise_add operator for input dataA and input dataB data type of int8,\nand accumulates in type int32 for the output. For each argument, two more arguments of type\nfloat32 must be provided representing the thresholds of quantizing argument from data\ntype float32 to int8. The final outputs contain result in int32, and min\nand max thresholds representing the threholds for quantizing the float32 output into int32.\n\n.. Note::\n    This operator only supports forward propogation. DO NOT use it in training.\n\n",
    "NumArgs": 6,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      },
      {
        "Name": "lhs_min",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "3rd input"
      },
      {
        "Name": "lhs_max",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "4th input"
      },
      {
        "Name": "rhs_min",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "5th input"
      },
      {
        "Name": "rhs_max",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "6th input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_quantized_flatten",
    "Description": "",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "A ndarray/symbol of type `float32`"
      },
      {
        "Name": "min_data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The minimum scalar value possibly produced for the data"
      },
      {
        "Name": "max_data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The maximum scalar value possibly produced for the data"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "Flatten",
    "Description": "Flattens the input array into a 2-D array by collapsing the higher dimensions.\n\n.. note:: `Flatten` is deprecated. Use `flatten` instead.\n\nFor an input array with shape ``(d1, d2, ..., dk)``, `flatten` operation reshapes\nthe input array into an output array of shape ``(d1, d2*...*dk)``.\n\nNote that the bahavior of this function is different from numpy.ndarray.flatten,\nwhich behaves similar to mxnet.ndarray.reshape((-1,)).\n\nExample::\n\n    x = [[\n        [1,2,3],\n        [4,5,6],\n        [7,8,9]\n    ],\n    [    [1,2,3],\n        [4,5,6],\n        [7,8,9]\n    ]],\n\n    flatten(x) = [[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.],\n       [ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\matrix_op.cc:L293",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_quantized_fully_connected",
    "Description": "Fully Connected operator for input, weight and bias data type of int8,\nand accumulates in type int32 for the output. For each argument, two more arguments of type\nfloat32 must be provided representing the thresholds of quantizing argument from data\ntype float32 to int8. The final outputs contain the convolution result in int32, and min\nand max thresholds representing the threholds for quantizing the float32 output into int32.\n\n.. Note::\n    This operator only supports forward propogation. DO NOT use it in training.\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\quantization\\quantized_fully_connected.cc:L313",
    "NumArgs": 12,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data."
      },
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "weight."
      },
      {
        "Name": "bias",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "bias."
      },
      {
        "Name": "min_data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Minimum value of data."
      },
      {
        "Name": "max_data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Maximum value of data."
      },
      {
        "Name": "min_weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Minimum value of weight."
      },
      {
        "Name": "max_weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Maximum value of weight."
      },
      {
        "Name": "min_bias",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Minimum value of bias."
      },
      {
        "Name": "max_bias",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Maximum value of bias."
      },
      {
        "Name": "num_hidden",
        "TypeInfo": "int, required",
        "Description": "Number of hidden nodes of the output."
      },
      {
        "Name": "no_bias",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether to disable bias parameter."
      },
      {
        "Name": "flatten",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "Whether to collapse all but the first axis of the input data tensor."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_quantized_pooling",
    "Description": "Pooling operator for input and output data type of int8.\nThe input and output data comes with min and max thresholds for quantizing\nthe float32 data into int8.\n\n.. Note::\n    This operator only supports forward propogation. DO NOT use it in training.\n    This operator only supports `pool_type` of `avg` or `max`.\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\quantization\\quantized_pooling.cc:L145",
    "NumArgs": 13,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data."
      },
      {
        "Name": "min_data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Minimum value of data."
      },
      {
        "Name": "max_data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Maximum value of data."
      },
      {
        "Name": "kernel",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "Pooling kernel size: (y, x) or (d, y, x)"
      },
      {
        "Name": "pool_type",
        "TypeInfo": "{'avg', 'lp', 'max', 'sum'},optional, default='max'",
        "Description": "Pooling type to be applied."
      },
      {
        "Name": "global_pool",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Ignore kernel size, do global pooling based on current input feature map. "
      },
      {
        "Name": "cudnn_off",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Turn off cudnn pooling and use MXNet pooling operator. "
      },
      {
        "Name": "pooling_convention",
        "TypeInfo": "{'full', 'same', 'valid'},optional, default='valid'",
        "Description": "Pooling convention to be applied."
      },
      {
        "Name": "stride",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "Stride: for pooling (y, x) or (d, y, x). Defaults to 1 for each dimension."
      },
      {
        "Name": "pad",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "Pad for pooling: (y, x) or (d, y, x). Defaults to no padding."
      },
      {
        "Name": "p_value",
        "TypeInfo": "int or None, optional, default='None'",
        "Description": "Value of p for Lp pooling, can be 1 or 2, required for Lp Pooling."
      },
      {
        "Name": "count_include_pad",
        "TypeInfo": "boolean or None, optional, default=None",
        "Description": "Only used for AvgPool, specify whether to count padding elements for averagecalculation. For example, with a 5*5 kernel on a 3*3 corner of a image,the sum of the 9 valid elements will be divided by 25 if this is set to true,or it will be divided by 9 if this is set to false. Defaults to true."
      },
      {
        "Name": "layout",
        "TypeInfo": "{None, 'NCDHW', 'NCHW', 'NCW', 'NDHWC', 'NHWC', 'NWC'},optional, default='None'",
        "Description": "Set layout for input and output. Empty for\n    default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_requantize",
    "Description": "Given data that is quantized in int32 and the corresponding thresholds,\nrequantize the data into int8 using min and max thresholds either calculated at runtime\nor from calibration. It's highly recommended to pre-calucate the min and max thresholds\nthrough calibration since it is able to save the runtime of the operator and improve the\ninference accuracy.\n\n.. Note::\n    This operator only supports forward propogation. DO NOT use it in training.\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\quantization\\requantize.cc:L60",
    "NumArgs": 6,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "A ndarray/symbol of type `int32`"
      },
      {
        "Name": "min_range",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The original minimum scalar value in the form of float32 used for quantizing data into int32."
      },
      {
        "Name": "max_range",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The original maximum scalar value in the form of float32 used for quantizing data into int32."
      },
      {
        "Name": "out_type",
        "TypeInfo": "{'auto', 'int8', 'uint8'},optional, default='int8'",
        "Description": "Output data type. `auto` can be specified to automatically determine output type according to min_calib_range."
      },
      {
        "Name": "min_calib_range",
        "TypeInfo": "float or None, optional, default=None",
        "Description": "The minimum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int32 data into int8."
      },
      {
        "Name": "max_calib_range",
        "TypeInfo": "float or None, optional, default=None",
        "Description": "The maximum scalar value in the form of float32 obtained through calibration. If present, it will be used to requantize the int32 data into int8."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_sample_uniform",
    "Description": "Concurrent sampling from multiple\nuniform distributions on the intervals given by *[low,high)*.\n\nThe parameters of the distributions are provided as input arrays.\nLet *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*\nbe the shape specified as the parameter of the operator, and *m* be the dimension\nof *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.\n\nFor any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*\nwill be an *m*-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index *i*. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.\n\nExamples::\n\n   low = [ 0.0, 2.5 ]\n   high = [ 1.0, 3.7 ]\n\n   // Draw a single sample for each distribution\n   sample_uniform(low, high) = [ 0.40451524,  3.18687344]\n\n   // Draw a vector containing two samples for each distribution\n   sample_uniform(low, high, shape=(2)) = [[ 0.40451524,  0.18017688],\n                                           [ 3.18687344,  3.68352246]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\random\\multisample_op.cc:L277",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "low",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Lower bounds of the distributions."
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=None",
        "Description": "Shape to be sampled from each random distribution."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'None', 'float16', 'float32', 'float64'},optional, default='None'",
        "Description": "DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None)."
      },
      {
        "Name": "high",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Upper bounds of the distributions."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_sample_normal",
    "Description": "Concurrent sampling from multiple\nnormal distributions with parameters *mu* (mean) and *sigma* (standard deviation).\n\nThe parameters of the distributions are provided as input arrays.\nLet *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*\nbe the shape specified as the parameter of the operator, and *m* be the dimension\nof *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.\n\nFor any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*\nwill be an *m*-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index *i*. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.\n\nExamples::\n\n   mu = [ 0.0, 2.5 ]\n   sigma = [ 1.0, 3.7 ]\n\n   // Draw a single sample for each distribution\n   sample_normal(mu, sigma) = [-0.56410581,  0.95934606]\n\n   // Draw a vector containing two samples for each distribution\n   sample_normal(mu, sigma, shape=(2)) = [[-0.56410581,  0.2928229 ],\n                                          [ 0.95934606,  4.48287058]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\random\\multisample_op.cc:L279",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "mu",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Means of the distributions."
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=None",
        "Description": "Shape to be sampled from each random distribution."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'None', 'float16', 'float32', 'float64'},optional, default='None'",
        "Description": "DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None)."
      },
      {
        "Name": "sigma",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Standard deviations of the distributions."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_sample_gamma",
    "Description": "Concurrent sampling from multiple\ngamma distributions with parameters *alpha* (shape) and *beta* (scale).\n\nThe parameters of the distributions are provided as input arrays.\nLet *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*\nbe the shape specified as the parameter of the operator, and *m* be the dimension\nof *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.\n\nFor any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*\nwill be an *m*-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index *i*. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.\n\nExamples::\n\n   alpha = [ 0.0, 2.5 ]\n   beta = [ 1.0, 0.7 ]\n\n   // Draw a single sample for each distribution\n   sample_gamma(alpha, beta) = [ 0.        ,  2.25797319]\n\n   // Draw a vector containing two samples for each distribution\n   sample_gamma(alpha, beta, shape=(2)) = [[ 0.        ,  0.        ],\n                                           [ 2.25797319,  1.70734084]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\random\\multisample_op.cc:L282",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "alpha",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Alpha (shape) parameters of the distributions."
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=None",
        "Description": "Shape to be sampled from each random distribution."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'None', 'float16', 'float32', 'float64'},optional, default='None'",
        "Description": "DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None)."
      },
      {
        "Name": "beta",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Beta (scale) parameters of the distributions."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_sample_exponential",
    "Description": "Concurrent sampling from multiple\nexponential distributions with parameters lambda (rate).\n\nThe parameters of the distributions are provided as an input array.\nLet *[s]* be the shape of the input array, *n* be the dimension of *[s]*, *[t]*\nbe the shape specified as the parameter of the operator, and *m* be the dimension\nof *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.\n\nFor any valid *n*-dimensional index *i* with respect to the input array, *output[i]*\nwill be an *m*-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input value at index *i*. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input array.\n\nExamples::\n\n   lam = [ 1.0, 8.5 ]\n\n   // Draw a single sample for each distribution\n   sample_exponential(lam) = [ 0.51837951,  0.09994757]\n\n   // Draw a vector containing two samples for each distribution\n   sample_exponential(lam, shape=(2)) = [[ 0.51837951,  0.19866663],\n                                         [ 0.09994757,  0.50447971]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\random\\multisample_op.cc:L284",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "lam",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Lambda (rate) parameters of the distributions."
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=None",
        "Description": "Shape to be sampled from each random distribution."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'None', 'float16', 'float32', 'float64'},optional, default='None'",
        "Description": "DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_sample_poisson",
    "Description": "Concurrent sampling from multiple\nPoisson distributions with parameters lambda (rate).\n\nThe parameters of the distributions are provided as an input array.\nLet *[s]* be the shape of the input array, *n* be the dimension of *[s]*, *[t]*\nbe the shape specified as the parameter of the operator, and *m* be the dimension\nof *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.\n\nFor any valid *n*-dimensional index *i* with respect to the input array, *output[i]*\nwill be an *m*-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input value at index *i*. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input array.\n\nSamples will always be returned as a floating point data type.\n\nExamples::\n\n   lam = [ 1.0, 8.5 ]\n\n   // Draw a single sample for each distribution\n   sample_poisson(lam) = [  0.,  13.]\n\n   // Draw a vector containing two samples for each distribution\n   sample_poisson(lam, shape=(2)) = [[  0.,   4.],\n                                     [ 13.,   8.]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\random\\multisample_op.cc:L286",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "lam",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Lambda (rate) parameters of the distributions."
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=None",
        "Description": "Shape to be sampled from each random distribution."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'None', 'float16', 'float32', 'float64'},optional, default='None'",
        "Description": "DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_sample_negative_binomial",
    "Description": "Concurrent sampling from multiple\nnegative binomial distributions with parameters *k* (failure limit) and *p* (failure probability).\n\nThe parameters of the distributions are provided as input arrays.\nLet *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*\nbe the shape specified as the parameter of the operator, and *m* be the dimension\nof *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.\n\nFor any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*\nwill be an *m*-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index *i*. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.\n\nSamples will always be returned as a floating point data type.\n\nExamples::\n\n   k = [ 20, 49 ]\n   p = [ 0.4 , 0.77 ]\n\n   // Draw a single sample for each distribution\n   sample_negative_binomial(k, p) = [ 15.,  16.]\n\n   // Draw a vector containing two samples for each distribution\n   sample_negative_binomial(k, p, shape=(2)) = [[ 15.,  50.],\n                                                [ 16.,  12.]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\random\\multisample_op.cc:L289",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "k",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Limits of unsuccessful experiments."
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=None",
        "Description": "Shape to be sampled from each random distribution."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'None', 'float16', 'float32', 'float64'},optional, default='None'",
        "Description": "DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None)."
      },
      {
        "Name": "p",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Failure probabilities in each experiment."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_sample_generalized_negative_binomial",
    "Description": "Concurrent sampling from multiple\ngeneralized negative binomial distributions with parameters *mu* (mean) and *alpha* (dispersion).\n\nThe parameters of the distributions are provided as input arrays.\nLet *[s]* be the shape of the input arrays, *n* be the dimension of *[s]*, *[t]*\nbe the shape specified as the parameter of the operator, and *m* be the dimension\nof *[t]*. Then the output will be a *(n+m)*-dimensional array with shape *[s]x[t]*.\n\nFor any valid *n*-dimensional index *i* with respect to the input arrays, *output[i]*\nwill be an *m*-dimensional array that holds randomly drawn samples from the distribution\nwhich is parameterized by the input values at index *i*. If the shape parameter of the\noperator is not set, then one sample will be drawn per distribution and the output array\nhas the same shape as the input arrays.\n\nSamples will always be returned as a floating point data type.\n\nExamples::\n\n   mu = [ 2.0, 2.5 ]\n   alpha = [ 1.0, 0.1 ]\n\n   // Draw a single sample for each distribution\n   sample_generalized_negative_binomial(mu, alpha) = [ 0.,  3.]\n\n   // Draw a vector containing two samples for each distribution\n   sample_generalized_negative_binomial(mu, alpha, shape=(2)) = [[ 0.,  3.],\n                                                                 [ 3.,  1.]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\random\\multisample_op.cc:L293",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "mu",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Means of the distributions."
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=None",
        "Description": "Shape to be sampled from each random distribution."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'None', 'float16', 'float32', 'float64'},optional, default='None'",
        "Description": "DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None)."
      },
      {
        "Name": "alpha",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Alpha (dispersion) parameters of the distributions."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_sample_multinomial",
    "Description": "Concurrent sampling from multiple multinomial distributions.\n\n*data* is an *n* dimensional array whose last dimension has length *k*, where\n*k* is the number of possible outcomes of each multinomial distribution. This\noperator will draw *shape* samples from each distribution. If shape is empty\none sample will be drawn from each distribution.\n\nIf *get_prob* is true, a second array containing log likelihood of the drawn\nsamples will also be returned. This is usually used for reinforcement learning\nwhere you can provide reward as head gradient for this array to estimate\ngradient.\n\nNote that the input distribution must be normalized, i.e. *data* must sum to\n1 along its last axis.\n\nExamples::\n\n   probs = [[0, 0.1, 0.2, 0.3, 0.4], [0.4, 0.3, 0.2, 0.1, 0]]\n\n   // Draw a single sample for each distribution\n   sample_multinomial(probs) = [3, 0]\n\n   // Draw a vector containing two samples for each distribution\n   sample_multinomial(probs, shape=(2)) = [[4, 2],\n                                           [0, 0]]\n\n   // requests log likelihood\n   sample_multinomial(probs, get_prob=True) = [2, 1], [0.2, 0.3]\n",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Distribution probabilities. Must sum to one on the last axis."
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "Shape to be sampled from each random distribution."
      },
      {
        "Name": "get_prob",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether to also return the log probability of sampled result. This is usually used for differentiating through stochastic variables, e.g. in reinforcement learning."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'float16', 'float32', 'float64', 'int32', 'uint8'},optional, default='int32'",
        "Description": "DType of the output in case this can't be inferred."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_sample_multinomial",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_random_uniform",
    "Description": "Draw random samples from a uniform distribution.\n\n.. note:: The existing alias ``uniform`` is deprecated.\n\nSamples are uniformly distributed over the half-open interval *[low, high)*\n(includes *low*, but excludes *high*).\n\nExample::\n\n   uniform(low=0, high=1, shape=(2,2)) = [[ 0.60276335,  0.85794562],\n                                          [ 0.54488319,  0.84725171]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\random\\sample_op.cc:L96",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "low",
        "TypeInfo": "float, optional, default=0",
        "Description": "Lower bound of the distribution."
      },
      {
        "Name": "high",
        "TypeInfo": "float, optional, default=1",
        "Description": "Upper bound of the distribution."
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=None",
        "Description": "Shape of the output."
      },
      {
        "Name": "ctx",
        "TypeInfo": "string, optional, default=''",
        "Description": "Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'None', 'float16', 'float32', 'float64'},optional, default='None'",
        "Description": "DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_random_normal",
    "Description": "Draw random samples from a normal (Gaussian) distribution.\n\n.. note:: The existing alias ``normal`` is deprecated.\n\nSamples are distributed according to a normal distribution parametrized by *loc* (mean) and *scale*\n(standard deviation).\n\nExample::\n\n   normal(loc=0, scale=1, shape=(2,2)) = [[ 1.89171135, -1.16881478],\n                                          [-1.23474145,  1.55807114]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\random\\sample_op.cc:L113",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "loc",
        "TypeInfo": "float, optional, default=0",
        "Description": "Mean of the distribution."
      },
      {
        "Name": "scale",
        "TypeInfo": "float, optional, default=1",
        "Description": "Standard deviation of the distribution."
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=None",
        "Description": "Shape of the output."
      },
      {
        "Name": "ctx",
        "TypeInfo": "string, optional, default=''",
        "Description": "Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'None', 'float16', 'float32', 'float64'},optional, default='None'",
        "Description": "DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_random_gamma",
    "Description": "Draw random samples from a gamma distribution.\n\nSamples are distributed according to a gamma distribution parametrized by *alpha* (shape) and *beta* (scale).\n\nExample::\n\n   gamma(alpha=9, beta=0.5, shape=(2,2)) = [[ 7.10486984,  3.37695289],\n                                            [ 3.91697288,  3.65933681]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\random\\sample_op.cc:L125",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "alpha",
        "TypeInfo": "float, optional, default=1",
        "Description": "Alpha parameter (shape) of the gamma distribution."
      },
      {
        "Name": "beta",
        "TypeInfo": "float, optional, default=1",
        "Description": "Beta parameter (scale) of the gamma distribution."
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=None",
        "Description": "Shape of the output."
      },
      {
        "Name": "ctx",
        "TypeInfo": "string, optional, default=''",
        "Description": "Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'None', 'float16', 'float32', 'float64'},optional, default='None'",
        "Description": "DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_random_exponential",
    "Description": "Draw random samples from an exponential distribution.\n\nSamples are distributed according to an exponential distribution parametrized by *lambda* (rate).\n\nExample::\n\n   exponential(lam=4, shape=(2,2)) = [[ 0.0097189 ,  0.08999364],\n                                      [ 0.04146638,  0.31715935]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\random\\sample_op.cc:L137",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "lam",
        "TypeInfo": "float, optional, default=1",
        "Description": "Lambda parameter (rate) of the exponential distribution."
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=None",
        "Description": "Shape of the output."
      },
      {
        "Name": "ctx",
        "TypeInfo": "string, optional, default=''",
        "Description": "Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'None', 'float16', 'float32', 'float64'},optional, default='None'",
        "Description": "DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_random_poisson",
    "Description": "Draw random samples from a Poisson distribution.\n\nSamples are distributed according to a Poisson distribution parametrized by *lambda* (rate).\nSamples will always be returned as a floating point data type.\n\nExample::\n\n   poisson(lam=4, shape=(2,2)) = [[ 5.,  2.],\n                                  [ 4.,  6.]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\random\\sample_op.cc:L150",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "lam",
        "TypeInfo": "float, optional, default=1",
        "Description": "Lambda parameter (rate) of the Poisson distribution."
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=None",
        "Description": "Shape of the output."
      },
      {
        "Name": "ctx",
        "TypeInfo": "string, optional, default=''",
        "Description": "Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'None', 'float16', 'float32', 'float64'},optional, default='None'",
        "Description": "DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_random_negative_binomial",
    "Description": "Draw random samples from a negative binomial distribution.\n\nSamples are distributed according to a negative binomial distribution parametrized by\n*k* (limit of unsuccessful experiments) and *p* (failure probability in each experiment).\nSamples will always be returned as a floating point data type.\n\nExample::\n\n   negative_binomial(k=3, p=0.4, shape=(2,2)) = [[ 4.,  7.],\n                                                 [ 2.,  5.]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\random\\sample_op.cc:L164",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "k",
        "TypeInfo": "int, optional, default='1'",
        "Description": "Limit of unsuccessful experiments."
      },
      {
        "Name": "p",
        "TypeInfo": "float, optional, default=1",
        "Description": "Failure probability in each experiment."
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=None",
        "Description": "Shape of the output."
      },
      {
        "Name": "ctx",
        "TypeInfo": "string, optional, default=''",
        "Description": "Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'None', 'float16', 'float32', 'float64'},optional, default='None'",
        "Description": "DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_random_generalized_negative_binomial",
    "Description": "Draw random samples from a generalized negative binomial distribution.\n\nSamples are distributed according to a generalized negative binomial distribution parametrized by\n*mu* (mean) and *alpha* (dispersion). *alpha* is defined as *1/k* where *k* is the failure limit of the\nnumber of unsuccessful experiments (generalized to real numbers).\nSamples will always be returned as a floating point data type.\n\nExample::\n\n   generalized_negative_binomial(mu=2.0, alpha=0.3, shape=(2,2)) = [[ 2.,  1.],\n                                                                    [ 6.,  4.]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\random\\sample_op.cc:L179",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "mu",
        "TypeInfo": "float, optional, default=1",
        "Description": "Mean of the negative binomial distribution."
      },
      {
        "Name": "alpha",
        "TypeInfo": "float, optional, default=1",
        "Description": "Alpha (dispersion) parameter of the negative binomial distribution."
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=None",
        "Description": "Shape of the output."
      },
      {
        "Name": "ctx",
        "TypeInfo": "string, optional, default=''",
        "Description": "Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'None', 'float16', 'float32', 'float64'},optional, default='None'",
        "Description": "DType of the output in case this can't be inferred. Defaults to float32 if not defined (dtype=None)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_random_randint",
    "Description": "Draw random samples from a discrete uniform distribution.\n\nSamples are uniformly distributed over the half-open interval *[low, high)*\n(includes *low*, but excludes *high*).\n\nExample::\n\n   randint(low=0, high=5, shape=(2,2)) = [[ 0,  2],\n                                          [ 3,  1]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\random\\sample_op.cc:L193",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "low",
        "TypeInfo": ", required",
        "Description": "Lower bound of the distribution."
      },
      {
        "Name": "high",
        "TypeInfo": ", required",
        "Description": "Upper bound of the distribution."
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=None",
        "Description": "Shape of the output."
      },
      {
        "Name": "ctx",
        "TypeInfo": "string, optional, default=''",
        "Description": "Context of output, in format [cpu|gpu|cpu_pinned](n). Only used for imperative calls."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'None', 'int32', 'int64'},optional, default='None'",
        "Description": "DType of the output in case this can't be inferred. Defaults to int32 if not defined (dtype=None)."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_random_uniform_like",
    "Description": "Draw random samples from a uniform distribution according to the input array shape.\n\nSamples are uniformly distributed over the half-open interval *[low, high)*\n(includes *low*, but excludes *high*).\n\nExample::\n\n   uniform(low=0, high=1, data=ones(2,2)) = [[ 0.60276335,  0.85794562],\n                                             [ 0.54488319,  0.84725171]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\random\\sample_op.cc:L208",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "low",
        "TypeInfo": "float, optional, default=0",
        "Description": "Lower bound of the distribution."
      },
      {
        "Name": "high",
        "TypeInfo": "float, optional, default=1",
        "Description": "Upper bound of the distribution."
      },
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_random_normal_like",
    "Description": "Draw random samples from a normal (Gaussian) distribution according to the input array shape.\n\nSamples are distributed according to a normal distribution parametrized by *loc* (mean) and *scale*\n(standard deviation).\n\nExample::\n\n   normal(loc=0, scale=1, data=ones(2,2)) = [[ 1.89171135, -1.16881478],\n                                             [-1.23474145,  1.55807114]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\random\\sample_op.cc:L220",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "loc",
        "TypeInfo": "float, optional, default=0",
        "Description": "Mean of the distribution."
      },
      {
        "Name": "scale",
        "TypeInfo": "float, optional, default=1",
        "Description": "Standard deviation of the distribution."
      },
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_random_gamma_like",
    "Description": "Draw random samples from a gamma distribution according to the input array shape.\n\nSamples are distributed according to a gamma distribution parametrized by *alpha* (shape) and *beta* (scale).\n\nExample::\n\n   gamma(alpha=9, beta=0.5, data=ones(2,2)) = [[ 7.10486984,  3.37695289],\n                                               [ 3.91697288,  3.65933681]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\random\\sample_op.cc:L231",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "alpha",
        "TypeInfo": "float, optional, default=1",
        "Description": "Alpha parameter (shape) of the gamma distribution."
      },
      {
        "Name": "beta",
        "TypeInfo": "float, optional, default=1",
        "Description": "Beta parameter (scale) of the gamma distribution."
      },
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_random_exponential_like",
    "Description": "Draw random samples from an exponential distribution according to the input array shape.\n\nSamples are distributed according to an exponential distribution parametrized by *lambda* (rate).\n\nExample::\n\n   exponential(lam=4, data=ones(2,2)) = [[ 0.0097189 ,  0.08999364],\n                                         [ 0.04146638,  0.31715935]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\random\\sample_op.cc:L242",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lam",
        "TypeInfo": "float, optional, default=1",
        "Description": "Lambda parameter (rate) of the exponential distribution."
      },
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_random_poisson_like",
    "Description": "Draw random samples from a Poisson distribution according to the input array shape.\n\nSamples are distributed according to a Poisson distribution parametrized by *lambda* (rate).\nSamples will always be returned as a floating point data type.\n\nExample::\n\n   poisson(lam=4, data=ones(2,2)) = [[ 5.,  2.],\n                                     [ 4.,  6.]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\random\\sample_op.cc:L254",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lam",
        "TypeInfo": "float, optional, default=1",
        "Description": "Lambda parameter (rate) of the Poisson distribution."
      },
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_random_negative_binomial_like",
    "Description": "Draw random samples from a negative binomial distribution according to the input array shape.\n\nSamples are distributed according to a negative binomial distribution parametrized by\n*k* (limit of unsuccessful experiments) and *p* (failure probability in each experiment).\nSamples will always be returned as a floating point data type.\n\nExample::\n\n   negative_binomial(k=3, p=0.4, data=ones(2,2)) = [[ 4.,  7.],\n                                                    [ 2.,  5.]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\random\\sample_op.cc:L267",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "k",
        "TypeInfo": "int, optional, default='1'",
        "Description": "Limit of unsuccessful experiments."
      },
      {
        "Name": "p",
        "TypeInfo": "float, optional, default=1",
        "Description": "Failure probability in each experiment."
      },
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_random_generalized_negative_binomial_like",
    "Description": "Draw random samples from a generalized negative binomial distribution according to the\ninput array shape.\n\nSamples are distributed according to a generalized negative binomial distribution parametrized by\n*mu* (mean) and *alpha* (dispersion). *alpha* is defined as *1/k* where *k* is the failure limit of the\nnumber of unsuccessful experiments (generalized to real numbers).\nSamples will always be returned as a floating point data type.\n\nExample::\n\n   generalized_negative_binomial(mu=2.0, alpha=0.3, data=ones(2,2)) = [[ 2.,  1.],\n                                                                       [ 6.,  4.]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\random\\sample_op.cc:L283",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "mu",
        "TypeInfo": "float, optional, default=1",
        "Description": "Mean of the negative binomial distribution."
      },
      {
        "Name": "alpha",
        "TypeInfo": "float, optional, default=1",
        "Description": "Alpha (dispersion) parameter of the negative binomial distribution."
      },
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_shuffle",
    "Description": "Randomly shuffle the elements.\n\nThis shuffles the array along the first axis.\nThe order of the elements in each subarray does not change.\nFor example, if a 2D array is given, the order of the rows randomly changes,\nbut the order of the elements in each row does not change.\n",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Data to be shuffled."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_sample_unique_zipfian",
    "Description": "Draw random samples from an an approximately log-uniform\nor Zipfian distribution without replacement.\n\nThis operation takes a 2-D shape `(batch_size, num_sampled)`,\nand randomly generates *num_sampled* samples from the range of integers [0, range_max)\nfor each instance in the batch.\n\nThe elements in each instance are drawn without replacement from the base distribution.\nThe base distribution for this operator is an approximately log-uniform or Zipfian distribution:\n\n  P(class) = (log(class + 2) - log(class + 1)) / log(range_max + 1)\n\nAdditionaly, it also returns the number of trials used to obtain `num_sampled` samples for\neach instance in the batch.\n\nExample::\n\n   samples, trials = _sample_unique_zipfian(750000, shape=(4, 8192))\n   unique(samples[0]) = 8192\n   unique(samples[3]) = 8192\n   trials[0] = 16435\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\random\\unique_sample_op.cc:L66",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "range_max",
        "TypeInfo": "int, required",
        "Description": "The number of possible classes."
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=None",
        "Description": "2-D shape of the output, where shape[0] is the batch size, and shape[1] is the number of candidates to sample for each batch."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "LinearRegressionOutput",
    "Description": "Computes and optimizes for squared loss during backward propagation.\nJust outputs ``data`` during forward propagation.\n\nIf :math:`\\hat{y}_i` is the predicted value of the i-th sample, and :math:`y_i` is the corresponding target value,\nthen the squared loss estimated over :math:`n` samples is defined as\n\n:math:`\\text{SquaredLoss}(\\textbf{Y}, \\hat{\\textbf{Y}} ) = \\frac{1}{n} \\sum_{i=0}^{n-1} \\lVert  \\textbf{y}_i - \\hat{\\textbf{y}}_i  \\rVert_2`\n\n.. note::\n   Use the LinearRegressionOutput as the final output layer of a net.\n\nThe storage type of ``label`` can be ``default`` or ``csr``\n\n- LinearRegressionOutput(default, default) = default\n- LinearRegressionOutput(default, csr) = default\n\nBy default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.\nThe parameter `grad_scale` can be used to change this scale to `grad_scale/m`.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\regression_output.cc:L92",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data to the function."
      },
      {
        "Name": "label",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input label to the function."
      },
      {
        "Name": "grad_scale",
        "TypeInfo": "float, optional, default=1",
        "Description": "Scale the gradient by a float factor"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_linear_reg_out",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "MAERegressionOutput",
    "Description": "Computes mean absolute error of the input.\n\nMAE is a risk metric corresponding to the expected value of the absolute error.\n\nIf :math:`\\hat{y}_i` is the predicted value of the i-th sample, and :math:`y_i` is the corresponding target value,\nthen the mean absolute error (MAE) estimated over :math:`n` samples is defined as\n\n:math:`\\text{MAE}(\\textbf{Y}, \\hat{\\textbf{Y}} ) = \\frac{1}{n} \\sum_{i=0}^{n-1} \\lVert \\textbf{y}_i - \\hat{\\textbf{y}}_i \\rVert_1`\n\n.. note::\n   Use the MAERegressionOutput as the final output layer of a net.\n\nThe storage type of ``label`` can be ``default`` or ``csr``\n\n- MAERegressionOutput(default, default) = default\n- MAERegressionOutput(default, csr) = default\n\nBy default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.\nThe parameter `grad_scale` can be used to change this scale to `grad_scale/m`.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\regression_output.cc:L120",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data to the function."
      },
      {
        "Name": "label",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input label to the function."
      },
      {
        "Name": "grad_scale",
        "TypeInfo": "float, optional, default=1",
        "Description": "Scale the gradient by a float factor"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_mae_reg_out",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "LogisticRegressionOutput",
    "Description": "Applies a logistic function to the input.\n\nThe logistic function, also known as the sigmoid function, is computed as\n:math:`\\frac{1}{1+exp(-\\textbf{x})}`.\n\nCommonly, the sigmoid is used to squash the real-valued output of a linear model\n:math:`wTx+b` into the [0,1] range so that it can be interpreted as a probability.\nIt is suitable for binary classification or probability prediction tasks.\n\n.. note::\n   Use the LogisticRegressionOutput as the final output layer of a net.\n\nThe storage type of ``label`` can be ``default`` or ``csr``\n\n- LogisticRegressionOutput(default, default) = default\n- LogisticRegressionOutput(default, csr) = default\n\nThe loss function used is the Binary Cross Entropy Loss:\n\n:math:`-{(y\\log(p) + (1 - y)\\log(1 - p))}`\n\nWhere `y` is the ground truth probability of positive outcome for a given example, and `p` the probability predicted by the model. By default, gradients of this loss function are scaled by factor `1/m`, where m is the number of regression outputs of a training example.\nThe parameter `grad_scale` can be used to change this scale to `grad_scale/m`.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\regression_output.cc:L152",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data to the function."
      },
      {
        "Name": "label",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input label to the function."
      },
      {
        "Name": "grad_scale",
        "TypeInfo": "float, optional, default=1",
        "Description": "Scale the gradient by a float factor"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_logistic_reg_out",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "RNN",
    "Description": "Applies recurrent layers to input data. Currently, vanilla RNN, LSTM and GRU are\nimplemented, with both multi-layer and bidirectional support.\n\nWhen the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE\nand MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use\npseudo-float16 precision (float32 math with float16 I/O) precision in order to use\nTensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.\n\n**Vanilla RNN**\n\nApplies a single-gate recurrent layer to input X. Two kinds of activation function are supported:\nReLU and Tanh.\n\nWith ReLU activation function:\n\n.. math::\n    h_t = relu(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})\n\nWith Tanh activtion function:\n\n.. math::\n    h_t = \\tanh(W_{ih} * x_t + b_{ih}  +  W_{hh} * h_{(t-1)} + b_{hh})\n\nReference paper: Finding structure in time - Elman, 1988.\nhttps://crl.ucsd.edu/~elman/Papers/fsit.pdf\n\n**LSTM**\n\nLong Short-Term Memory - Hochreiter, 1997. http://www.bioinf.jku.at/publications/older/2604.pdf\n\n.. math::\n  \\begin{array}{ll}\n            i_t = \\mathrm{sigmoid}(W_{ii} x_t + b_{ii} + W_{hi} h_{(t-1)} + b_{hi}) \\\\\n            f_t = \\mathrm{sigmoid}(W_{if} x_t + b_{if} + W_{hf} h_{(t-1)} + b_{hf}) \\\\\n            g_t = \\tanh(W_{ig} x_t + b_{ig} + W_{hc} h_{(t-1)} + b_{hg}) \\\\\n            o_t = \\mathrm{sigmoid}(W_{io} x_t + b_{io} + W_{ho} h_{(t-1)} + b_{ho}) \\\\\n            c_t = f_t * c_{(t-1)} + i_t * g_t \\\\\n            h_t = o_t * \\tanh(c_t)\n            \\end{array}\n\n**GRU**\n\nGated Recurrent Unit - Cho et al. 2014. http://arxiv.org/abs/1406.1078\n\nThe definition of GRU here is slightly different from paper but compatible with CUDNN.\n\n.. math::\n  \\begin{array}{ll}\n            r_t = \\mathrm{sigmoid}(W_{ir} x_t + b_{ir} + W_{hr} h_{(t-1)} + b_{hr}) \\\\\n            z_t = \\mathrm{sigmoid}(W_{iz} x_t + b_{iz} + W_{hz} h_{(t-1)} + b_{hz}) \\\\\n            n_t = \\tanh(W_{in} x_t + b_{in} + r_t * (W_{hn} h_{(t-1)}+ b_{hn})) \\\\\n            h_t = (1 - z_t) * n_t + z_t * h_{(t-1)} \\\\\n            \\end{array}\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\rnn.cc:L690",
    "NumArgs": 16,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data to RNN"
      },
      {
        "Name": "parameters",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Vector of all RNN trainable parameters concatenated"
      },
      {
        "Name": "state",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "initial hidden state of the RNN"
      },
      {
        "Name": "state_cell",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "initial cell state for LSTM networks (only for LSTM)"
      },
      {
        "Name": "sequence_length",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Vector of valid sequence lengths for each element in batch. (Only used if use_sequence_length kwarg is True)"
      },
      {
        "Name": "state_size",
        "TypeInfo": "int (non-negative), required",
        "Description": "size of the state for each layer"
      },
      {
        "Name": "num_layers",
        "TypeInfo": "int (non-negative), required",
        "Description": "number of stacked layers"
      },
      {
        "Name": "bidirectional",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "whether to use bidirectional recurrent layers"
      },
      {
        "Name": "mode",
        "TypeInfo": "{'gru', 'lstm', 'rnn_relu', 'rnn_tanh'}, required",
        "Description": "the type of RNN to compute"
      },
      {
        "Name": "p",
        "TypeInfo": "float, optional, default=0",
        "Description": "drop rate of the dropout on the outputs of each RNN layer, except the last layer."
      },
      {
        "Name": "state_outputs",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether to have the states as symbol outputs."
      },
      {
        "Name": "projection_size",
        "TypeInfo": "int or None, optional, default='None'",
        "Description": "size of project size"
      },
      {
        "Name": "lstm_state_clip_min",
        "TypeInfo": "double or None, optional, default=None",
        "Description": "Minimum clip value of LSTM states. This option must be used together with lstm_state_clip_max."
      },
      {
        "Name": "lstm_state_clip_max",
        "TypeInfo": "double or None, optional, default=None",
        "Description": "Maximum clip value of LSTM states. This option must be used together with lstm_state_clip_min."
      },
      {
        "Name": "lstm_state_clip_nan",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether to stop NaN from propagating in state by clipping it to min/max. If clipping range is not specified, this option is ignored."
      },
      {
        "Name": "use_sequence_length",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_RNN",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "SliceChannel",
    "Description": "Splits an array along a particular axis into multiple sub-arrays.\n\n.. note:: ``SliceChannel`` is deprecated. Use ``split`` instead.\n\n**Note** that `num_outputs` should evenly divide the length of the axis\nalong which to split the array.\n\nExample::\n\n   x  = [[[ 1.]\n          [ 2.]]\n         [[ 3.]\n          [ 4.]]\n         [[ 5.]\n          [ 6.]]]\n   x.shape = (3, 2, 1)\n\n   y = split(x, axis=1, num_outputs=2) // a list of 2 arrays with shape (3, 1, 1)\n   y = [[[ 1.]]\n        [[ 3.]]\n        [[ 5.]]]\n\n       [[[ 2.]]\n        [[ 4.]]\n        [[ 6.]]]\n\n   y[0].shape = (3, 1, 1)\n\n   z = split(x, axis=0, num_outputs=3) // a list of 3 arrays with shape (1, 2, 1)\n   z = [[[ 1.]\n         [ 2.]]]\n\n       [[[ 3.]\n         [ 4.]]]\n\n       [[[ 5.]\n         [ 6.]]]\n\n   z[0].shape = (1, 2, 1)\n\n`squeeze_axis=1` removes the axis with length 1 from the shapes of the output arrays.\n**Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only\nalong the `axis` which it is split.\nAlso `squeeze_axis` can be set to true only if ``input.shape[axis] == num_outputs``.\n\nExample::\n\n   z = split(x, axis=0, num_outputs=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)\n   z = [[ 1.]\n        [ 2.]]\n\n       [[ 3.]\n        [ 4.]]\n\n       [[ 5.]\n        [ 6.]]\n   z[0].shape = (2 ,1 )\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\slice_channel.cc:L107",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      },
      {
        "Name": "num_outputs",
        "TypeInfo": "int, required",
        "Description": "Number of splits. Note that this should evenly divide the length of the `axis`."
      },
      {
        "Name": "axis",
        "TypeInfo": "int, optional, default='1'",
        "Description": "Axis along which to split."
      },
      {
        "Name": "squeeze_axis",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "SoftmaxOutput",
    "Description": "Computes the gradient of cross entropy loss with respect to softmax output.\n\n- This operator computes the gradient in two steps.\n  The cross entropy loss does not actually need to be computed.\n\n  - Applies softmax function on the input array.\n  - Computes and returns the gradient of cross entropy loss w.r.t. the softmax output.\n\n- The softmax function, cross entropy loss and gradient is given by:\n\n  - Softmax Function:\n\n    .. math:: \\text{softmax}(x)_i = \\frac{exp(x_i)}{\\sum_j exp(x_j)}\n\n  - Cross Entropy Function:\n\n    .. math:: \\text{CE(label, output)} = - \\sum_i \\text{label}_i \\log(\\text{output}_i)\n\n  - The gradient of cross entropy loss w.r.t softmax output:\n\n    .. math:: \\text{gradient} = \\text{output} - \\text{label}\n\n- During forward propagation, the softmax function is computed for each instance in the input array.\n\n  For general *N*-D input arrays with shape :math:`(d_1, d_2, ..., d_n)`. The size is\n  :math:`s=d_1 \\cdot d_2 \\cdot \\cdot \\cdot d_n`. We can use the parameters `preserve_shape`\n  and `multi_output` to specify the way to compute softmax:\n\n  - By default, `preserve_shape` is ``false``. This operator will reshape the input array\n    into a 2-D array with shape :math:`(d_1, \\frac{s}{d_1})` and then compute the softmax function for\n    each row in the reshaped array, and afterwards reshape it back to the original shape\n    :math:`(d_1, d_2, ..., d_n)`.\n  - If `preserve_shape` is ``true``, the softmax function will be computed along\n    the last axis (`axis` = ``-1``).\n  - If `multi_output` is ``true``, the softmax function will be computed along\n    the second axis (`axis` = ``1``).\n\n- During backward propagation, the gradient of cross-entropy loss w.r.t softmax output array is computed.\n  The provided label can be a one-hot label array or a probability label array.\n\n  - If the parameter `use_ignore` is ``true``, `ignore_label` can specify input instances\n    with a particular label to be ignored during backward propagation. **This has no effect when\n    softmax `output` has same shape as `label`**.\n\n    Example::\n\n      data = [[1,2,3,4],[2,2,2,2],[3,3,3,3],[4,4,4,4]]\n      label = [1,0,2,3]\n      ignore_label = 1\n      SoftmaxOutput(data=data, label = label,\\\n                    multi_output=true, use_ignore=true,\\\n                    ignore_label=ignore_label)\n      ## forward softmax output\n      [[ 0.0320586   0.08714432  0.23688284  0.64391428]\n       [ 0.25        0.25        0.25        0.25      ]\n       [ 0.25        0.25        0.25        0.25      ]\n       [ 0.25        0.25        0.25        0.25      ]]\n      ## backward gradient output\n      [[ 0.    0.    0.    0.  ]\n       [-0.75  0.25  0.25  0.25]\n       [ 0.25  0.25 -0.75  0.25]\n       [ 0.25  0.25  0.25 -0.75]]\n      ## notice that the first row is all 0 because label[0] is 1, which is equal to ignore_label.\n\n  - The parameter `grad_scale` can be used to rescale the gradient, which is often used to\n    give each loss function different weights.\n\n  - This operator also supports various ways to normalize the gradient by `normalization`,\n    The `normalization` is applied if softmax output has different shape than the labels.\n    The `normalization` mode can be set to the followings:\n\n    - ``'null'``: do nothing.\n    - ``'batch'``: divide the gradient by the batch size.\n    - ``'valid'``: divide the gradient by the number of instances which are not ignored.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\softmax_output.cc:L230",
    "NumArgs": 10,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input array."
      },
      {
        "Name": "label",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Ground truth label."
      },
      {
        "Name": "grad_scale",
        "TypeInfo": "float, optional, default=1",
        "Description": "Scales the gradient by a float factor."
      },
      {
        "Name": "ignore_label",
        "TypeInfo": "float, optional, default=-1",
        "Description": "The instances whose `labels` == `ignore_label` will be ignored during backward, if `use_ignore` is set to ``true``)."
      },
      {
        "Name": "multi_output",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If set to ``true``, the softmax function will be computed along axis ``1``. This is applied when the shape of input array differs from the shape of label array."
      },
      {
        "Name": "use_ignore",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If set to ``true``, the `ignore_label` value will not contribute to the backward gradient."
      },
      {
        "Name": "preserve_shape",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If set to ``true``, the softmax function will be computed along the last axis (``-1``)."
      },
      {
        "Name": "normalization",
        "TypeInfo": "{'batch', 'null', 'valid'},optional, default='null'",
        "Description": "Normalizes the gradient."
      },
      {
        "Name": "out_grad",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Multiplies gradient with output gradient element-wise."
      },
      {
        "Name": "smooth_alpha",
        "TypeInfo": "float, optional, default=0",
        "Description": "Constant for computing a label smoothed version of cross-entropyfor the backwards pass.  This constant gets subtracted from theone-hot encoding of the gold label and distributed uniformly toall other labels."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_SoftmaxOutput",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "SwapAxis",
    "Description": "Interchanges two axes of an array.\n\nExamples::\n\n  x = [[1, 2, 3]])\n  swapaxes(x, 0, 1) = [[ 1],\n                       [ 2],\n                       [ 3]]\n\n  x = [[[ 0, 1],\n        [ 2, 3]],\n       [[ 4, 5],\n        [ 6, 7]]]  // (2,2,2) array\n\n swapaxes(x, 0, 2) = [[[ 0, 4],\n                       [ 2, 6]],\n                      [[ 1, 5],\n                       [ 3, 7]]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\swapaxis.cc:L70",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input array."
      },
      {
        "Name": "dim1",
        "TypeInfo": "int (non-negative), optional, default=0",
        "Description": "the first axis to be swapped."
      },
      {
        "Name": "dim2",
        "TypeInfo": "int (non-negative), optional, default=0",
        "Description": "the second axis to be swapped."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "amp_cast",
    "Description": "Cast function between low precision float/FP32 used by AMP.\n\nIt casts only between low precision float/FP32 and does not do anything for other types.\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\amp_cast.cc:L37",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'}, required",
        "Description": "Output data type."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_amp_cast",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "amp_multicast",
    "Description": "Cast function used by AMP, that casts its inputs to the common widest type.\n\nIt casts only between low precision float/FP32 and does not do anything for other types.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\amp_cast.cc:L71",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "Weights"
      },
      {
        "Name": "num_outputs",
        "TypeInfo": "int, required",
        "Description": "Number of input/output pairs to be casted to the widest type."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_amp_multicast",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "grad",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "Gradients"
      },
      {
        "Name": "num_outputs",
        "TypeInfo": "int, required",
        "Description": "Number of input/output pairs to be casted to the widest type."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "argmax",
    "Description": "Returns indices of the maximum values along an axis.\n\nIn the case of multiple occurrences of maximum values, the indices corresponding to the first occurrence\nare returned.\n\nExamples::\n\n  x = [[ 0.,  1.,  2.],\n       [ 3.,  4.,  5.]]\n\n  // argmax along axis 0\n  argmax(x, axis=0) = [ 1.,  1.,  1.]\n\n  // argmax along axis 1\n  argmax(x, axis=1) = [ 2.,  2.]\n\n  // argmax along axis 1 keeping same dims as an input array\n  argmax(x, axis=1, keepdims=True) = [[ 2.],\n                                      [ 2.]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\broadcast_reduce_op_index.cc:L52",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      },
      {
        "Name": "axis",
        "TypeInfo": "int or None, optional, default='None'",
        "Description": "The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``"
      },
      {
        "Name": "keepdims",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If this is set to `True`, the reduced axis is left in the result as dimension with size one."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "argmin",
    "Description": "Returns indices of the minimum values along an axis.\n\nIn the case of multiple occurrences of minimum values, the indices corresponding to the first occurrence\nare returned.\n\nExamples::\n\n  x = [[ 0.,  1.,  2.],\n       [ 3.,  4.,  5.]]\n\n  // argmin along axis 0\n  argmin(x, axis=0) = [ 0.,  0.,  0.]\n\n  // argmin along axis 1\n  argmin(x, axis=1) = [ 0.,  0.]\n\n  // argmin along axis 1 keeping same dims as an input array\n  argmin(x, axis=1, keepdims=True) = [[ 0.],\n                                      [ 0.]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\broadcast_reduce_op_index.cc:L77",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      },
      {
        "Name": "axis",
        "TypeInfo": "int or None, optional, default='None'",
        "Description": "The axis along which to perform the reduction. Negative values means indexing from right to left. ``Requires axis to be set as int, because global reduction is not supported yet.``"
      },
      {
        "Name": "keepdims",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If this is set to `True`, the reduced axis is left in the result as dimension with size one."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "argmax_channel",
    "Description": "Returns argmax indices of each channel from the input array.\n\nThe result will be an NDArray of shape (num_channel,).\n\nIn case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence\nare returned.\n\nExamples::\n\n  x = [[ 0.,  1.,  2.],\n       [ 3.,  4.,  5.]]\n\n  argmax_channel(x) = [ 2.,  2.]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\broadcast_reduce_op_index.cc:L97",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "pick",
    "Description": "Picks elements from an input array according to the input indices along the given axis.\n\nGiven an input array of shape ``(d0, d1)`` and indices of shape ``(i0,)``, the result will be\nan output array of shape ``(i0,)`` with::\n\n  output[i] = input[i, indices[i]]\n\nBy default, if any index mentioned is too large, it is replaced by the index that addresses\nthe last element along an axis (the `clip` mode).\n\nThis function supports n-dimensional input and (n-1)-dimensional indices arrays.\n\nExamples::\n\n  x = [[ 1.,  2.],\n       [ 3.,  4.],\n       [ 5.,  6.]]\n\n  // picks elements with specified indices along axis 0\n  pick(x, y=[0,1], 0) = [ 1.,  4.]\n\n  // picks elements with specified indices along axis 1\n  pick(x, y=[0,1,0], 1) = [ 1.,  4.,  5.]\n\n  y = [[ 1.],\n       [ 0.],\n       [ 2.]]\n\n  // picks elements with specified indices along axis 1 using 'wrap' mode\n  // to place indicies that would normally be out of bounds\n  pick(x, y=[2,-1,-2], 1, mode='wrap') = [ 1.,  4.,  5.]\n\n  y = [[ 1.],\n       [ 0.],\n       [ 2.]]\n\n  // picks elements with specified indices along axis 1 and dims are maintained\n  pick(x,y, 1, keepdims=True) = [[ 2.],\n                                 [ 3.],\n                                 [ 6.]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\broadcast_reduce_op_index.cc:L154",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array"
      },
      {
        "Name": "index",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The index array"
      },
      {
        "Name": "axis",
        "TypeInfo": "int or None, optional, default='-1'",
        "Description": "int or None. The axis to picking the elements. Negative values means indexing from right to left. If is `None`, the elements in the index w.r.t the flattened input will be picked."
      },
      {
        "Name": "keepdims",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If true, the axis where we pick the elements is left in the result as dimension with size one."
      },
      {
        "Name": "mode",
        "TypeInfo": "{'clip', 'wrap'},optional, default='clip'",
        "Description": "Specify how out-of-bound indices behave. Default is \"clip\". \"clip\" means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis.  \"wrap\" means to wrap around."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_pick",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "sum",
    "Description": "Computes the sum of array elements over given axes.\n\n.. Note::\n\n  `sum` and `sum_axis` are equivalent.\n  For ndarray of csr storage type summation along axis 0 and axis 1 is supported.\n  Setting keepdims or exclude to True will cause a fallback to dense operator.\n\nExample::\n\n  data = [[[1, 2], [2, 3], [1, 3]],\n          [[1, 4], [4, 3], [5, 2]],\n          [[7, 1], [7, 2], [7, 3]]]\n\n  sum(data, axis=1)\n  [[  4.   8.]\n   [ 10.   9.]\n   [ 21.   6.]]\n\n  sum(data, axis=[1,2])\n  [ 12.  19.  27.]\n\n  data = [[1, 2, 0],\n          [3, 0, 1],\n          [4, 1, 0]]\n\n  csr = cast_storage(data, 'csr')\n\n  sum(csr, axis=0)\n  [ 8.  3.  1.]\n\n  sum(csr, axis=1)\n  [ 3.  4.  5.]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\broadcast_reduce_op_value.cc:L116",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      },
      {
        "Name": "axis",
        "TypeInfo": "Shape or None, optional, default=None",
        "Description": "The axis or axes along which to perform the reduction.\n\n      The default, `axis=()`, will compute over all elements into a\n      scalar array with shape `(1,)`.\n\n      If `axis` is int, a reduction is performed on a particular axis.\n\n      If `axis` is a tuple of ints, a reduction is performed on all the axes\n      specified in the tuple.\n\n      If `exclude` is true, reduction will be performed on the axes that are\n      NOT in axis instead.\n\n      Negative values means indexing from right to left."
      },
      {
        "Name": "keepdims",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If this is set to `True`, the reduced axes are left in the result as dimension with size one."
      },
      {
        "Name": "exclude",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether to perform reduction on axis that are NOT in axis instead."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_sum",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "mean",
    "Description": "Computes the mean of array elements over given axes.\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\broadcast_reduce_op_value.cc:L132",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      },
      {
        "Name": "axis",
        "TypeInfo": "Shape or None, optional, default=None",
        "Description": "The axis or axes along which to perform the reduction.\n\n      The default, `axis=()`, will compute over all elements into a\n      scalar array with shape `(1,)`.\n\n      If `axis` is int, a reduction is performed on a particular axis.\n\n      If `axis` is a tuple of ints, a reduction is performed on all the axes\n      specified in the tuple.\n\n      If `exclude` is true, reduction will be performed on the axes that are\n      NOT in axis instead.\n\n      Negative values means indexing from right to left."
      },
      {
        "Name": "keepdims",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If this is set to `True`, the reduced axes are left in the result as dimension with size one."
      },
      {
        "Name": "exclude",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether to perform reduction on axis that are NOT in axis instead."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_mean",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "prod",
    "Description": "Computes the product of array elements over given axes.\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\broadcast_reduce_op_value.cc:L147",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      },
      {
        "Name": "axis",
        "TypeInfo": "Shape or None, optional, default=None",
        "Description": "The axis or axes along which to perform the reduction.\n\n      The default, `axis=()`, will compute over all elements into a\n      scalar array with shape `(1,)`.\n\n      If `axis` is int, a reduction is performed on a particular axis.\n\n      If `axis` is a tuple of ints, a reduction is performed on all the axes\n      specified in the tuple.\n\n      If `exclude` is true, reduction will be performed on the axes that are\n      NOT in axis instead.\n\n      Negative values means indexing from right to left."
      },
      {
        "Name": "keepdims",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If this is set to `True`, the reduced axes are left in the result as dimension with size one."
      },
      {
        "Name": "exclude",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether to perform reduction on axis that are NOT in axis instead."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_prod",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "nansum",
    "Description": "Computes the sum of array elements over given axes treating Not a Numbers (``NaN``) as zero.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\broadcast_reduce_op_value.cc:L162",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      },
      {
        "Name": "axis",
        "TypeInfo": "Shape or None, optional, default=None",
        "Description": "The axis or axes along which to perform the reduction.\n\n      The default, `axis=()`, will compute over all elements into a\n      scalar array with shape `(1,)`.\n\n      If `axis` is int, a reduction is performed on a particular axis.\n\n      If `axis` is a tuple of ints, a reduction is performed on all the axes\n      specified in the tuple.\n\n      If `exclude` is true, reduction will be performed on the axes that are\n      NOT in axis instead.\n\n      Negative values means indexing from right to left."
      },
      {
        "Name": "keepdims",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If this is set to `True`, the reduced axes are left in the result as dimension with size one."
      },
      {
        "Name": "exclude",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether to perform reduction on axis that are NOT in axis instead."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_nansum",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "nanprod",
    "Description": "Computes the product of array elements over given axes treating Not a Numbers (``NaN``) as one.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\broadcast_reduce_op_value.cc:L177",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      },
      {
        "Name": "axis",
        "TypeInfo": "Shape or None, optional, default=None",
        "Description": "The axis or axes along which to perform the reduction.\n\n      The default, `axis=()`, will compute over all elements into a\n      scalar array with shape `(1,)`.\n\n      If `axis` is int, a reduction is performed on a particular axis.\n\n      If `axis` is a tuple of ints, a reduction is performed on all the axes\n      specified in the tuple.\n\n      If `exclude` is true, reduction will be performed on the axes that are\n      NOT in axis instead.\n\n      Negative values means indexing from right to left."
      },
      {
        "Name": "keepdims",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If this is set to `True`, the reduced axes are left in the result as dimension with size one."
      },
      {
        "Name": "exclude",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether to perform reduction on axis that are NOT in axis instead."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_nanprod",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "max",
    "Description": "Computes the max of array elements over given axes.\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\broadcast_reduce_op_value.cc:L191",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      },
      {
        "Name": "axis",
        "TypeInfo": "Shape or None, optional, default=None",
        "Description": "The axis or axes along which to perform the reduction.\n\n      The default, `axis=()`, will compute over all elements into a\n      scalar array with shape `(1,)`.\n\n      If `axis` is int, a reduction is performed on a particular axis.\n\n      If `axis` is a tuple of ints, a reduction is performed on all the axes\n      specified in the tuple.\n\n      If `exclude` is true, reduction will be performed on the axes that are\n      NOT in axis instead.\n\n      Negative values means indexing from right to left."
      },
      {
        "Name": "keepdims",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If this is set to `True`, the reduced axes are left in the result as dimension with size one."
      },
      {
        "Name": "exclude",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether to perform reduction on axis that are NOT in axis instead."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_max",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "min",
    "Description": "Computes the min of array elements over given axes.\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\broadcast_reduce_op_value.cc:L205",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      },
      {
        "Name": "axis",
        "TypeInfo": "Shape or None, optional, default=None",
        "Description": "The axis or axes along which to perform the reduction.\n\n      The default, `axis=()`, will compute over all elements into a\n      scalar array with shape `(1,)`.\n\n      If `axis` is int, a reduction is performed on a particular axis.\n\n      If `axis` is a tuple of ints, a reduction is performed on all the axes\n      specified in the tuple.\n\n      If `exclude` is true, reduction will be performed on the axes that are\n      NOT in axis instead.\n\n      Negative values means indexing from right to left."
      },
      {
        "Name": "keepdims",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If this is set to `True`, the reduced axes are left in the result as dimension with size one."
      },
      {
        "Name": "exclude",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether to perform reduction on axis that are NOT in axis instead."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_min",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "broadcast_axis",
    "Description": "Broadcasts the input array over particular axes.\n\nBroadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to\n`(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.\n\nExample::\n\n   // given x of shape (1,2,1)\n   x = [[[ 1.],\n         [ 2.]]]\n\n   // broadcast x on on axis 2\n   broadcast_axis(x, axis=2, size=3) = [[[ 1.,  1.,  1.],\n                                         [ 2.,  2.,  2.]]]\n   // broadcast x on on axes 0 and 2\n   broadcast_axis(x, axis=(0,2), size=(2,3)) = [[[ 1.,  1.,  1.],\n                                                 [ 2.,  2.,  2.]],\n                                                [[ 1.,  1.,  1.],\n                                                 [ 2.,  2.,  2.]]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\broadcast_reduce_op_value.cc:L238",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      },
      {
        "Name": "axis",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "The axes to perform the broadcasting."
      },
      {
        "Name": "size",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "Target sizes of the broadcasting axes."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "broadcast_to",
    "Description": "Broadcasts the input array to a new shape.\n\nBroadcasting is a mechanism that allows NDArrays to perform arithmetic operations\nwith arrays of different shapes efficiently without creating multiple copies of arrays.\nAlso see, `Broadcasting <https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html>`_ for more explanation.\n\nBroadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to\n`(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.\n\nFor example::\n\n   broadcast_to([[1,2,3]], shape=(2,3)) = [[ 1.,  2.,  3.],\n                                           [ 1.,  2.,  3.]])\n\nThe dimension which you do not want to change can also be kept as `0` which means copy the original value.\nSo with `shape=(2,0)`, we will obtain the same result as in the above example.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\broadcast_reduce_op_value.cc:L262",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "The shape of the desired array. We can set the dim to zero if it's same as the original. E.g `A = broadcast_to(B, shape=(10, 0, 0))` has the same meaning as `A = broadcast_axis(B, axis=0, size=10)`."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_broadcast_backward",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "broadcast_like",
    "Description": "Broadcasts lhs to have the same shape as rhs.\n\nBroadcasting is a mechanism that allows NDArrays to perform arithmetic operations\nwith arrays of different shapes efficiently without creating multiple copies of arrays.\nAlso see, `Broadcasting <https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html>`_ for more explanation.\n\nBroadcasting is allowed on axes with size 1, such as from `(2,1,3,1)` to\n`(2,8,3,9)`. Elements will be duplicated on the broadcasted axes.\n\nFor example::\n\n   broadcast_like([[1,2,3]], [[5,6,7],[7,8,9]]) = [[ 1.,  2.,  3.],\n                                                   [ 1.,  2.,  3.]])\n\n   broadcast_like([9], [1,2,3,4,5], lhs_axes=(0,), rhs_axes=(-1,)) = [9,9,9,9,9]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\broadcast_reduce_op_value.cc:L315",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "First input."
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Second input."
      },
      {
        "Name": "lhs_axes",
        "TypeInfo": "Shape or None, optional, default=None",
        "Description": "Axes to perform broadcast on in the first input array"
      },
      {
        "Name": "rhs_axes",
        "TypeInfo": "Shape or None, optional, default=None",
        "Description": "Axes to copy from the second input array"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "norm",
    "Description": "Computes the norm on an NDArray.\n\nThis operator computes the norm on an NDArray with the specified axis, depending\non the value of the ord parameter. By default, it computes the L2 norm on the entire\narray. Currently only ord=2 supports sparse ndarrays.\n\nExamples::\n\n  x = [[[1, 2],\n        [3, 4]],\n       [[2, 2],\n        [5, 6]]]\n\n  norm(x, ord=2, axis=1) = [[3.1622777 4.472136 ]\n                            [5.3851647 6.3245554]]\n\n  norm(x, ord=1, axis=1) = [[4., 6.],\n                            [7., 8.]]\n\n  rsp = x.cast_storage('row_sparse')\n\n  norm(rsp) = [5.47722578]\n\n  csr = x.cast_storage('csr')\n\n  norm(csr) = [5.47722578]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\broadcast_reduce_op_value.cc:L350",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      },
      {
        "Name": "ord",
        "TypeInfo": "int, optional, default='2'",
        "Description": "Order of the norm. Currently ord=1 and ord=2 is supported."
      },
      {
        "Name": "axis",
        "TypeInfo": "Shape or None, optional, default=None",
        "Description": "The axis or axes along which to perform the reduction.\n      The default, `axis=()`, will compute over all elements into a\n      scalar array with shape `(1,)`.\n      If `axis` is int, a reduction is performed on a particular axis.\n      If `axis` is a 2-tuple, it specifies the axes that hold 2-D matrices,\n      and the matrix norms of these matrices are computed."
      },
      {
        "Name": "out_dtype",
        "TypeInfo": "{None, 'float16', 'float32', 'float64', 'int32', 'int64', 'int8'},optional, default='None'",
        "Description": "The data type of the output."
      },
      {
        "Name": "keepdims",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If this is set to `True`, the reduced axis is left in the result as dimension with size one."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_norm",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "cast_storage",
    "Description": "Casts tensor storage type to the new type.\n\nWhen an NDArray with default storage type is cast to csr or row_sparse storage,\nthe result is compact, which means:\n\n- for csr, zero values will not be retained\n- for row_sparse, row slices of all zeros will not be retained\n\nThe storage type of ``cast_storage`` output depends on stype parameter:\n\n- cast_storage(csr, 'default') = default\n- cast_storage(row_sparse, 'default') = default\n- cast_storage(default, 'csr') = csr\n- cast_storage(default, 'row_sparse') = row_sparse\n- cast_storage(csr, 'csr') = csr\n- cast_storage(row_sparse, 'row_sparse') = row_sparse\n\nExample::\n\n    dense = [[ 0.,  1.,  0.],\n             [ 2.,  0.,  3.],\n             [ 0.,  0.,  0.],\n             [ 0.,  0.,  0.]]\n\n    # cast to row_sparse storage type\n    rsp = cast_storage(dense, 'row_sparse')\n    rsp.indices = [0, 1]\n    rsp.values = [[ 0.,  1.,  0.],\n                  [ 2.,  0.,  3.]]\n\n    # cast to csr storage type\n    csr = cast_storage(dense, 'csr')\n    csr.indices = [1, 0, 2]\n    csr.values = [ 1.,  2.,  3.]\n    csr.indptr = [0, 1, 3, 3, 3]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\cast_storage.cc:L71",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input."
      },
      {
        "Name": "stype",
        "TypeInfo": "{'csr', 'default', 'row_sparse'}, required",
        "Description": "Output storage type."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "where",
    "Description": "Return the elements, either from x or y, depending on the condition.\n\nGiven three ndarrays, condition, x, and y, return an ndarray with the elements from x or y,\ndepending on the elements from condition are true or false. x and y must have the same shape.\nIf condition has the same shape as x, each element in the output array is from x if the\ncorresponding element in the condition is true, and from y if false.\n\nIf condition does not have the same shape as x, it must be a 1D array whose size is\nthe same as x's first dimension size. Each row of the output array is from x's row\nif the corresponding element from condition is true, and from y's row if false.\n\nNote that all non-zero values are interpreted as ``True`` in condition.\n\nExamples::\n\n  x = [[1, 2], [3, 4]]\n  y = [[5, 6], [7, 8]]\n  cond = [[0, 1], [-1, 0]]\n\n  where(cond, x, y) = [[5, 2], [3, 8]]\n\n  csr_cond = cast_storage(cond, 'csr')\n\n  where(csr_cond, x, y) = [[5, 2], [3, 8]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\control_flow_op.cc:L57",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "condition",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "condition array"
      },
      {
        "Name": "x",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": ""
      },
      {
        "Name": "y",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": ""
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_where",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "diag",
    "Description": "Extracts a diagonal or constructs a diagonal array.\n\n``diag``'s behavior depends on the input array dimensions:\n\n- 1-D arrays: constructs a 2-D array with the input as its diagonal, all other elements are zero.\n- N-D arrays: extracts the diagonals of the sub-arrays with axes specified by ``axis1`` and ``axis2``.\n  The output shape would be decided by removing the axes numbered ``axis1`` and ``axis2`` from the\n  input shape and appending to the result a new axis with the size of the diagonals in question.\n\n  For example, when the input shape is `(2, 3, 4, 5)`, ``axis1`` and ``axis2`` are 0 and 2\n  respectively and ``k`` is 0, the resulting shape would be `(3, 5, 2)`.\n\nExamples::\n\n  x = [[1, 2, 3],\n       [4, 5, 6]]\n\n  diag(x) = [1, 5]\n\n  diag(x, k=1) = [2, 6]\n\n  diag(x, k=-1) = [4]\n\n  x = [1, 2, 3]\n\n  diag(x) = [[1, 0, 0],\n             [0, 2, 0],\n             [0, 0, 3]]\n\n  diag(x, k=1) = [[0, 1, 0],\n                  [0, 0, 2],\n                  [0, 0, 0]]\n\n  diag(x, k=-1) = [[0, 0, 0],\n                   [1, 0, 0],\n                   [0, 2, 0]]\n\n  x = [[[1, 2],\n        [3, 4]],\n\n       [[5, 6],\n        [7, 8]]]\n\n  diag(x) = [[1, 7],\n             [2, 8]]\n\n  diag(x, k=1) = [[3],\n                  [4]]\n\n  diag(x, axis1=-2, axis2=-1) = [[1, 4],\n                                 [5, 8]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\diag_op.cc:L87",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input ndarray"
      },
      {
        "Name": "k",
        "TypeInfo": "int, optional, default='0'",
        "Description": "Diagonal in question. The default is 0. Use k>0 for diagonals above the main diagonal, and k<0 for diagonals below the main diagonal. If input has shape (S0 S1) k must be between -S0 and S1"
      },
      {
        "Name": "axis1",
        "TypeInfo": "int, optional, default='0'",
        "Description": "The first axis of the sub-arrays of interest. Ignored when the input is a 1-D array."
      },
      {
        "Name": "axis2",
        "TypeInfo": "int, optional, default='1'",
        "Description": "The second axis of the sub-arrays of interest. Ignored when the input is a 1-D array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_diag",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "dot",
    "Description": "Dot product of two arrays.\n\n``dot``'s behavior depends on the input array dimensions:\n\n- 1-D arrays: inner product of vectors\n- 2-D arrays: matrix multiplication\n- N-D arrays: a sum product over the last axis of the first input and the first\n  axis of the second input\n\n  For example, given 3-D ``x`` with shape `(n,m,k)` and ``y`` with shape `(k,r,s)`, the\n  result array will have shape `(n,m,r,s)`. It is computed by::\n\n    dot(x,y)[i,j,a,b] = sum(x[i,j,:]*y[:,a,b])\n\n  Example::\n\n    x = reshape([0,1,2,3,4,5,6,7], shape=(2,2,2))\n    y = reshape([7,6,5,4,3,2,1,0], shape=(2,2,2))\n    dot(x,y)[0,0,1,1] = 0\n    sum(x[0,0,:]*y[:,1,1]) = 0\n\nThe storage type of ``dot`` output depends on storage types of inputs, transpose option and\nforward_stype option for output storage type. Implemented sparse operations include:\n\n- dot(default, default, transpose_a=True/False, transpose_b=True/False) = default\n- dot(csr, default, transpose_a=True) = default\n- dot(csr, default, transpose_a=True) = row_sparse\n- dot(csr, default) = default\n- dot(csr, row_sparse) = default\n- dot(default, csr) = csr (CPU only)\n- dot(default, csr, forward_stype='default') = default\n- dot(default, csr, transpose_b=True, forward_stype='default') = default\n\nIf the combination of input storage types and forward_stype does not match any of the\nabove patterns, ``dot`` will fallback and generate output with default storage.\n\n.. Note::\n\n    If the storage type of the lhs is \"csr\", the storage type of gradient w.r.t rhs will be\n    \"row_sparse\". Only a subset of optimizers support sparse gradients, including SGD, AdaGrad\n    and Adam. Note that by default lazy updates is turned on, which may perform differently\n    from standard updates. For more details, please check the Optimization API at:\n    https://mxnet.incubator.apache.org/api/python/optimization/optimization.html\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\dot.cc:L77",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The second input"
      },
      {
        "Name": "transpose_a",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If true then transpose the first input before dot."
      },
      {
        "Name": "transpose_b",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If true then transpose the second input before dot."
      },
      {
        "Name": "forward_stype",
        "TypeInfo": "{None, 'csr', 'default', 'row_sparse'},optional, default='None'",
        "Description": "The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_dot",
    "Description": "",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "transpose_a",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If true then transpose the first input before dot."
      },
      {
        "Name": "transpose_b",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If true then transpose the second input before dot."
      },
      {
        "Name": "forward_stype",
        "TypeInfo": "{None, 'csr', 'default', 'row_sparse'},optional, default='None'",
        "Description": "The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "batch_dot",
    "Description": "Batchwise dot product.\n\n``batch_dot`` is used to compute dot product of ``x`` and ``y`` when ``x`` and\n``y`` are data in batch, namely 3D arrays in shape of `(batch_size, :, :)`.\n\nFor example, given ``x`` with shape `(batch_size, n, m)` and ``y`` with shape\n`(batch_size, m, k)`, the result array will have shape `(batch_size, n, k)`,\nwhich is computed by::\n\n   batch_dot(x,y)[i,:,:] = dot(x[i,:,:], y[i,:,:])\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\dot.cc:L125",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The second input"
      },
      {
        "Name": "transpose_a",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If true then transpose the first input before dot."
      },
      {
        "Name": "transpose_b",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If true then transpose the second input before dot."
      },
      {
        "Name": "forward_stype",
        "TypeInfo": "{None, 'csr', 'default', 'row_sparse'},optional, default='None'",
        "Description": "The desired storage type of the forward output given by user, if thecombination of input storage types and this hint does not matchany implemented ones, the dot operator will perform fallback operationand still produce an output of the desired storage type."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_batch_dot",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "broadcast_add",
    "Description": "Returns element-wise sum of the input arrays with broadcasting.\n\n`broadcast_plus` is an alias to the function `broadcast_add`.\n\nExample::\n\n   x = [[ 1.,  1.,  1.],\n        [ 1.,  1.,  1.]]\n\n   y = [[ 0.],\n        [ 1.]]\n\n   broadcast_add(x, y) = [[ 1.,  1.,  1.],\n                          [ 2.,  2.,  2.]]\n\n   broadcast_plus(x, y) = [[ 1.,  1.,  1.],\n                           [ 2.,  2.,  2.]]\n\nSupported sparse operations:\n\n   broadcast_add(csr, dense(1D)) = dense\n   broadcast_add(dense(1D), csr) = dense\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_binary_broadcast_op_basic.cc:L58",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "First input to the function"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Second input to the function"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_broadcast_add",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "broadcast_sub",
    "Description": "Returns element-wise difference of the input arrays with broadcasting.\n\n`broadcast_minus` is an alias to the function `broadcast_sub`.\n\nExample::\n\n   x = [[ 1.,  1.,  1.],\n        [ 1.,  1.,  1.]]\n\n   y = [[ 0.],\n        [ 1.]]\n\n   broadcast_sub(x, y) = [[ 1.,  1.,  1.],\n                          [ 0.,  0.,  0.]]\n\n   broadcast_minus(x, y) = [[ 1.,  1.,  1.],\n                            [ 0.,  0.,  0.]]\n\nSupported sparse operations:\n\n   broadcast_sub/minus(csr, dense(1D)) = dense\n   broadcast_sub/minus(dense(1D), csr) = dense\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_binary_broadcast_op_basic.cc:L106",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "First input to the function"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Second input to the function"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_broadcast_sub",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "broadcast_mul",
    "Description": "Returns element-wise product of the input arrays with broadcasting.\n\nExample::\n\n   x = [[ 1.,  1.,  1.],\n        [ 1.,  1.,  1.]]\n\n   y = [[ 0.],\n        [ 1.]]\n\n   broadcast_mul(x, y) = [[ 0.,  0.,  0.],\n                          [ 1.,  1.,  1.]]\n\nSupported sparse operations:\n\n   broadcast_mul(csr, dense(1D)) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_binary_broadcast_op_basic.cc:L146",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "First input to the function"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Second input to the function"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_broadcast_mul",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "broadcast_div",
    "Description": "Returns element-wise division of the input arrays with broadcasting.\n\nExample::\n\n   x = [[ 6.,  6.,  6.],\n        [ 6.,  6.,  6.]]\n\n   y = [[ 2.],\n        [ 3.]]\n\n   broadcast_div(x, y) = [[ 3.,  3.,  3.],\n                          [ 2.,  2.,  2.]]\n\nSupported sparse operations:\n\n   broadcast_div(csr, dense(1D)) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_binary_broadcast_op_basic.cc:L187",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "First input to the function"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Second input to the function"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_broadcast_div",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "broadcast_mod",
    "Description": "Returns element-wise modulo of the input arrays with broadcasting.\n\nExample::\n\n   x = [[ 8.,  8.,  8.],\n        [ 8.,  8.,  8.]]\n\n   y = [[ 2.],\n        [ 3.]]\n\n   broadcast_mod(x, y) = [[ 0.,  0.,  0.],\n                          [ 2.,  2.,  2.]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_binary_broadcast_op_basic.cc:L222",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "First input to the function"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Second input to the function"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_broadcast_mod",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "broadcast_power",
    "Description": "Returns result of first array elements raised to powers from second array, element-wise with broadcasting.\n\nExample::\n\n   x = [[ 1.,  1.,  1.],\n        [ 1.,  1.,  1.]]\n\n   y = [[ 0.],\n        [ 1.]]\n\n   broadcast_power(x, y) = [[ 2.,  2.,  2.],\n                            [ 4.,  4.,  4.]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_binary_broadcast_op_extended.cc:L45",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "First input to the function"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Second input to the function"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_broadcast_power",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "broadcast_maximum",
    "Description": "Returns element-wise maximum of the input arrays with broadcasting.\n\nThis function compares two input arrays and returns a new array having the element-wise maxima.\n\nExample::\n\n   x = [[ 1.,  1.,  1.],\n        [ 1.,  1.,  1.]]\n\n   y = [[ 0.],\n        [ 1.]]\n\n   broadcast_maximum(x, y) = [[ 1.,  1.,  1.],\n                              [ 1.,  1.,  1.]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_binary_broadcast_op_extended.cc:L80",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "First input to the function"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Second input to the function"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_broadcast_maximum",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "broadcast_minimum",
    "Description": "Returns element-wise minimum of the input arrays with broadcasting.\n\nThis function compares two input arrays and returns a new array having the element-wise minima.\n\nExample::\n\n   x = [[ 1.,  1.,  1.],\n        [ 1.,  1.,  1.]]\n\n   y = [[ 0.],\n        [ 1.]]\n\n   broadcast_maximum(x, y) = [[ 0.,  0.,  0.],\n                              [ 1.,  1.,  1.]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_binary_broadcast_op_extended.cc:L115",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "First input to the function"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Second input to the function"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_broadcast_minimum",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "broadcast_hypot",
    "Description": " Returns the hypotenuse of a right angled triangle, given its \"legs\"\nwith broadcasting.\n\nIt is equivalent to doing :math:`sqrt(x_1^2 + x_2^2)`.\n\nExample::\n\n   x = [[ 3.,  3.,  3.]]\n\n   y = [[ 4.],\n        [ 4.]]\n\n   broadcast_hypot(x, y) = [[ 5.,  5.,  5.],\n                            [ 5.,  5.,  5.]]\n\n   z = [[ 0.],\n        [ 4.]]\n\n   broadcast_hypot(x, z) = [[ 3.,  3.,  3.],\n                            [ 5.,  5.,  5.]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_binary_broadcast_op_extended.cc:L156",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "First input to the function"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Second input to the function"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_broadcast_hypot",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "broadcast_equal",
    "Description": "Returns the result of element-wise **equal to** (==) comparison operation with broadcasting.\n\nExample::\n\n   x = [[ 1.,  1.,  1.],\n        [ 1.,  1.,  1.]]\n\n   y = [[ 0.],\n        [ 1.]]\n\n   broadcast_equal(x, y) = [[ 0.,  0.,  0.],\n                            [ 1.,  1.,  1.]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_binary_broadcast_op_logic.cc:L46",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "First input to the function"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Second input to the function"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "broadcast_not_equal",
    "Description": "Returns the result of element-wise **not equal to** (!=) comparison operation with broadcasting.\n\nExample::\n\n   x = [[ 1.,  1.,  1.],\n        [ 1.,  1.,  1.]]\n\n   y = [[ 0.],\n        [ 1.]]\n\n   broadcast_not_equal(x, y) = [[ 1.,  1.,  1.],\n                                [ 0.,  0.,  0.]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_binary_broadcast_op_logic.cc:L64",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "First input to the function"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Second input to the function"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "broadcast_greater",
    "Description": "Returns the result of element-wise **greater than** (>) comparison operation with broadcasting.\n\nExample::\n\n   x = [[ 1.,  1.,  1.],\n        [ 1.,  1.,  1.]]\n\n   y = [[ 0.],\n        [ 1.]]\n\n   broadcast_greater(x, y) = [[ 1.,  1.,  1.],\n                              [ 0.,  0.,  0.]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_binary_broadcast_op_logic.cc:L82",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "First input to the function"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Second input to the function"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "broadcast_greater_equal",
    "Description": "Returns the result of element-wise **greater than or equal to** (>=) comparison operation with broadcasting.\n\nExample::\n\n   x = [[ 1.,  1.,  1.],\n        [ 1.,  1.,  1.]]\n\n   y = [[ 0.],\n        [ 1.]]\n\n   broadcast_greater_equal(x, y) = [[ 1.,  1.,  1.],\n                                    [ 1.,  1.,  1.]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_binary_broadcast_op_logic.cc:L100",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "First input to the function"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Second input to the function"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "broadcast_lesser",
    "Description": "Returns the result of element-wise **lesser than** (<) comparison operation with broadcasting.\n\nExample::\n\n   x = [[ 1.,  1.,  1.],\n        [ 1.,  1.,  1.]]\n\n   y = [[ 0.],\n        [ 1.]]\n\n   broadcast_lesser(x, y) = [[ 0.,  0.,  0.],\n                             [ 0.,  0.,  0.]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_binary_broadcast_op_logic.cc:L118",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "First input to the function"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Second input to the function"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "broadcast_lesser_equal",
    "Description": "Returns the result of element-wise **lesser than or equal to** (<=) comparison operation with broadcasting.\n\nExample::\n\n   x = [[ 1.,  1.,  1.],\n        [ 1.,  1.,  1.]]\n\n   y = [[ 0.],\n        [ 1.]]\n\n   broadcast_lesser_equal(x, y) = [[ 0.,  0.,  0.],\n                                   [ 1.,  1.,  1.]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_binary_broadcast_op_logic.cc:L136",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "First input to the function"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Second input to the function"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "broadcast_logical_and",
    "Description": "Returns the result of element-wise **logical and** with broadcasting.\n\nExample::\n\n   x = [[ 1.,  1.,  1.],\n        [ 1.,  1.,  1.]]\n\n   y = [[ 0.],\n        [ 1.]]\n\n   broadcast_logical_and(x, y) = [[ 0.,  0.,  0.],\n                                  [ 1.,  1.,  1.]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_binary_broadcast_op_logic.cc:L154",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "First input to the function"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Second input to the function"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "broadcast_logical_or",
    "Description": "Returns the result of element-wise **logical or** with broadcasting.\n\nExample::\n\n   x = [[ 1.,  1.,  0.],\n        [ 1.,  1.,  0.]]\n\n   y = [[ 1.],\n        [ 0.]]\n\n   broadcast_logical_or(x, y) = [[ 1.,  1.,  1.],\n                                 [ 1.,  1.,  0.]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_binary_broadcast_op_logic.cc:L172",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "First input to the function"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Second input to the function"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "broadcast_logical_xor",
    "Description": "Returns the result of element-wise **logical xor** with broadcasting.\n\nExample::\n\n   x = [[ 1.,  1.,  0.],\n        [ 1.,  1.,  0.]]\n\n   y = [[ 1.],\n        [ 0.]]\n\n   broadcast_logical_xor(x, y) = [[ 0.,  0.,  1.],\n                                  [ 1.,  1.,  0.]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_binary_broadcast_op_logic.cc:L190",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "First input to the function"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Second input to the function"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "elemwise_add",
    "Description": "Adds arguments element-wise.\n\nThe storage type of ``elemwise_add`` output depends on storage types of inputs\n\n   - elemwise_add(row_sparse, row_sparse) = row_sparse\n   - elemwise_add(csr, csr) = csr\n   - elemwise_add(default, csr) = default\n   - elemwise_add(csr, default) = default\n   - elemwise_add(default, rsp) = default\n   - elemwise_add(rsp, default) = default\n   - otherwise, ``elemwise_add`` generates output with default storage\n\n",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_grad_add",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_add",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "elemwise_sub",
    "Description": "Subtracts arguments element-wise.\n\nThe storage type of ``elemwise_sub`` output depends on storage types of inputs\n\n   - elemwise_sub(row_sparse, row_sparse) = row_sparse\n   - elemwise_sub(csr, csr) = csr\n   - elemwise_sub(default, csr) = default\n   - elemwise_sub(csr, default) = default\n   - elemwise_sub(default, rsp) = default\n   - elemwise_sub(rsp, default) = default\n   - otherwise, ``elemwise_sub`` generates output with default storage\n\n",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_sub",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "elemwise_mul",
    "Description": "Multiplies arguments element-wise.\n\nThe storage type of ``elemwise_mul`` output depends on storage types of inputs\n\n   - elemwise_mul(default, default) = default\n   - elemwise_mul(row_sparse, row_sparse) = row_sparse\n   - elemwise_mul(default, row_sparse) = row_sparse\n   - elemwise_mul(row_sparse, default) = row_sparse\n   - elemwise_mul(csr, csr) = csr\n   - otherwise, ``elemwise_mul`` generates output with default storage\n\n",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_mul",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "elemwise_div",
    "Description": "Divides arguments element-wise.\n\nThe storage type of ``elemwise_div`` output is always dense\n\n",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_div",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_mod",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_mod",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_power",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_power",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_maximum",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_maximum",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_minimum",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_minimum",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_hypot",
    "Description": "Given the \"legs\" of a right triangle, return its hypotenuse.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_binary_op_extended.cc:L79",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_hypot",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_equal",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_not_equal",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_greater",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_greater_equal",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_lesser",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_lesser_equal",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_logical_and",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_logical_or",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_logical_xor",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_plus_scalar",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_minus_scalar",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_rminus_scalar",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_mul_scalar",
    "Description": "Multiply an array with a scalar.\n\n``_mul_scalar`` only operates on data array of input if input is sparse.\n\nFor example, if input of shape (100, 100) has only 2 non zero elements,\ni.e. input.data = [5, 6], scalar = nan,\nit will result output.data = [nan, nan] instead of 10000 nans.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_binary_scalar_op_basic.cc:L149",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_mul_scalar",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_div_scalar",
    "Description": "Divide an array with a scalar.\n\n``_div_scalar`` only operates on data array of input if input is sparse.\n\nFor example, if input of shape (100, 100) has only 2 non zero elements,\ni.e. input.data = [5, 6], scalar = nan,\nit will result output.data = [nan, nan] instead of 10000 nans.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_binary_scalar_op_basic.cc:L171",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_div_scalar",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_rdiv_scalar",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_rdiv_scalar",
    "Description": "",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar value"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_mod_scalar",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_mod_scalar",
    "Description": "",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar value"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_rmod_scalar",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_rmod_scalar",
    "Description": "",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar value"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_maximum_scalar",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_maximum_scalar",
    "Description": "",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar value"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_minimum_scalar",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_minimum_scalar",
    "Description": "",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar value"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_power_scalar",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_power_scalar",
    "Description": "",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar value"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_rpower_scalar",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_rpower_scalar",
    "Description": "",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar value"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_hypot_scalar",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_hypot_scalar",
    "Description": "",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar value"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "smooth_l1",
    "Description": "Calculate Smooth L1 Loss(lhs, scalar) by summing\n\n.. math::\n\n    f(x) =\n    \\begin{cases}\n    (\\sigma x)^2/2,& \\text{if }x < 1/\\sigma^2\\\\\n    |x|-0.5/\\sigma^2,& \\text{otherwise}\n    \\end{cases}\n\nwhere :math:`x` is an element of the tensor *lhs* and :math:`\\sigma` is the scalar.\n\nExample::\n\n  smooth_l1([1, 2, 3, 4]) = [0.5, 1.5, 2.5, 3.5]\n  smooth_l1([1, 2, 3, 4], scalar=1) = [0.5, 1.5, 2.5, 3.5]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_binary_scalar_op_extended.cc:L104",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_smooth_l1",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_equal_scalar",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_not_equal_scalar",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_greater_scalar",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_greater_equal_scalar",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_lesser_scalar",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_lesser_equal_scalar",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_logical_and_scalar",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_logical_or_scalar",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_logical_xor_scalar",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_scatter_elemwise_div",
    "Description": "Divides arguments element-wise.  If the left-hand-side input is 'row_sparse', then\nonly the values which exist in the left-hand sparse array are computed.  The 'missing' values\nare ignored.\n\nThe storage type of ``_scatter_elemwise_div`` output depends on storage types of inputs\n\n- _scatter_elemwise_div(row_sparse, row_sparse) = row_sparse\n- _scatter_elemwise_div(row_sparse, dense) = row_sparse\n- _scatter_elemwise_div(row_sparse, csr) = row_sparse\n- otherwise, ``_scatter_elemwise_div`` behaves exactly like elemwise_div and generates output\nwith default storage\n\n",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_scatter_plus_scalar",
    "Description": "Adds a scalar to a tensor element-wise.  If the left-hand-side input is\n'row_sparse' or 'csr', then only the values which exist in the left-hand sparse array are computed.\nThe 'missing' values are ignored.\n\nThe storage type of ``_scatter_plus_scalar`` output depends on storage types of inputs\n\n- _scatter_plus_scalar(row_sparse, scalar) = row_sparse\n- _scatter_plus_scalar(csr, scalar) = csr\n- otherwise, ``_scatter_plus_scalar`` behaves exactly like _plus_scalar and generates output\nwith default storage\n\n",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_scatter_minus_scalar",
    "Description": "Subtracts a scalar to a tensor element-wise.  If the left-hand-side input is\n'row_sparse' or 'csr', then only the values which exist in the left-hand sparse array are computed.\nThe 'missing' values are ignored.\n\nThe storage type of ``_scatter_minus_scalar`` output depends on storage types of inputs\n\n- _scatter_minus_scalar(row_sparse, scalar) = row_sparse\n- _scatter_minus_scalar(csr, scalar) = csr\n- otherwise, ``_scatter_minus_scalar`` behaves exactly like _minus_scalar and generates output\nwith default storage\n\n",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "float",
        "Description": "scalar input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "add_n",
    "Description": "Adds all input arguments element-wise.\n\n.. math::\n   add\\_n(a_1, a_2, ..., a_n) = a_1 + a_2 + ... + a_n\n\n``add_n`` is potentially more efficient than calling ``add`` by `n` times.\n\nThe storage type of ``add_n`` output depends on storage types of inputs\n\n- add_n(row_sparse, row_sparse, ..) = row_sparse\n- add_n(default, csr, default) = default\n- add_n(any input combinations longer than 4 (>4) with at least one default type) = default\n- otherwise, ``add_n`` falls all inputs back to default storage and generates default storage\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_sum.cc:L155",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "args",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "Positional input arguments"
      }
    ],
    "KeyVarNumArgs": "num_args",
    "ReturnType": null
  },
  {
    "Name": "relu",
    "Description": "Computes rectified linear activation.\n\n.. math::\n   max(features, 0)\n\nThe storage type of ``relu`` output depends upon the input storage type:\n\n   - relu(default) = default\n   - relu(row_sparse) = row_sparse\n   - relu(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L85",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_relu",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "sigmoid",
    "Description": "Computes sigmoid of x element-wise.\n\n.. math::\n   y = 1 / (1 + exp(-x))\n\nThe storage type of ``sigmoid`` output is always dense\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L119",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_sigmoid",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "hard_sigmoid",
    "Description": "Computes hard sigmoid of x element-wise.\n\n.. math::\n   y = max(0, min(1, alpha * x + beta))\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L133",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      },
      {
        "Name": "alpha",
        "TypeInfo": "float, optional, default=0.200000003",
        "Description": "Slope of hard sigmoid"
      },
      {
        "Name": "beta",
        "TypeInfo": "float, optional, default=0.5",
        "Description": "Bias of hard sigmoid."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_hard_sigmoid",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "softsign",
    "Description": "Computes softsign of x element-wise.\n\n.. math::\n   y = x / (1 + abs(x))\n\nThe storage type of ``softsign`` output is always dense\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L163",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_softsign",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_copy",
    "Description": "Returns a copy of the input.\n\nFrom:C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:218",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_copy",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_reshape",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "BlockGrad",
    "Description": "Stops gradient computation.\n\nStops the accumulated gradient of the inputs from flowing through this operator\nin the backward direction. In other words, this operator prevents the contribution\nof its inputs to be taken into account for computing gradients.\n\nExample::\n\n  v1 = [1, 2]\n  v2 = [0, 1]\n  a = Variable('a')\n  b = Variable('b')\n  b_stop_grad = stop_gradient(3 * b)\n  loss = MakeLoss(b_stop_grad + a)\n\n  executor = loss.simple_bind(ctx=cpu(), a=(1,2), b=(1,2))\n  executor.forward(is_train=True, a=v1, b=v2)\n  executor.outputs\n  [ 1.  5.]\n\n  executor.backward()\n  executor.grad_arrays\n  [ 0.  0.]\n  [ 1.  1.]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L299",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "make_loss",
    "Description": "Make your own loss function in network construction.\n\nThis operator accepts a customized loss function symbol as a terminal loss and\nthe symbol should be an operator with no backward dependency.\nThe output of this function is the gradient of loss with respect to the input data.\n\nFor example, if you are a making a cross entropy loss function. Assume ``out`` is the\npredicted output and ``label`` is the true label, then the cross entropy can be defined as::\n\n  cross_entropy = label * log(out) + (1 - label) * log(1 - out)\n  loss = make_loss(cross_entropy)\n\nWe will need to use ``make_loss`` when we are creating our own loss function or we want to\ncombine multiple loss functions. Also we may want to stop some variables' gradients\nfrom backpropagation. See more detail in ``BlockGrad`` or ``stop_gradient``.\n\nThe storage type of ``make_loss`` output depends upon the input storage type:\n\n   - make_loss(default) = default\n   - make_loss(row_sparse) = row_sparse\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L332",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_identity_with_attr_like_rhs",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "First input."
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Second input."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "reshape_like",
    "Description": "Reshape some or all dimensions of `lhs` to have the same shape as some or all dimensions of `rhs`.\n\nReturns a **view** of the `lhs` array with a new shape without altering any data.\n\nExample::\n\n  x = [1, 2, 3, 4, 5, 6]\n  y = [[0, -4], [3, 2], [2, 2]]\n  reshape_like(x, y) = [[1, 2], [3, 4], [5, 6]]\n\nMore precise control over how dimensions are inherited is achieved by specifying \\\nslices over the `lhs` and `rhs` array dimensions. Only the sliced `lhs` dimensions \\\nare reshaped to the `rhs` sliced dimensions, with the non-sliced `lhs` dimensions staying the same.\n\n  Examples::\n\n  - lhs shape = (30,7), rhs shape = (15,2,4), lhs_begin=0, lhs_end=1, rhs_begin=0, rhs_end=2, output shape = (15,2,7)\n  - lhs shape = (3, 5), rhs shape = (1,15,4), lhs_begin=0, lhs_end=2, rhs_begin=1, rhs_end=2, output shape = (15)\n\nNegative indices are supported, and `None` can be used for either `lhs_end` or `rhs_end` to indicate the end of the range.\n\n  Example::\n\n  - lhs shape = (30, 12), rhs shape = (4, 2, 2, 3), lhs_begin=-1, lhs_end=None, rhs_begin=1, rhs_end=None, output shape = (30, 2, 2, 3)\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L485",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "First input."
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Second input."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "shape_array",
    "Description": "Returns a 1D int64 array containing the shape of data.\n\nExample::\n\n  shape_array([[1,2,3,4], [5,6,7,8]]) = [2,4]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L544",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input Array."
      },
      {
        "Name": "lhs_begin",
        "TypeInfo": "int or None, optional, default='None'",
        "Description": "Defaults to 0. The beginning index along which the lhs dimensions are to be reshaped. Supports negative indices."
      },
      {
        "Name": "lhs_end",
        "TypeInfo": "int or None, optional, default='None'",
        "Description": "Defaults to None. The ending index along which the lhs dimensions are to be used for reshaping. Supports negative indices."
      },
      {
        "Name": "rhs_begin",
        "TypeInfo": "int or None, optional, default='None'",
        "Description": "Defaults to 0. The beginning index along which the rhs dimensions are to be used for reshaping. Supports negative indices."
      },
      {
        "Name": "rhs_end",
        "TypeInfo": "int or None, optional, default='None'",
        "Description": "Defaults to None. The ending index along which the rhs dimensions are to be used for reshaping. Supports negative indices."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "size_array",
    "Description": "Returns a 1D int64 array containing the size of data.\n\nExample::\n\n  size_array([[1,2,3,4], [5,6,7,8]]) = [8]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L596",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input Array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "Cast",
    "Description": "Casts all elements of the input to a new type.\n\n.. note:: ``Cast`` is deprecated. Use ``cast`` instead.\n\nExample::\n\n   cast([0.9, 1.3], dtype='int32') = [0, 1]\n   cast([1e20, 11.1], dtype='float16') = [inf, 11.09375]\n   cast([300, 11.1, 10.9, -1, -3], dtype='uint8') = [44, 11, 10, 255, 253]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L634",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'}, required",
        "Description": "Output data type."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_cast",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "negative",
    "Description": "Numerical negative of the argument, element-wise.\n\nThe storage type of ``negative`` output depends upon the input storage type:\n\n   - negative(default) = default\n   - negative(row_sparse) = row_sparse\n   - negative(csr) = csr\n\n",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "reciprocal",
    "Description": "Returns the reciprocal of the argument, element-wise.\n\nCalculates 1/x.\n\nExample::\n\n    reciprocal([-2, 1, 3, 1.6, 0.2]) = [-0.5, 1.0, 0.33333334, 0.625, 5.0]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L686",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_reciprocal",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "abs",
    "Description": "Returns element-wise absolute value of the input.\n\nExample::\n\n   abs([-2, 0, 3]) = [2, 0, 3]\n\nThe storage type of ``abs`` output depends upon the input storage type:\n\n   - abs(default) = default\n   - abs(row_sparse) = row_sparse\n   - abs(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L708",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_abs",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "sign",
    "Description": "Returns element-wise sign of the input.\n\nExample::\n\n   sign([-2, 0, 3]) = [-1, 0, 1]\n\nThe storage type of ``sign`` output depends upon the input storage type:\n\n   - sign(default) = default\n   - sign(row_sparse) = row_sparse\n   - sign(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L727",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_sign",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "round",
    "Description": "Returns element-wise rounded value to the nearest integer of the input.\n\nExample::\n\n   round([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  2., -2.,  2.,  2.]\n\nThe storage type of ``round`` output depends upon the input storage type:\n\n  - round(default) = default\n  - round(row_sparse) = row_sparse\n  - round(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L746",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "rint",
    "Description": "Returns element-wise rounded value to the nearest integer of the input.\n\n.. note::\n   - For input ``n.5`` ``rint`` returns ``n`` while ``round`` returns ``n+1``.\n   - For input ``-n.5`` both ``rint`` and ``round`` returns ``-n-1``.\n\nExample::\n\n   rint([-1.5, 1.5, -1.9, 1.9, 2.1]) = [-2.,  1., -2.,  2.,  2.]\n\nThe storage type of ``rint`` output depends upon the input storage type:\n\n   - rint(default) = default\n   - rint(row_sparse) = row_sparse\n   - rint(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L767",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "ceil",
    "Description": "Returns element-wise ceiling of the input.\n\nThe ceil of the scalar x is the smallest integer i, such that i >= x.\n\nExample::\n\n   ceil([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  2.,  2.,  3.]\n\nThe storage type of ``ceil`` output depends upon the input storage type:\n\n   - ceil(default) = default\n   - ceil(row_sparse) = row_sparse\n   - ceil(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L786",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "floor",
    "Description": "Returns element-wise floor of the input.\n\nThe floor of the scalar x is the largest integer i, such that i <= x.\n\nExample::\n\n   floor([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-3., -2.,  1.,  1.,  2.]\n\nThe storage type of ``floor`` output depends upon the input storage type:\n\n   - floor(default) = default\n   - floor(row_sparse) = row_sparse\n   - floor(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L805",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "trunc",
    "Description": "Return the element-wise truncated value of the input.\n\nThe truncated value of the scalar x is the nearest integer i which is closer to\nzero than x is. In short, the fractional part of the signed number x is discarded.\n\nExample::\n\n   trunc([-2.1, -1.9, 1.5, 1.9, 2.1]) = [-2., -1.,  1.,  1.,  2.]\n\nThe storage type of ``trunc`` output depends upon the input storage type:\n\n   - trunc(default) = default\n   - trunc(row_sparse) = row_sparse\n   - trunc(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L825",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "fix",
    "Description": "Returns element-wise rounded value to the nearest \\\ninteger towards zero of the input.\n\nExample::\n\n   fix([-2.1, -1.9, 1.9, 2.1]) = [-2., -1.,  1., 2.]\n\nThe storage type of ``fix`` output depends upon the input storage type:\n\n   - fix(default) = default\n   - fix(row_sparse) = row_sparse\n   - fix(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L843",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "square",
    "Description": "Returns element-wise squared value of the input.\n\n.. math::\n   square(x) = x^2\n\nExample::\n\n   square([2, 3, 4]) = [4, 9, 16]\n\nThe storage type of ``square`` output depends upon the input storage type:\n\n   - square(default) = default\n   - square(row_sparse) = row_sparse\n   - square(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L883",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_square",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "sqrt",
    "Description": "Returns element-wise square-root value of the input.\n\n.. math::\n   \\textrm{sqrt}(x) = \\sqrt{x}\n\nExample::\n\n   sqrt([4, 9, 16]) = [2, 3, 4]\n\nThe storage type of ``sqrt`` output depends upon the input storage type:\n\n   - sqrt(default) = default\n   - sqrt(row_sparse) = row_sparse\n   - sqrt(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L907",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_sqrt",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "rsqrt",
    "Description": "Returns element-wise inverse square-root value of the input.\n\n.. math::\n   rsqrt(x) = 1/\\sqrt{x}\n\nExample::\n\n   rsqrt([4,9,16]) = [0.5, 0.33333334, 0.25]\n\nThe storage type of ``rsqrt`` output is always dense\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L927",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_rsqrt",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "cbrt",
    "Description": "Returns element-wise cube-root value of the input.\n\n.. math::\n   cbrt(x) = \\sqrt[3]{x}\n\nExample::\n\n   cbrt([1, 8, -125]) = [1, 2, -5]\n\nThe storage type of ``cbrt`` output depends upon the input storage type:\n\n   - cbrt(default) = default\n   - cbrt(row_sparse) = row_sparse\n   - cbrt(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L950",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_cbrt",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "erf",
    "Description": "Returns element-wise gauss error function of the input.\n\nExample::\n\n   erf([0, -1., 10.]) = [0., -0.8427, 1.]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L964",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_erf",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "erfinv",
    "Description": "Returns element-wise inverse gauss error function of the input.\n\nExample::\n\n   erfinv([0, 0.5., -1.]) = [0., 0.4769, -inf]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L985",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_erfinv",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "rcbrt",
    "Description": "Returns element-wise inverse cube-root value of the input.\n\n.. math::\n   rcbrt(x) = 1/\\sqrt[3]{x}\n\nExample::\n\n   rcbrt([1,8,-125]) = [1.0, 0.5, -0.2]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L1004",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_rcbrt",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "exp",
    "Description": "Returns element-wise exponential value of the input.\n\n.. math::\n   exp(x) = e^x \\approx 2.718^x\n\nExample::\n\n   exp([0, 1, 2]) = [1., 2.71828175, 7.38905621]\n\nThe storage type of ``exp`` output is always dense\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L1044",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "log",
    "Description": "Returns element-wise Natural logarithmic value of the input.\n\nThe natural logarithm is logarithm in base *e*, so that ``log(exp(x)) = x``\n\nThe storage type of ``log`` output is always dense\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L1057",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "log10",
    "Description": "Returns element-wise Base-10 logarithmic value of the input.\n\n``10**log10(x) = x``\n\nThe storage type of ``log10`` output is always dense\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L1074",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "log2",
    "Description": "Returns element-wise Base-2 logarithmic value of the input.\n\n``2**log2(x) = x``\n\nThe storage type of ``log2`` output is always dense\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L1086",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_log",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_log10",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_log2",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "log1p",
    "Description": "Returns element-wise ``log(1 + x)`` value of the input.\n\nThis function is more accurate than ``log(1 + x)``  for small ``x`` so that\n:math:`1+x\\approx 1`\n\nThe storage type of ``log1p`` output depends upon the input storage type:\n\n   - log1p(default) = default\n   - log1p(row_sparse) = row_sparse\n   - log1p(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L1171",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_log1p",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "expm1",
    "Description": "Returns ``exp(x) - 1`` computed element-wise on the input.\n\nThis function provides greater precision than ``exp(x) - 1`` for small values of ``x``.\n\nThe storage type of ``expm1`` output depends upon the input storage type:\n\n   - expm1(default) = default\n   - expm1(row_sparse) = row_sparse\n   - expm1(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_basic.cc:L1189",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_expm1",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "gamma",
    "Description": "Returns the gamma function (extension of the factorial function \\\nto the reals), computed element-wise on the input array.\n\nThe storage type of ``gamma`` output is always dense\n\n",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_gamma",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "gammaln",
    "Description": "Returns element-wise log of the absolute value of the gamma function \\\nof the input.\n\nThe storage type of ``gammaln`` output is always dense\n\n",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_gammaln",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "logical_not",
    "Description": "Returns the result of logical NOT (!) function\n\nExample:\n  logical_not([-2., 0., 1.]) = [0., 1., 0.]\n\n",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "sin",
    "Description": "Computes the element-wise sine of the input array.\n\nThe input should be in radians (:math:`2\\pi` rad equals 360 degrees).\n\n.. math::\n   sin([0, \\pi/4, \\pi/2]) = [0, 0.707, 1]\n\nThe storage type of ``sin`` output depends upon the input storage type:\n\n   - sin(default) = default\n   - sin(row_sparse) = row_sparse\n   - sin(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_trig.cc:L46",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_sin",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "cos",
    "Description": "Computes the element-wise cosine of the input array.\n\nThe input should be in radians (:math:`2\\pi` rad equals 360 degrees).\n\n.. math::\n   cos([0, \\pi/4, \\pi/2]) = [1, 0.707, 0]\n\nThe storage type of ``cos`` output is always dense\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_trig.cc:L89",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_cos",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "tan",
    "Description": "Computes the element-wise tangent of the input array.\n\nThe input should be in radians (:math:`2\\pi` rad equals 360 degrees).\n\n.. math::\n   tan([0, \\pi/4, \\pi/2]) = [0, 1, -inf]\n\nThe storage type of ``tan`` output depends upon the input storage type:\n\n   - tan(default) = default\n   - tan(row_sparse) = row_sparse\n   - tan(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_trig.cc:L139",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_tan",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "arcsin",
    "Description": "Returns element-wise inverse sine of the input array.\n\nThe input should be in the range `[-1, 1]`.\nThe output is in the closed interval of [:math:`-\\pi/2`, :math:`\\pi/2`].\n\n.. math::\n   arcsin([-1, -.707, 0, .707, 1]) = [-\\pi/2, -\\pi/4, 0, \\pi/4, \\pi/2]\n\nThe storage type of ``arcsin`` output depends upon the input storage type:\n\n   - arcsin(default) = default\n   - arcsin(row_sparse) = row_sparse\n   - arcsin(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_trig.cc:L160",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_arcsin",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "arccos",
    "Description": "Returns element-wise inverse cosine of the input array.\n\nThe input should be in range `[-1, 1]`.\nThe output is in the closed interval :math:`[0, \\pi]`\n\n.. math::\n   arccos([-1, -.707, 0, .707, 1]) = [\\pi, 3\\pi/4, \\pi/2, \\pi/4, 0]\n\nThe storage type of ``arccos`` output is always dense\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_trig.cc:L179",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_arccos",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "arctan",
    "Description": "Returns element-wise inverse tangent of the input array.\n\nThe output is in the closed interval :math:`[-\\pi/2, \\pi/2]`\n\n.. math::\n   arctan([-1, 0, 1]) = [-\\pi/4, 0, \\pi/4]\n\nThe storage type of ``arctan`` output depends upon the input storage type:\n\n   - arctan(default) = default\n   - arctan(row_sparse) = row_sparse\n   - arctan(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_trig.cc:L200",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_arctan",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "degrees",
    "Description": "Converts each element of the input array from radians to degrees.\n\n.. math::\n   degrees([0, \\pi/2, \\pi, 3\\pi/2, 2\\pi]) = [0, 90, 180, 270, 360]\n\nThe storage type of ``degrees`` output depends upon the input storage type:\n\n   - degrees(default) = default\n   - degrees(row_sparse) = row_sparse\n   - degrees(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_trig.cc:L219",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_degrees",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "radians",
    "Description": "Converts each element of the input array from degrees to radians.\n\n.. math::\n   radians([0, 90, 180, 270, 360]) = [0, \\pi/2, \\pi, 3\\pi/2, 2\\pi]\n\nThe storage type of ``radians`` output depends upon the input storage type:\n\n   - radians(default) = default\n   - radians(row_sparse) = row_sparse\n   - radians(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_trig.cc:L238",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_radians",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "sinh",
    "Description": "Returns the hyperbolic sine of the input array, computed element-wise.\n\n.. math::\n   sinh(x) = 0.5\\times(exp(x) - exp(-x))\n\nThe storage type of ``sinh`` output depends upon the input storage type:\n\n   - sinh(default) = default\n   - sinh(row_sparse) = row_sparse\n   - sinh(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_trig.cc:L257",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_sinh",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "cosh",
    "Description": "Returns the hyperbolic cosine  of the input array, computed element-wise.\n\n.. math::\n   cosh(x) = 0.5\\times(exp(x) + exp(-x))\n\nThe storage type of ``cosh`` output is always dense\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_trig.cc:L272",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_cosh",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "tanh",
    "Description": "Returns the hyperbolic tangent of the input array, computed element-wise.\n\n.. math::\n   tanh(x) = sinh(x) / cosh(x)\n\nThe storage type of ``tanh`` output depends upon the input storage type:\n\n   - tanh(default) = default\n   - tanh(row_sparse) = row_sparse\n   - tanh(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_trig.cc:L290",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_tanh",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "arcsinh",
    "Description": "Returns the element-wise inverse hyperbolic sine of the input array, \\\ncomputed element-wise.\n\nThe storage type of ``arcsinh`` output depends upon the input storage type:\n\n   - arcsinh(default) = default\n   - arcsinh(row_sparse) = row_sparse\n   - arcsinh(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_trig.cc:L306",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_arcsinh",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "arccosh",
    "Description": "Returns the element-wise inverse hyperbolic cosine of the input array, \\\ncomputed element-wise.\n\nThe storage type of ``arccosh`` output is always dense\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_trig.cc:L320",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_arccosh",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "arctanh",
    "Description": "Returns the element-wise inverse hyperbolic tangent of the input array, \\\ncomputed element-wise.\n\nThe storage type of ``arctanh`` output depends upon the input storage type:\n\n   - arctanh(default) = default\n   - arctanh(row_sparse) = row_sparse\n   - arctanh(csr) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\elemwise_unary_op_trig.cc:L337",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_arctanh",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "first input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "second input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_histogram",
    "Description": "This operators implements the histogram function.\n\nExample::\n  x = [[0, 1], [2, 2], [3, 4]]\n  histo, bin_edges = histogram(data=x, bin_bounds=[], bin_cnt=5, range=(0,5))\n  histo = [1, 1, 2, 1, 1]\n  bin_edges = [0., 1., 2., 3., 4.]\n  histo, bin_edges = histogram(data=x, bin_bounds=[0., 2.1, 3.])\n  histo = [4, 1]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\histogram.cc:L136",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input ndarray"
      },
      {
        "Name": "bins",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input ndarray"
      },
      {
        "Name": "bin_cnt",
        "TypeInfo": "int or None, optional, default='None'",
        "Description": "Number of bins for uniform case"
      },
      {
        "Name": "range",
        "TypeInfo": ", optional, default=None",
        "Description": "The lower and upper range of the bins. if not provided, range is simply (a.min(), a.max()). values outside the range are ignored. the first element of the range must be less than or equal to the second. range affects the automatic bin computation as well. while bin width is computed to be optimal based on the actual data within range, the bin count will fill the entire range including portions containing no data."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "Embedding",
    "Description": "Maps integer indices to vector representations (embeddings).\n\nThis operator maps words to real-valued vectors in a high-dimensional space,\ncalled word embeddings. These embeddings can capture semantic and syntactic properties of the words.\nFor example, it has been noted that in the learned embedding spaces, similar words tend\nto be close to each other and dissimilar words far apart.\n\nFor an input array of shape (d1, ..., dK),\nthe shape of an output array is (d1, ..., dK, output_dim).\nAll the input values should be integers in the range [0, input_dim).\n\nIf the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be\n(ip0, op0).\n\nBy default, if any index mentioned is too large, it is replaced by the index that addresses\nthe last vector in an embedding matrix.\n\nExamples::\n\n  input_dim = 4\n  output_dim = 5\n\n  // Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)\n  y = [[  0.,   1.,   2.,   3.,   4.],\n       [  5.,   6.,   7.,   8.,   9.],\n       [ 10.,  11.,  12.,  13.,  14.],\n       [ 15.,  16.,  17.,  18.,  19.]]\n\n  // Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]\n  x = [[ 1.,  3.],\n       [ 0.,  2.]]\n\n  // Mapped input x to its vector representation y.\n  Embedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],\n                            [ 15.,  16.,  17.,  18.,  19.]],\n\n                           [[  0.,   1.,   2.,   3.,   4.],\n                            [ 10.,  11.,  12.,  13.,  14.]]]\n\n\nThe storage type of weight can be either row_sparse or default.\n\n.. Note::\n\n    If \"sparse_grad\" is set to True, the storage type of gradient w.r.t weights will be\n    \"row_sparse\". Only a subset of optimizers support sparse gradients, including SGD, AdaGrad\n    and Adam. Note that by default lazy updates is turned on, which may perform differently\n    from standard updates. For more details, please check the Optimization API at:\n    https://mxnet.incubator.apache.org/api/python/optimization/optimization.html\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\indexing_op.cc:L519",
    "NumArgs": 6,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array to the embedding operator."
      },
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The embedding weight matrix."
      },
      {
        "Name": "input_dim",
        "TypeInfo": "int, required",
        "Description": "Vocabulary size of the input indices."
      },
      {
        "Name": "output_dim",
        "TypeInfo": "int, required",
        "Description": "Dimension of the embedding vectors."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'",
        "Description": "Data type of weight."
      },
      {
        "Name": "sparse_grad",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Compute row sparse gradient in the backward calculation. If set to True, the grad's storage type is row_sparse."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_SparseEmbedding",
    "Description": "Maps integer indices to vector representations (embeddings).\n\nnote:: ``contrib.SparseEmbedding`` is deprecated, use ``Embedding`` instead.\n\nThis operator maps words to real-valued vectors in a high-dimensional space,\ncalled word embeddings. These embeddings can capture semantic and syntactic properties of the words.\nFor example, it has been noted that in the learned embedding spaces, similar words tend\nto be close to each other and dissimilar words far apart.\n\nFor an input array of shape (d1, ..., dK),\nthe shape of an output array is (d1, ..., dK, output_dim).\nAll the input values should be integers in the range [0, input_dim).\n\nIf the input_dim is ip0 and output_dim is op0, then shape of the embedding weight matrix must be\n(ip0, op0).\n\nThe storage type of the gradient will be `row_sparse`.\n\n.. Note::\n\n    `SparseEmbedding` is designed for the use case where `input_dim` is very large (e.g. 100k).\n    The operator is available on both CPU and GPU.\n    When `deterministic` is set to `True`, the accumulation of gradients follows a\n    deterministic order if a feature appears multiple times in the input. However, the\n    accumulation is usually slower when the order is enforced on GPU.\n    When the operator is used on the GPU, the recommended value for `deterministic` is `True`.\n\nExamples::\n\n  input_dim = 4\n  output_dim = 5\n\n  // Each row in weight matrix y represents a word. So, y = (w0,w1,w2,w3)\n  y = [[  0.,   1.,   2.,   3.,   4.],\n       [  5.,   6.,   7.,   8.,   9.],\n       [ 10.,  11.,  12.,  13.,  14.],\n       [ 15.,  16.,  17.,  18.,  19.]]\n\n  // Input array x represents n-grams(2-gram). So, x = [(w1,w3), (w0,w2)]\n  x = [[ 1.,  3.],\n       [ 0.,  2.]]\n\n  // Mapped input x to its vector representation y.\n  SparseEmbedding(x, y, 4, 5) = [[[  5.,   6.,   7.,   8.,   9.],\n                                 [ 15.,  16.,  17.,  18.,  19.]],\n\n                                [[  0.,   1.,   2.,   3.,   4.],\n                                 [ 10.,  11.,  12.,  13.,  14.]]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\indexing_op.cc:L595",
    "NumArgs": 6,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array to the embedding operator."
      },
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The embedding weight matrix."
      },
      {
        "Name": "input_dim",
        "TypeInfo": "int, required",
        "Description": "Vocabulary size of the input indices."
      },
      {
        "Name": "output_dim",
        "TypeInfo": "int, required",
        "Description": "Dimension of the embedding vectors."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'",
        "Description": "Data type of weight."
      },
      {
        "Name": "sparse_grad",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Compute row sparse gradient in the backward calculation. If set to True, the grad's storage type is row_sparse."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_Embedding",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_SparseEmbedding",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "take",
    "Description": "Takes elements from an input array along the given axis.\n\nThis function slices the input array along a particular axis with the provided indices.\n\nGiven data tensor of rank r >= 1, and indices tensor of rank q, gather entries of the axis\ndimension of data (by default outer-most one as axis=0) indexed by indices, and concatenates them\nin an output tensor of rank q + (r - 1).\n\nExamples::\n\n  x = [4.  5.  6.]\n\n  // Trivial case, take the second element along the first axis.\n\n  take(x, [1]) = [ 5. ]\n\n  // The other trivial case, axis=-1, take the third element along the first axis\n\n  take(x, [3], axis=-1, mode='clip') = [ 6. ]\n\n  x = [[ 1.,  2.],\n       [ 3.,  4.],\n       [ 5.,  6.]]\n\n  // In this case we will get rows 0 and 1, then 1 and 2. Along axis 0\n\n  take(x, [[0,1],[1,2]]) = [[[ 1.,  2.],\n                             [ 3.,  4.]],\n\n                            [[ 3.,  4.],\n                             [ 5.,  6.]]]\n\n  // In this case we will get rows 0 and 1, then 1 and 2 (calculated by wrapping around).\n  // Along axis 1\n\n  take(x, [[0, 3], [-1, -2]], axis=1, mode='wrap') = [[[ 1.  2.]\n                                                       [ 2.  1.]]\n\n                                                      [[ 3.  4.]\n                                                       [ 4.  3.]]\n\n                                                      [[ 5.  6.]\n                                                       [ 6.  5.]]]\n\nThe storage type of ``take`` output depends upon the input storage type:\n\n   - take(default, default) = default\n   - take(csr, default, axis=0) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\indexing_op.cc:L695",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "a",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array."
      },
      {
        "Name": "indices",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The indices of the values to be extracted."
      },
      {
        "Name": "axis",
        "TypeInfo": "int, optional, default='0'",
        "Description": "The axis of input array to be taken.For input tensor of rank r, it could be in the range of [-r, r-1]"
      },
      {
        "Name": "mode",
        "TypeInfo": "{'clip', 'raise', 'wrap'},optional, default='clip'",
        "Description": "Specify how out-of-bound indices bahave. Default is \"clip\". \"clip\" means clip to the range. So, if all indices mentioned are too large, they are replaced by the index that addresses the last element along an axis.  \"wrap\" means to wrap around.  \"raise\" means to raise an error, not supported yet."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_take",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "batch_take",
    "Description": "Takes elements from a data batch.\n\n.. note::\n  `batch_take` is deprecated. Use `pick` instead.\n\nGiven an input array of shape ``(d0, d1)`` and indices of shape ``(i0,)``, the result will be\nan output array of shape ``(i0,)`` with::\n\n  output[i] = input[i, indices[i]]\n\nExamples::\n\n  x = [[ 1.,  2.],\n       [ 3.,  4.],\n       [ 5.,  6.]]\n\n  // takes elements with specified indices\n  batch_take(x, [0,1,0]) = [ 1.  4.  5.]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\indexing_op.cc:L753",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "a",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array"
      },
      {
        "Name": "indices",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The index array"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "one_hot",
    "Description": "Returns a one-hot array.\n\nThe locations represented by `indices` take value `on_value`, while all\nother locations take value `off_value`.\n\n`one_hot` operation with `indices` of shape ``(i0, i1)`` and `depth`  of ``d`` would result\nin an output array of shape ``(i0, i1, d)`` with::\n\n  output[i,j,:] = off_value\n  output[i,j,indices[i,j]] = on_value\n\nExamples::\n\n  one_hot([1,0,2,0], 3) = [[ 0.  1.  0.]\n                           [ 1.  0.  0.]\n                           [ 0.  0.  1.]\n                           [ 1.  0.  0.]]\n\n  one_hot([1,0,2,0], 3, on_value=8, off_value=1,\n          dtype='int32') = [[1 8 1]\n                            [8 1 1]\n                            [1 1 8]\n                            [8 1 1]]\n\n  one_hot([[1,0],[1,0],[2,0]], 3) = [[[ 0.  1.  0.]\n                                      [ 1.  0.  0.]]\n\n                                     [[ 0.  1.  0.]\n                                      [ 1.  0.  0.]]\n\n                                     [[ 0.  0.  1.]\n                                      [ 1.  0.  0.]]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\indexing_op.cc:L799",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "indices",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "array of locations where to set on_value"
      },
      {
        "Name": "depth",
        "TypeInfo": "int, required",
        "Description": "Depth of the one hot dimension."
      },
      {
        "Name": "on_value",
        "TypeInfo": "double, optional, default=1",
        "Description": "The value assigned to the locations represented by indices."
      },
      {
        "Name": "off_value",
        "TypeInfo": "double, optional, default=0",
        "Description": "The value assigned to the locations not represented by indices."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'",
        "Description": "DType of the output"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "gather_nd",
    "Description": "Gather elements or slices from `data` and store to a tensor whose\nshape is defined by `indices`.\n\nGiven `data` with shape `(X_0, X_1, ..., X_{N-1})` and indices with shape\n`(M, Y_0, ..., Y_{K-1})`, the output will have shape `(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})`,\nwhere `M <= N`. If `M == N`, output shape will simply be `(Y_0, ..., Y_{K-1})`.\n\nThe elements in output is defined as follows::\n\n  output[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}] = data[indices[0, y_0, ..., y_{K-1}],\n                                                      ...,\n                                                      indices[M-1, y_0, ..., y_{K-1}],\n                                                      x_M, ..., x_{N-1}]\n\nExamples::\n\n  data = [[0, 1], [2, 3]]\n  indices = [[1, 1, 0], [0, 1, 0]]\n  gather_nd(data, indices) = [2, 3, 0]\n\n  data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]\n  indices = [[0, 1], [1, 0]]\n  gather_nd(data, indices) = [[3, 4], [5, 6]]\n\n",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "data"
      },
      {
        "Name": "indices",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "indices"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "scatter_nd",
    "Description": "Scatters data into a new tensor according to indices.\n\nGiven `data` with shape `(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})` and indices with shape\n`(M, Y_0, ..., Y_{K-1})`, the output will have shape `(X_0, X_1, ..., X_{N-1})`,\nwhere `M <= N`. If `M == N`, data shape should simply be `(Y_0, ..., Y_{K-1})`.\n\nThe elements in output is defined as follows::\n\n  output[indices[0, y_0, ..., y_{K-1}],\n         ...,\n         indices[M-1, y_0, ..., y_{K-1}],\n         x_M, ..., x_{N-1}] = data[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}]\n\nall other entries in output are 0.\n\n.. warning::\n\n    If the indices have duplicates, the result will be non-deterministic and\n    the gradient of `scatter_nd` will not be correct!!\n\n\nExamples::\n\n  data = [2, 3, 0]\n  indices = [[1, 1, 0], [0, 1, 0]]\n  shape = (2, 2)\n  scatter_nd(data, indices, shape) = [[0, 0], [2, 3]]\n\n  data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]\n  indices = [[0, 1], [1, 1]]\n  shape = (2, 2, 2, 2)\n  scatter_nd(data, indices, shape) = [[[[0, 0],\n                                        [0, 0]],\n\n                                       [[1, 2],\n                                        [3, 4]]],\n\n                                      [[[0, 0],\n                                        [0, 0]],\n\n                                       [[5, 6],\n                                        [7, 8]]]]\n\n",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "data"
      },
      {
        "Name": "indices",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "indices"
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), required",
        "Description": "Shape of output."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_gather_nd",
    "Description": "Accumulates data according to indices and get the result. It's the backward of\n`gather_nd`.\n\nGiven `data` with shape `(Y_0, ..., Y_{K-1}, X_M, ..., X_{N-1})` and indices with shape\n`(M, Y_0, ..., Y_{K-1})`, the output will have shape `(X_0, X_1, ..., X_{N-1})`,\nwhere `M <= N`. If `M == N`, data shape should simply be `(Y_0, ..., Y_{K-1})`.\n\nThe elements in output is defined as follows::\n\n  output[indices[0, y_0, ..., y_{K-1}],\n         ...,\n         indices[M-1, y_0, ..., y_{K-1}],\n         x_M, ..., x_{N-1}] += data[y_0, ..., y_{K-1}, x_M, ..., x_{N-1}]\n\nall other entries in output are 0 or the original value if AddTo is triggered.\n\nExamples::\n\n  data = [2, 3, 0]\n  indices = [[1, 1, 0], [0, 1, 0]]\n  shape = (2, 2)\n  _backward_gather_nd(data, indices, shape) = [[0, 0], [2, 3]] # Same as scatter_nd\n\n  # The difference between scatter_nd and scatter_nd_acc is the latter will accumulate\n  #  the values that point to the same index.\n\n  data = [2, 3, 0]\n  indices = [[1, 1, 0], [1, 1, 0]]\n  shape = (2, 2)\n  _backward_gather_nd(data, indices, shape) = [[0, 0], [0, 5]]\n\n",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "data"
      },
      {
        "Name": "indices",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "indices"
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), required",
        "Description": "Shape of output."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_scatter_set_nd",
    "Description": "This operator has the same functionality as scatter_nd\nexcept that it does not reset the elements not indexed by the input\nindex `NDArray` in the input data `NDArray`. output should be explicitly\ngiven and be the same as lhs.\n\n.. note:: This operator is for internal use only.\n\nExamples::\n\n  data = [2, 3, 0]\n  indices = [[1, 1, 0], [0, 1, 0]]\n  out = [[1, 1], [1, 1]]\n  _scatter_set_nd(lhs=out, rhs=data, indices=indices, out=out)\n  out = [[0, 1], [2, 3]]\n\n",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "source input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "value to assign"
      },
      {
        "Name": "indices",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "indices"
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), required",
        "Description": "Shape of output."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_zeros_without_dtype",
    "Description": "fill target with zeros without default dtype",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=None",
        "Description": "The shape of the output"
      },
      {
        "Name": "ctx",
        "TypeInfo": "string, optional, default=''",
        "Description": "Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls."
      },
      {
        "Name": "dtype",
        "TypeInfo": "int, optional, default='-1'",
        "Description": "Target data type."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_zeros",
    "Description": "fill target with zeros",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "The shape of the output"
      },
      {
        "Name": "ctx",
        "TypeInfo": "string, optional, default=''",
        "Description": "Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'",
        "Description": "Target data type."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_eye",
    "Description": "Return a 2-D array with ones on the diagonal and zeros elsewhere.",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "N",
        "TypeInfo": ", required",
        "Description": "Number of rows in the output."
      },
      {
        "Name": "M",
        "TypeInfo": ", optional, default=0",
        "Description": "Number of columns in the output. If 0, defaults to N"
      },
      {
        "Name": "k",
        "TypeInfo": ", optional, default=0",
        "Description": "Index of the diagonal. 0 (the default) refers to the main diagonal.A positive value refers to an upper diagonal.A negative value to a lower diagonal."
      },
      {
        "Name": "ctx",
        "TypeInfo": "string, optional, default=''",
        "Description": "Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'",
        "Description": "Target data type."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_ones",
    "Description": "fill target with ones",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "The shape of the output"
      },
      {
        "Name": "ctx",
        "TypeInfo": "string, optional, default=''",
        "Description": "Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'",
        "Description": "Target data type."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_full",
    "Description": "fill target with a scalar value",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=None",
        "Description": "The shape of the output"
      },
      {
        "Name": "ctx",
        "TypeInfo": "string, optional, default=''",
        "Description": "Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'",
        "Description": "Target data type."
      },
      {
        "Name": "value",
        "TypeInfo": "double, required",
        "Description": "Value with which to fill newly created tensor"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_arange",
    "Description": "Return evenly spaced values within a given interval. Similar to Numpy",
    "NumArgs": 7,
    "Arguments": [
      {
        "Name": "start",
        "TypeInfo": "double, required",
        "Description": "Start of interval. The interval includes this value. The default start value is 0."
      },
      {
        "Name": "stop",
        "TypeInfo": "double or None, optional, default=None",
        "Description": "End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out."
      },
      {
        "Name": "step",
        "TypeInfo": "double, optional, default=1",
        "Description": "Spacing between values."
      },
      {
        "Name": "repeat",
        "TypeInfo": "int, optional, default='1'",
        "Description": "The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --> a, a, a."
      },
      {
        "Name": "infer_range",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "When set to True, infer the stop position from the start, step, repeat, and output tensor size."
      },
      {
        "Name": "ctx",
        "TypeInfo": "string, optional, default=''",
        "Description": "Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'",
        "Description": "Target data type."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_linspace",
    "Description": "Return evenly spaced numbers over a specified interval. Similar to Numpy",
    "NumArgs": 7,
    "Arguments": [
      {
        "Name": "start",
        "TypeInfo": "double, required",
        "Description": "Start of interval. The interval includes this value. The default start value is 0."
      },
      {
        "Name": "stop",
        "TypeInfo": "double or None, optional, default=None",
        "Description": "End of interval. The interval does not include this value, except in some cases where step is not an integer and floating point round-off affects the length of out."
      },
      {
        "Name": "step",
        "TypeInfo": "double, optional, default=1",
        "Description": "Spacing between values."
      },
      {
        "Name": "repeat",
        "TypeInfo": "int, optional, default='1'",
        "Description": "The repeating time of all elements. E.g repeat=3, the element a will be repeated three times --> a, a, a."
      },
      {
        "Name": "infer_range",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "When set to True, infer the stop position from the start, step, repeat, and output tensor size."
      },
      {
        "Name": "ctx",
        "TypeInfo": "string, optional, default=''",
        "Description": "Context of output, in format [cpu|gpu|cpu_pinned](n).Only used for imperative calls."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'float16', 'float32', 'float64', 'int32', 'int64', 'int8', 'uint8'},optional, default='float32'",
        "Description": "Target data type."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "zeros_like",
    "Description": "Return an array of zeros with the same shape, type and storage type\nas the input array.\n\nThe storage type of ``zeros_like`` output depends on the storage type of the input\n\n- zeros_like(row_sparse) = row_sparse\n- zeros_like(csr) = csr\n- zeros_like(default) = default\n\nExamples::\n\n  x = [[ 1.,  1.,  1.],\n       [ 1.,  1.,  1.]]\n\n  zeros_like(x) = [[ 0.,  0.,  0.],\n                   [ 0.,  0.,  0.]]\n\n",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "ones_like",
    "Description": "Return an array of ones with the same shape and type\nas the input array.\n\nExamples::\n\n  x = [[ 0.,  0.,  0.],\n       [ 0.,  0.,  0.]]\n\n  ones_like(x) = [[ 1.,  1.,  1.],\n                  [ 1.,  1.,  1.]]\n\n",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_linalg_gemm",
    "Description": "Performs general matrix multiplication and accumulation.\nInput are tensors *A*, *B*, *C*, each of dimension *n >= 2* and having the same shape\non the leading *n-2* dimensions.\n\nIf *n=2*, the BLAS3 function *gemm* is performed:\n\n   *out* = *alpha* \\* *op*\\ (*A*) \\* *op*\\ (*B*) + *beta* \\* *C*\n\nHere, *alpha* and *beta* are scalar parameters, and *op()* is either the identity or\nmatrix transposition (depending on *transpose_a*, *transpose_b*).\n\nIf *n>2*, *gemm* is performed separately for a batch of matrices. The column indices of the matrices\nare given by the last dimensions of the tensors, the row indices by the axis specified with the *axis*\nparameter. By default, the trailing two dimensions will be used for matrix encoding.\n\nFor a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes\ncalls. For example let *A*, *B*, *C* be 5 dimensional tensors. Then gemm(*A*, *B*, *C*, axis=1) is equivalent\nto the following without the overhead of the additional swapaxis operations::\n\n    A1 = swapaxes(A, dim1=1, dim2=3)\n    B1 = swapaxes(B, dim1=1, dim2=3)\n    C = swapaxes(C, dim1=1, dim2=3)\n    C = gemm(A1, B1, C)\n    C = swapaxis(C, dim1=1, dim2=3)\n\nWhen the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE\nand MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use\npseudo-float16 precision (float32 math with float16 I/O) precision in order to use\nTensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.\n\n.. note:: The operator supports float32 and float64 data types only.\n\nExamples::\n\n   // Single matrix multiply-add\n   A = [[1.0, 1.0], [1.0, 1.0]]\n   B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]\n   C = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]\n   gemm(A, B, C, transpose_b=True, alpha=2.0, beta=10.0)\n           = [[14.0, 14.0, 14.0], [14.0, 14.0, 14.0]]\n\n   // Batch matrix multiply-add\n   A = [[[1.0, 1.0]], [[0.1, 0.1]]]\n   B = [[[1.0, 1.0]], [[0.1, 0.1]]]\n   C = [[[10.0]], [[0.01]]]\n   gemm(A, B, C, transpose_b=True, alpha=2.0 , beta=10.0)\n           = [[[104.0]], [[0.14]]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\la_op.cc:L89",
    "NumArgs": 8,
    "Arguments": [
      {
        "Name": "A",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Tensor of input matrices"
      },
      {
        "Name": "B",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Tensor of input matrices"
      },
      {
        "Name": "C",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Tensor of input matrices"
      },
      {
        "Name": "transpose_a",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Multiply with transposed of first input (A)."
      },
      {
        "Name": "transpose_b",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Multiply with transposed of second input (B)."
      },
      {
        "Name": "alpha",
        "TypeInfo": "double, optional, default=1",
        "Description": "Scalar factor multiplied with A*B."
      },
      {
        "Name": "beta",
        "TypeInfo": "double, optional, default=1",
        "Description": "Scalar factor multiplied with C."
      },
      {
        "Name": "axis",
        "TypeInfo": "int, optional, default='-2'",
        "Description": "Axis corresponding to the matrix rows."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_linalg_gemm",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_linalg_gemm2",
    "Description": "Performs general matrix multiplication.\nInput are tensors *A*, *B*, each of dimension *n >= 2* and having the same shape\non the leading *n-2* dimensions.\n\nIf *n=2*, the BLAS3 function *gemm* is performed:\n\n   *out* = *alpha* \\* *op*\\ (*A*) \\* *op*\\ (*B*)\n\nHere *alpha* is a scalar parameter and *op()* is either the identity or the matrix\ntransposition (depending on *transpose_a*, *transpose_b*).\n\nIf *n>2*, *gemm* is performed separately for a batch of matrices. The column indices of the matrices\nare given by the last dimensions of the tensors, the row indices by the axis specified with the *axis*\nparameter. By default, the trailing two dimensions will be used for matrix encoding.\n\nFor a non-default axis parameter, the operation performed is equivalent to a series of swapaxes/gemm/swapaxes\ncalls. For example let *A*, *B* be 5 dimensional tensors. Then gemm(*A*, *B*, axis=1) is equivalent to\nthe following without the overhead of the additional swapaxis operations::\n\n    A1 = swapaxes(A, dim1=1, dim2=3)\n    B1 = swapaxes(B, dim1=1, dim2=3)\n    C = gemm2(A1, B1)\n    C = swapaxis(C, dim1=1, dim2=3)\n\nWhen the input data is of type float32 and the environment variables MXNET_CUDA_ALLOW_TENSOR_CORE\nand MXNET_CUDA_TENSOR_OP_MATH_ALLOW_CONVERSION are set to 1, this operator will try to use\npseudo-float16 precision (float32 math with float16 I/O) precision in order to use\nTensor Cores on suitable NVIDIA GPUs. This can sometimes give significant speedups.\n\n.. note:: The operator supports float32 and float64 data types only.\n\nExamples::\n\n   // Single matrix multiply\n   A = [[1.0, 1.0], [1.0, 1.0]]\n   B = [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]\n   gemm2(A, B, transpose_b=True, alpha=2.0)\n            = [[4.0, 4.0, 4.0], [4.0, 4.0, 4.0]]\n\n   // Batch matrix multiply\n   A = [[[1.0, 1.0]], [[0.1, 0.1]]]\n   B = [[[1.0, 1.0]], [[0.1, 0.1]]]\n   gemm2(A, B, transpose_b=True, alpha=2.0)\n           = [[[4.0]], [[0.04 ]]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\la_op.cc:L163",
    "NumArgs": 6,
    "Arguments": [
      {
        "Name": "A",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Tensor of input matrices"
      },
      {
        "Name": "B",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Tensor of input matrices"
      },
      {
        "Name": "transpose_a",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Multiply with transposed of first input (A)."
      },
      {
        "Name": "transpose_b",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Multiply with transposed of second input (B)."
      },
      {
        "Name": "alpha",
        "TypeInfo": "double, optional, default=1",
        "Description": "Scalar factor multiplied with A*B."
      },
      {
        "Name": "axis",
        "TypeInfo": "int, optional, default='-2'",
        "Description": "Axis corresponding to the matrix row indices."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_linalg_gemm2",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_linalg_potrf",
    "Description": "Performs Cholesky factorization of a symmetric positive-definite matrix.\nInput is a tensor *A* of dimension *n >= 2*.\n\nIf *n=2*, the Cholesky factor *B* of the symmetric, positive definite matrix *A* is\ncomputed. *B* is triangular (entries of upper or lower triangle are all zero), has\npositive diagonal entries, and:\n\n  *A* = *B* \\* *B*\\ :sup:`T`  if *lower* = *true*\n  *A* = *B*\\ :sup:`T` \\* *B*  if *lower* = *false*\n\nIf *n>2*, *potrf* is performed separately on the trailing two dimensions for all inputs\n(batch mode).\n\n.. note:: The operator supports float32 and float64 data types only.\n\nExamples::\n\n   // Single matrix factorization\n   A = [[4.0, 1.0], [1.0, 4.25]]\n   potrf(A) = [[2.0, 0], [0.5, 2.0]]\n\n   // Batch matrix factorization\n   A = [[[4.0, 1.0], [1.0, 4.25]], [[16.0, 4.0], [4.0, 17.0]]]\n   potrf(A) = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\la_op.cc:L214",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "A",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Tensor of input matrices to be decomposed"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_linalg_potrf",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_linalg_potri",
    "Description": "Performs matrix inversion from a Cholesky factorization.\nInput is a tensor *A* of dimension *n >= 2*.\n\nIf *n=2*, *A* is a triangular matrix (entries of upper or lower triangle are all zero)\nwith positive diagonal. We compute:\n\n  *out* = *A*\\ :sup:`-T` \\* *A*\\ :sup:`-1` if *lower* = *true*\n  *out* = *A*\\ :sup:`-1` \\* *A*\\ :sup:`-T` if *lower* = *false*\n\nIn other words, if *A* is the Cholesky factor of a symmetric positive definite matrix\n*B* (obtained by *potrf*), then\n\n  *out* = *B*\\ :sup:`-1`\n\nIf *n>2*, *potri* is performed separately on the trailing two dimensions for all inputs\n(batch mode).\n\n.. note:: The operator supports float32 and float64 data types only.\n\n.. note:: Use this operator only if you are certain you need the inverse of *B*, and\n          cannot use the Cholesky factor *A* (*potrf*), together with backsubstitution\n          (*trsm*). The latter is numerically much safer, and also cheaper.\n\nExamples::\n\n   // Single matrix inverse\n   A = [[2.0, 0], [0.5, 2.0]]\n   potri(A) = [[0.26563, -0.0625], [-0.0625, 0.25]]\n\n   // Batch matrix inverse\n   A = [[[2.0, 0], [0.5, 2.0]], [[4.0, 0], [1.0, 4.0]]]\n   potri(A) = [[[0.26563, -0.0625], [-0.0625, 0.25]],\n               [[0.06641, -0.01562], [-0.01562, 0,0625]]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\la_op.cc:L275",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "A",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Tensor of lower triangular matrices"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_linalg_potri",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_linalg_trmm",
    "Description": "Performs multiplication with a lower triangular matrix.\nInput are tensors *A*, *B*, each of dimension *n >= 2* and having the same shape\non the leading *n-2* dimensions.\n\nIf *n=2*, *A* must be triangular. The operator performs the BLAS3 function\n*trmm*:\n\n   *out* = *alpha* \\* *op*\\ (*A*) \\* *B*\n\nif *rightside=False*, or\n\n   *out* = *alpha* \\* *B* \\* *op*\\ (*A*)\n\nif *rightside=True*. Here, *alpha* is a scalar parameter, and *op()* is either the\nidentity or the matrix transposition (depending on *transpose*).\n\nIf *n>2*, *trmm* is performed separately on the trailing two dimensions for all inputs\n(batch mode).\n\n.. note:: The operator supports float32 and float64 data types only.\n\nExamples::\n\n   // Single triangular matrix multiply\n   A = [[1.0, 0], [1.0, 1.0]]\n   B = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]\n   trmm(A, B, alpha=2.0) = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]\n\n   // Batch triangular matrix multiply\n   A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]\n   B = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]], [[0.5, 0.5, 0.5], [0.5, 0.5, 0.5]]]\n   trmm(A, B, alpha=2.0) = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],\n                            [[1.0, 1.0, 1.0], [2.0, 2.0, 2.0]]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\la_op.cc:L333",
    "NumArgs": 6,
    "Arguments": [
      {
        "Name": "A",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Tensor of lower triangular matrices"
      },
      {
        "Name": "B",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Tensor of matrices"
      },
      {
        "Name": "transpose",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Use transposed of the triangular matrix"
      },
      {
        "Name": "rightside",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Multiply triangular matrix from the right to non-triangular one."
      },
      {
        "Name": "lower",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "True if the triangular matrix is lower triangular, false if it is upper triangular."
      },
      {
        "Name": "alpha",
        "TypeInfo": "double, optional, default=1",
        "Description": "Scalar factor to be applied to the result."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_linalg_trmm",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_linalg_trsm",
    "Description": "Solves matrix equation involving a lower triangular matrix.\nInput are tensors *A*, *B*, each of dimension *n >= 2* and having the same shape\non the leading *n-2* dimensions.\n\nIf *n=2*, *A* must be triangular. The operator performs the BLAS3 function\n*trsm*, solving for *out* in:\n\n   *op*\\ (*A*) \\* *out* = *alpha* \\* *B*\n\nif *rightside=False*, or\n\n   *out* \\* *op*\\ (*A*) = *alpha* \\* *B*\n\nif *rightside=True*. Here, *alpha* is a scalar parameter, and *op()* is either the\nidentity or the matrix transposition (depending on *transpose*).\n\nIf *n>2*, *trsm* is performed separately on the trailing two dimensions for all inputs\n(batch mode).\n\n.. note:: The operator supports float32 and float64 data types only.\n\nExamples::\n\n   // Single matrix solve\n   A = [[1.0, 0], [1.0, 1.0]]\n   B = [[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]]\n   trsm(A, B, alpha=0.5) = [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]\n\n   // Batch matrix solve\n   A = [[[1.0, 0], [1.0, 1.0]], [[1.0, 0], [1.0, 1.0]]]\n   B = [[[2.0, 2.0, 2.0], [4.0, 4.0, 4.0]],\n        [[4.0, 4.0, 4.0], [8.0, 8.0, 8.0]]]\n   trsm(A, B, alpha=0.5) = [[[1.0, 1.0, 1.0], [1.0, 1.0, 1.0]],\n                            [[2.0, 2.0, 2.0], [2.0, 2.0, 2.0]]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\la_op.cc:L396",
    "NumArgs": 6,
    "Arguments": [
      {
        "Name": "A",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Tensor of lower triangular matrices"
      },
      {
        "Name": "B",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Tensor of matrices"
      },
      {
        "Name": "transpose",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Use transposed of the triangular matrix"
      },
      {
        "Name": "rightside",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Multiply triangular matrix from the right to non-triangular one."
      },
      {
        "Name": "lower",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "True if the triangular matrix is lower triangular, false if it is upper triangular."
      },
      {
        "Name": "alpha",
        "TypeInfo": "double, optional, default=1",
        "Description": "Scalar factor to be applied to the result."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_linalg_trsm",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_linalg_sumlogdiag",
    "Description": "Computes the sum of the logarithms of the diagonal elements of a square matrix.\nInput is a tensor *A* of dimension *n >= 2*.\n\nIf *n=2*, *A* must be square with positive diagonal entries. We sum the natural\nlogarithms of the diagonal elements, the result has shape (1,).\n\nIf *n>2*, *sumlogdiag* is performed separately on the trailing two dimensions for all\ninputs (batch mode).\n\n.. note:: The operator supports float32 and float64 data types only.\n\nExamples::\n\n   // Single matrix reduction\n   A = [[1.0, 1.0], [1.0, 7.0]]\n   sumlogdiag(A) = [1.9459]\n\n   // Batch matrix reduction\n   A = [[[1.0, 1.0], [1.0, 7.0]], [[3.0, 0], [0, 17.0]]]\n   sumlogdiag(A) = [1.9459, 3.9318]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\la_op.cc:L445",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "A",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Tensor of square matrices"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_linalg_sumlogdiag",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_linalg_extractdiag",
    "Description": "Extracts the diagonal entries of a square matrix.\nInput is a tensor *A* of dimension *n >= 2*.\n\nIf *n=2*, then *A* represents a single square matrix which diagonal elements get extracted as a 1-dimensional tensor.\n\nIf *n>2*, then *A* represents a batch of square matrices on the trailing two dimensions. The extracted diagonals are returned as an *n-1*-dimensional tensor.\n\n.. note:: The operator supports float32 and float64 data types only.\n\nExamples::\n\n    // Single matrix diagonal extraction\n    A = [[1.0, 2.0],\n         [3.0, 4.0]]\n\n    extractdiag(A) = [1.0, 4.0]\n\n    extractdiag(A, 1) = [2.0]\n\n    // Batch matrix diagonal extraction\n    A = [[[1.0, 2.0],\n          [3.0, 4.0]],\n         [[5.0, 6.0],\n          [7.0, 8.0]]]\n\n    extractdiag(A) = [[1.0, 4.0],\n                      [5.0, 8.0]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\la_op.cc:L495",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "A",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Tensor of square matrices"
      },
      {
        "Name": "offset",
        "TypeInfo": "int, optional, default='0'",
        "Description": "Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_linalg_extractdiag",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_linalg_makediag",
    "Description": "Constructs a square matrix with the input as diagonal.\nInput is a tensor *A* of dimension *n >= 1*.\n\nIf *n=1*, then *A* represents the diagonal entries of a single square matrix. This matrix will be returned as a 2-dimensional tensor.\nIf *n>1*, then *A* represents a batch of diagonals of square matrices. The batch of diagonal matrices will be returned as an *n+1*-dimensional tensor.\n\n.. note:: The operator supports float32 and float64 data types only.\n\nExamples::\n\n    // Single diagonal matrix construction\n    A = [1.0, 2.0]\n\n    makediag(A)    = [[1.0, 0.0],\n                      [0.0, 2.0]]\n\n    makediag(A, 1) = [[0.0, 1.0, 0.0],\n                      [0.0, 0.0, 2.0],\n                      [0.0, 0.0, 0.0]]\n\n    // Batch diagonal matrix construction\n    A = [[1.0, 2.0],\n         [3.0, 4.0]]\n\n    makediag(A) = [[[1.0, 0.0],\n                    [0.0, 2.0]],\n                   [[3.0, 0.0],\n                    [0.0, 4.0]]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\la_op.cc:L547",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "A",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Tensor of diagonal entries"
      },
      {
        "Name": "offset",
        "TypeInfo": "int, optional, default='0'",
        "Description": "Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_linalg_makediag",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_linalg_extracttrian",
    "Description": "Extracts a triangular sub-matrix from a square matrix.\nInput is a tensor *A* of dimension *n >= 2*.\n\nIf *n=2*, then *A* represents a single square matrix from which a triangular sub-matrix is extracted as a 1-dimensional tensor.\n\nIf *n>2*, then *A* represents a batch of square matrices on the trailing two dimensions. The extracted triangular sub-matrices are returned as an *n-1*-dimensional tensor.\n\nThe *offset* and *lower* parameters determine the triangle to be extracted:\n\n- When *offset = 0* either the lower or upper triangle with respect to the main diagonal is extracted depending on the value of parameter *lower*.\n- When *offset = k > 0* the upper triangle with respect to the k-th diagonal above the main diagonal is extracted. \n- When *offset = k < 0* the lower triangle with respect to the k-th diagonal below the main diagonal is extracted. \n\n.. note:: The operator supports float32 and float64 data types only.\n\nExamples::\n\n    // Single triagonal extraction\n    A = [[1.0, 2.0],\n         [3.0, 4.0]]\n\n    extracttrian(A) = [1.0, 3.0, 4.0]\n    extracttrian(A, lower=False) = [1.0, 2.0, 4.0]\n    extracttrian(A, 1) = [2.0]\n    extracttrian(A, -1) = [3.0]\n\n    // Batch triagonal extraction\n    A = [[[1.0, 2.0],\n          [3.0, 4.0]],\n         [[5.0, 6.0],\n          [7.0, 8.0]]]\n\n    extracttrian(A) = [[1.0, 3.0, 4.0],\n                       [5.0, 7.0, 8.0]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\la_op.cc:L605",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "A",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Tensor of square matrices"
      },
      {
        "Name": "offset",
        "TypeInfo": "int, optional, default='0'",
        "Description": "Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal."
      },
      {
        "Name": "lower",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "Refer to the lower triangular matrix if lower=true, refer to the upper otherwise. Only relevant when offset=0"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_linalg_extracttrian",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_linalg_maketrian",
    "Description": "Constructs a square matrix with the input representing a specific triangular sub-matrix.\nThis is basically the inverse of *linalg.extracttrian*. Input is a tensor *A* of dimension *n >= 1*.\n\nIf *n=1*, then *A* represents the entries of a triangular matrix which is lower triangular if *offset<0* or *offset=0*, *lower=true*. The resulting matrix is derived by first constructing the square\nmatrix with the entries outside the triangle set to zero and then adding *offset*-times an additional \ndiagonal with zero entries to the square matrix. \n\nIf *n>1*, then *A* represents a batch of triangular sub-matrices. The batch of corresponding square matrices is returned as an *n+1*-dimensional tensor.\n\n.. note:: The operator supports float32 and float64 data types only.\n\nExamples::\n\n    // Single  matrix construction\n    A = [1.0, 2.0, 3.0]\n\n    maketrian(A)              = [[1.0, 0.0],\n                                 [2.0, 3.0]]\n\n    maketrian(A, lower=false) = [[1.0, 2.0],\n                                 [0.0, 3.0]]\n\n    maketrian(A, offset=1)    = [[0.0, 1.0, 2.0],\n                                 [0.0, 0.0, 3.0],\n                                 [0.0, 0.0, 0.0]]\n    maketrian(A, offset=-1)   = [[0.0, 0.0, 0.0],\n                                 [1.0, 0.0, 0.0],\n                                 [2.0, 3.0, 0.0]]\n\n    // Batch matrix construction\n    A = [[1.0, 2.0, 3.0],\n         [4.0, 5.0, 6.0]]\n\n    maketrian(A)           = [[[1.0, 0.0],\n                               [2.0, 3.0]],\n                              [[4.0, 0.0],\n                               [5.0, 6.0]]]\n\n    maketrian(A, offset=1) = [[[0.0, 1.0, 2.0],\n                               [0.0, 0.0, 3.0],\n                               [0.0, 0.0, 0.0]],\n                              [[0.0, 4.0, 5.0],\n                               [0.0, 0.0, 6.0],\n                               [0.0, 0.0, 0.0]]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\la_op.cc:L673",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "A",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Tensor of triangular matrices stored as vectors"
      },
      {
        "Name": "offset",
        "TypeInfo": "int, optional, default='0'",
        "Description": "Offset of the diagonal versus the main diagonal. 0 corresponds to the main diagonal, a negative/positive value to diagonals below/above the main diagonal."
      },
      {
        "Name": "lower",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "Refer to the lower triangular matrix if lower=true, refer to the upper otherwise. Only relevant when offset=0"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_linalg_maketrian",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_linalg_syrk",
    "Description": "Multiplication of matrix with its transpose.\nInput is a tensor *A* of dimension *n >= 2*.\n\nIf *n=2*, the operator performs the BLAS3 function *syrk*:\n\n  *out* = *alpha* \\* *A* \\* *A*\\ :sup:`T`\n\nif *transpose=False*, or\n\n  *out* = *alpha* \\* *A*\\ :sup:`T` \\ \\* *A*\n\nif *transpose=True*.\n\nIf *n>2*, *syrk* is performed separately on the trailing two dimensions for all\ninputs (batch mode).\n\n.. note:: The operator supports float32 and float64 data types only.\n\nExamples::\n\n   // Single matrix multiply\n   A = [[1., 2., 3.], [4., 5., 6.]]\n   syrk(A, alpha=1., transpose=False)\n            = [[14., 32.],\n               [32., 77.]]\n   syrk(A, alpha=1., transpose=True)\n            = [[17., 22., 27.],\n               [22., 29., 36.],\n               [27., 36., 45.]]\n\n   // Batch matrix multiply\n   A = [[[1., 1.]], [[0.1, 0.1]]]\n   syrk(A, alpha=2., transpose=False) = [[[4.]], [[0.04]]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\la_op.cc:L730",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "A",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Tensor of input matrices"
      },
      {
        "Name": "transpose",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Use transpose of input matrix."
      },
      {
        "Name": "alpha",
        "TypeInfo": "double, optional, default=1",
        "Description": "Scalar factor to be applied to the result."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_linalg_syrk",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_linalg_gelqf",
    "Description": "LQ factorization for general matrix.\nInput is a tensor *A* of dimension *n >= 2*.\n\nIf *n=2*, we compute the LQ factorization (LAPACK *gelqf*, followed by *orglq*). *A*\nmust have shape *(x, y)* with *x <= y*, and must have full rank *=x*. The LQ\nfactorization consists of *L* with shape *(x, x)* and *Q* with shape *(x, y)*, so\nthat:\n\n   *A* = *L* \\* *Q*\n\nHere, *L* is lower triangular (upper triangle equal to zero) with nonzero diagonal,\nand *Q* is row-orthonormal, meaning that\n\n   *Q* \\* *Q*\\ :sup:`T`\n\nis equal to the identity matrix of shape *(x, x)*.\n\nIf *n>2*, *gelqf* is performed separately on the trailing two dimensions for all\ninputs (batch mode).\n\n.. note:: The operator supports float32 and float64 data types only.\n\nExamples::\n\n   // Single LQ factorization\n   A = [[1., 2., 3.], [4., 5., 6.]]\n   Q, L = gelqf(A)\n   Q = [[-0.26726124, -0.53452248, -0.80178373],\n        [0.87287156, 0.21821789, -0.43643578]]\n   L = [[-3.74165739, 0.],\n        [-8.55235974, 1.96396101]]\n\n   // Batch LQ factorization\n   A = [[[1., 2., 3.], [4., 5., 6.]],\n        [[7., 8., 9.], [10., 11., 12.]]]\n   Q, L = gelqf(A)\n   Q = [[[-0.26726124, -0.53452248, -0.80178373],\n         [0.87287156, 0.21821789, -0.43643578]],\n        [[-0.50257071, -0.57436653, -0.64616234],\n         [0.7620735, 0.05862104, -0.64483142]]]\n   L = [[[-3.74165739, 0.],\n         [-8.55235974, 1.96396101]],\n        [[-13.92838828, 0.],\n         [-19.09768702, 0.52758934]]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\la_op.cc:L798",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "A",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Tensor of input matrices to be factorized"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_linalg_gelqf",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_linalg_syevd",
    "Description": "Eigendecomposition for symmetric matrix.\nInput is a tensor *A* of dimension *n >= 2*.\n\nIf *n=2*, *A* must be symmetric, of shape *(x, x)*. We compute the eigendecomposition,\nresulting in the orthonormal matrix *U* of eigenvectors, shape *(x, x)*, and the\nvector *L* of eigenvalues, shape *(x,)*, so that:\n\n   *U* \\* *A* = *diag(L)* \\* *U*\n\nHere:\n\n   *U* \\* *U*\\ :sup:`T` = *U*\\ :sup:`T` \\* *U* = *I*\n\nwhere *I* is the identity matrix. Also, *L(0) <= L(1) <= L(2) <= ...* (ascending order).\n\nIf *n>2*, *syevd* is performed separately on the trailing two dimensions of *A* (batch\nmode). In this case, *U* has *n* dimensions like *A*, and *L* has *n-1* dimensions.\n\n.. note:: The operator supports float32 and float64 data types only.\n\n.. note:: Derivatives for this operator are defined only if *A* is such that all its\n          eigenvalues are distinct, and the eigengaps are not too small. If you need\n          gradients, do not apply this operator to matrices with multiple eigenvalues.\n\nExamples::\n\n   // Single symmetric eigendecomposition\n   A = [[1., 2.], [2., 4.]]\n   U, L = syevd(A)\n   U = [[0.89442719, -0.4472136],\n        [0.4472136, 0.89442719]]\n   L = [0., 5.]\n\n   // Batch symmetric eigendecomposition\n   A = [[[1., 2.], [2., 4.]],\n        [[1., 2.], [2., 5.]]]\n   U, L = syevd(A)\n   U = [[[0.89442719, -0.4472136],\n         [0.4472136, 0.89442719]],\n        [[0.92387953, -0.38268343],\n         [0.38268343, 0.92387953]]]\n   L = [[0., 5.],\n        [0.17157288, 5.82842712]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\la_op.cc:L867",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "A",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Tensor of input matrices to be factorized"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_linalg_syevd",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_linalg_inverse",
    "Description": "Compute the inverse of a matrix.\nInput is a tensor *A* of dimension *n >= 2*.\n\nIf *n=2*, *A* is a square matrix. We compute:\n\n  *out* = *A*\\ :sup:`-1`\n\nIf *n>2*, *inverse* is performed separately on the trailing two dimensions\nfor all inputs (batch mode).\n\n.. note:: The operator supports float32 and float64 data types only.\n\nExamples::\n\n   // Single matrix inversion\n   A = [[1., 4.], [2., 3.]]\n   inverse(A) = [[-0.6, 0.8], [0.4, -0.2]]\n\n   // Batch matrix inversion\n   A = [[[1., 4.], [2., 3.]],\n        [[1., 3.], [2., 4.]]]\n   inverse(A) = [[[-0.6, 0.8], [0.4, -0.2]],\n                 [[-2., 1.5], [1., -0.5]]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\la_op.cc:L917",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "A",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Tensor of square matrix"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_linalg_inverse",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "Reshape",
    "Description": "Reshapes the input array.\n\n.. note:: ``Reshape`` is deprecated, use ``reshape``\n\nGiven an array and a shape, this function returns a copy of the array in the new shape.\nThe shape is a tuple of integers such as (2,3,4). The size of the new shape should be same as the size of the input array.\n\nExample::\n\n  reshape([1,2,3,4], shape=(2,2)) = [[1,2], [3,4]]\n\nSome dimensions of the shape can take special values from the set {0, -1, -2, -3, -4}. The significance of each is explained below:\n\n- ``0``  copy this dimension from the input to the output shape.\n\n  Example::\n\n  - input shape = (2,3,4), shape = (4,0,2), output shape = (4,3,2)\n  - input shape = (2,3,4), shape = (2,0,0), output shape = (2,3,4)\n\n- ``-1`` infers the dimension of the output shape by using the remainder of the input dimensions\n  keeping the size of the new array same as that of the input array.\n  At most one dimension of shape can be -1.\n\n  Example::\n\n  - input shape = (2,3,4), shape = (6,1,-1), output shape = (6,1,4)\n  - input shape = (2,3,4), shape = (3,-1,8), output shape = (3,1,8)\n  - input shape = (2,3,4), shape=(-1,), output shape = (24,)\n\n- ``-2`` copy all/remainder of the input dimensions to the output shape.\n\n  Example::\n\n  - input shape = (2,3,4), shape = (-2,), output shape = (2,3,4)\n  - input shape = (2,3,4), shape = (2,-2), output shape = (2,3,4)\n  - input shape = (2,3,4), shape = (-2,1,1), output shape = (2,3,4,1,1)\n\n- ``-3`` use the product of two consecutive dimensions of the input shape as the output dimension.\n\n  Example::\n\n  - input shape = (2,3,4), shape = (-3,4), output shape = (6,4)\n  - input shape = (2,3,4,5), shape = (-3,-3), output shape = (6,20)\n  - input shape = (2,3,4), shape = (0,-3), output shape = (2,12)\n  - input shape = (2,3,4), shape = (-3,-2), output shape = (6,4)\n\n- ``-4`` split one dimension of the input into two dimensions passed subsequent to -4 in shape (can contain -1).\n\n  Example::\n\n  - input shape = (2,3,4), shape = (-4,1,2,-2), output shape =(1,2,3,4)\n  - input shape = (2,3,4), shape = (2,-4,-1,3,-2), output shape = (2,1,3,4)\n\nIf the argument `reverse` is set to 1, then the special values are inferred from right to left.\n\n  Example::\n\n  - without reverse=1, for input shape = (10,5,4), shape = (-1,0), output shape would be (40,5)\n  - with reverse=1, output shape will be (50,4).\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\matrix_op.cc:L201",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data to reshape."
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "The target shape"
      },
      {
        "Name": "reverse",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If true then the special values are inferred from right to left"
      },
      {
        "Name": "target_shape",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "(Deprecated! Use ``shape`` instead.) Target new shape. One and only one dim can be 0, in which case it will be inferred from the rest of dims"
      },
      {
        "Name": "keep_highest",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "(Deprecated! Use ``shape`` instead.) Whether keep the highest dim unchanged.If set to true, then the first dim in target_shape is ignored,and always fixed as input"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "transpose",
    "Description": "Permutes the dimensions of an array.\n\nExamples::\n\n  x = [[ 1, 2],\n       [ 3, 4]]\n\n  transpose(x) = [[ 1.,  3.],\n                  [ 2.,  4.]]\n\n  x = [[[ 1.,  2.],\n        [ 3.,  4.]],\n\n       [[ 5.,  6.],\n        [ 7.,  8.]]]\n\n  transpose(x) = [[[ 1.,  5.],\n                   [ 3.,  7.]],\n\n                  [[ 2.,  6.],\n                   [ 4.,  8.]]]\n\n  transpose(x, axes=(1,0,2)) = [[[ 1.,  2.],\n                                 [ 5.,  6.]],\n\n                                [[ 3.,  4.],\n                                 [ 7.,  8.]]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\matrix_op.cc:L377",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Source input"
      },
      {
        "Name": "axes",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "Target axis order. By default the axes will be inverted."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "expand_dims",
    "Description": "Inserts a new axis of size 1 into the array shape\n\nFor example, given ``x`` with shape ``(2,3,4)``, then ``expand_dims(x, axis=1)``\nwill return a new array with shape ``(2,1,3,4)``.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\matrix_op.cc:L418",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Source input"
      },
      {
        "Name": "axis",
        "TypeInfo": "int, required",
        "Description": "Position where new axis is to be inserted. Suppose that the input `NDArray`'s dimension is `ndim`, the range of the inserted axis is `[-ndim, ndim]`"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "slice",
    "Description": "Slices a region of the array.\n\n.. note:: ``crop`` is deprecated. Use ``slice`` instead.\n\nThis function returns a sliced array between the indices given\nby `begin` and `end` with the corresponding `step`.\n\nFor an input array of ``shape=(d_0, d_1, ..., d_n-1)``,\nslice operation with ``begin=(b_0, b_1...b_m-1)``,\n``end=(e_0, e_1, ..., e_m-1)``, and ``step=(s_0, s_1, ..., s_m-1)``,\nwhere m <= n, results in an array with the shape\n``(|e_0-b_0|/|s_0|, ..., |e_m-1-b_m-1|/|s_m-1|, d_m, ..., d_n-1)``.\n\nThe resulting array's *k*-th dimension contains elements\nfrom the *k*-th dimension of the input array starting\nfrom index ``b_k`` (inclusive) with step ``s_k``\nuntil reaching ``e_k`` (exclusive).\n\nIf the *k*-th elements are `None` in the sequence of `begin`, `end`,\nand `step`, the following rule will be used to set default values.\nIf `s_k` is `None`, set `s_k=1`. If `s_k > 0`, set `b_k=0`, `e_k=d_k`;\nelse, set `b_k=d_k-1`, `e_k=-1`.\n\nThe storage type of ``slice`` output depends on storage types of inputs\n\n- slice(csr) = csr\n- otherwise, ``slice`` generates output with default storage\n\n.. note:: When input data storage type is csr, it only supports\n   step=(), or step=(None,), or step=(1,) to generate a csr output.\n   For other step parameter values, it falls back to slicing\n   a dense tensor.\n\nExample::\n\n  x = [[  1.,   2.,   3.,   4.],\n       [  5.,   6.,   7.,   8.],\n       [  9.,  10.,  11.,  12.]]\n\n  slice(x, begin=(0,1), end=(2,4)) = [[ 2.,  3.,  4.],\n                                     [ 6.,  7.,  8.]]\n  slice(x, begin=(None, 0), end=(None, 3), step=(-1, 2)) = [[9., 11.],\n                                                            [5.,  7.],\n                                                            [1.,  3.]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\matrix_op.cc:L508",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Source input"
      },
      {
        "Name": "begin",
        "TypeInfo": "Shape(tuple), required",
        "Description": "starting indices for the slice operation, supports negative indices."
      },
      {
        "Name": "end",
        "TypeInfo": "Shape(tuple), required",
        "Description": "ending indices for the slice operation, supports negative indices."
      },
      {
        "Name": "step",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "step for the slice operation, supports negative values."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_slice",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_slice_assign",
    "Description": "Assign the rhs to a cropped subset of lhs.\n\nRequirements\n------------\n- output should be explicitly given and be the same as lhs.\n- lhs and rhs are of the same data type, and on the same device.\n\n\nFrom:C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\matrix_op.cc:537",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Source input"
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "value to assign"
      },
      {
        "Name": "begin",
        "TypeInfo": "Shape(tuple), required",
        "Description": "starting indices for the slice operation, supports negative indices."
      },
      {
        "Name": "end",
        "TypeInfo": "Shape(tuple), required",
        "Description": "ending indices for the slice operation, supports negative indices."
      },
      {
        "Name": "step",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "step for the slice operation, supports negative values."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_slice_assign_scalar",
    "Description": "(Assign the scalar to a cropped subset of the input.\n\nRequirements\n------------\n- output should be explicitly given and be the same as input\n)\n\nFrom:C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\matrix_op.cc:562",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Source input"
      },
      {
        "Name": "scalar",
        "TypeInfo": "double, optional, default=0",
        "Description": "The scalar value for assignment."
      },
      {
        "Name": "begin",
        "TypeInfo": "Shape(tuple), required",
        "Description": "starting indices for the slice operation, supports negative indices."
      },
      {
        "Name": "end",
        "TypeInfo": "Shape(tuple), required",
        "Description": "ending indices for the slice operation, supports negative indices."
      },
      {
        "Name": "step",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "step for the slice operation, supports negative values."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "slice_axis",
    "Description": "Slices along a given axis.\n\nReturns an array slice along a given `axis` starting from the `begin` index\nto the `end` index.\n\nExamples::\n\n  x = [[  1.,   2.,   3.,   4.],\n       [  5.,   6.,   7.,   8.],\n       [  9.,  10.,  11.,  12.]]\n\n  slice_axis(x, axis=0, begin=1, end=3) = [[  5.,   6.,   7.,   8.],\n                                           [  9.,  10.,  11.,  12.]]\n\n  slice_axis(x, axis=1, begin=0, end=2) = [[  1.,   2.],\n                                           [  5.,   6.],\n                                           [  9.,  10.]]\n\n  slice_axis(x, axis=1, begin=-3, end=-1) = [[  2.,   3.],\n                                             [  6.,   7.],\n                                             [ 10.,  11.]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\matrix_op.cc:L598",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Source input"
      },
      {
        "Name": "axis",
        "TypeInfo": "int, required",
        "Description": "Axis along which to be sliced, supports negative indexes."
      },
      {
        "Name": "begin",
        "TypeInfo": "int, required",
        "Description": "The beginning index along the axis to be sliced,  supports negative indexes."
      },
      {
        "Name": "end",
        "TypeInfo": "int or None, required",
        "Description": "The ending index along the axis to be sliced,  supports negative indexes."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_slice_axis",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "slice_like",
    "Description": "Slices a region of the array like the shape of another array.\n\nThis function is similar to ``slice``, however, the `begin` are always `0`s\nand `end` of specific axes are inferred from the second input `shape_like`.\n\nGiven the second `shape_like` input of ``shape=(d_0, d_1, ..., d_n-1)``,\na ``slice_like`` operator with default empty `axes`, it performs the\nfollowing operation:\n\n`` out = slice(input, begin=(0, 0, ..., 0), end=(d_0, d_1, ..., d_n-1))``.\n\nWhen `axes` is not empty, it is used to speficy which axes are being sliced.\n\nGiven a 4-d input data, ``slice_like`` operator with ``axes=(0, 2, -1)``\nwill perform the following operation:\n\n`` out = slice(input, begin=(0, 0, 0, 0), end=(d_0, None, d_2, d_3))``.\n\nNote that it is allowed to have first and second input with different dimensions,\nhowever, you have to make sure the `axes` are specified and not exceeding the\ndimension limits.\n\nFor example, given `input_1` with ``shape=(2,3,4,5)`` and `input_2` with\n``shape=(1,2,3)``, it is not allowed to use:\n\n`` out = slice_like(a, b)`` because ndim of `input_1` is 4, and ndim of `input_2`\nis 3.\n\nThe following is allowed in this situation:\n\n`` out = slice_like(a, b, axes=(0, 2))``\n\nExample::\n\n  x = [[  1.,   2.,   3.,   4.],\n       [  5.,   6.,   7.,   8.],\n       [  9.,  10.,  11.,  12.]]\n\n  y = [[  0.,   0.,   0.],\n       [  0.,   0.,   0.]]\n\n  slice_like(x, y) = [[ 1.,  2.,  3.]\n                      [ 5.,  6.,  7.]]\n  slice_like(x, y, axes=(0, 1)) = [[ 1.,  2.,  3.]\n                                   [ 5.,  6.,  7.]]\n  slice_like(x, y, axes=(0)) = [[ 1.,  2.,  3.,  4.]\n                                [ 5.,  6.,  7.,  8.]]\n  slice_like(x, y, axes=(-1)) = [[  1.,   2.,   3.]\n                                 [  5.,   6.,   7.]\n                                 [  9.,  10.,  11.]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\matrix_op.cc:L667",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Source input"
      },
      {
        "Name": "shape_like",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Shape like input"
      },
      {
        "Name": "axes",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "List of axes on which input data will be sliced according to the corresponding size of the second input. By default will slice on all axes. Negative axes are supported."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_slice_like",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "clip",
    "Description": "Clips (limits) the values in an array.\n\nGiven an interval, values outside the interval are clipped to the interval edges.\nClipping ``x`` between `a_min` and `a_x` would be::\n\n   clip(x, a_min, a_max) = max(min(x, a_max), a_min))\n\nExample::\n\n    x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    clip(x,1,8) = [ 1.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  8.]\n\nThe storage type of ``clip`` output depends on storage types of inputs and the a_min, a_max \\\nparameter values:\n\n   - clip(default) = default\n   - clip(row_sparse, a_min <= 0, a_max >= 0) = row_sparse\n   - clip(csr, a_min <= 0, a_max >= 0) = csr\n   - clip(row_sparse, a_min < 0, a_max < 0) = default\n   - clip(row_sparse, a_min > 0, a_max > 0) = default\n   - clip(csr, a_min < 0, a_max < 0) = csr\n   - clip(csr, a_min > 0, a_max > 0) = csr\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\matrix_op.cc:L725",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input array."
      },
      {
        "Name": "a_min",
        "TypeInfo": "float, required",
        "Description": "Minimum value"
      },
      {
        "Name": "a_max",
        "TypeInfo": "float, required",
        "Description": "Maximum value"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_clip",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "repeat",
    "Description": "Repeats elements of an array.\n\nBy default, ``repeat`` flattens the input array into 1-D and then repeats the\nelements::\n\n  x = [[ 1, 2],\n       [ 3, 4]]\n\n  repeat(x, repeats=2) = [ 1.,  1.,  2.,  2.,  3.,  3.,  4.,  4.]\n\nThe parameter ``axis`` specifies the axis along which to perform repeat::\n\n  repeat(x, repeats=2, axis=1) = [[ 1.,  1.,  2.,  2.],\n                                  [ 3.,  3.,  4.,  4.]]\n\n  repeat(x, repeats=2, axis=0) = [[ 1.,  2.],\n                                  [ 1.,  2.],\n                                  [ 3.,  4.],\n                                  [ 3.,  4.]]\n\n  repeat(x, repeats=2, axis=-1) = [[ 1.,  1.,  2.,  2.],\n                                   [ 3.,  3.,  4.,  4.]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\matrix_op.cc:L798",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data array"
      },
      {
        "Name": "repeats",
        "TypeInfo": "int, required",
        "Description": "The number of repetitions for each element."
      },
      {
        "Name": "axis",
        "TypeInfo": "int or None, optional, default='None'",
        "Description": "The axis along which to repeat values. The negative numbers are interpreted counting from the backward. By default, use the flattened input array, and return a flat output array."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_repeat",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "tile",
    "Description": "Repeats the whole array multiple times.\n\nIf ``reps`` has length *d*, and input array has dimension of *n*. There are\nthree cases:\n\n- **n=d**. Repeat *i*-th dimension of the input by ``reps[i]`` times::\n\n    x = [[1, 2],\n         [3, 4]]\n\n    tile(x, reps=(2,3)) = [[ 1.,  2.,  1.,  2.,  1.,  2.],\n                           [ 3.,  4.,  3.,  4.,  3.,  4.],\n                           [ 1.,  2.,  1.,  2.,  1.,  2.],\n                           [ 3.,  4.,  3.,  4.,  3.,  4.]]\n\n- **n>d**. ``reps`` is promoted to length *n* by pre-pending 1's to it. Thus for\n  an input shape ``(2,3)``, ``repos=(2,)`` is treated as ``(1,2)``::\n\n\n    tile(x, reps=(2,)) = [[ 1.,  2.,  1.,  2.],\n                          [ 3.,  4.,  3.,  4.]]\n\n- **n<d**. The input is promoted to be d-dimensional by prepending new axes. So a\n  shape ``(2,2)`` array is promoted to ``(1,2,2)`` for 3-D replication::\n\n    tile(x, reps=(2,2,3)) = [[[ 1.,  2.,  1.,  2.,  1.,  2.],\n                              [ 3.,  4.,  3.,  4.,  3.,  4.],\n                              [ 1.,  2.,  1.,  2.,  1.,  2.],\n                              [ 3.,  4.,  3.,  4.,  3.,  4.]],\n\n                             [[ 1.,  2.,  1.,  2.,  1.,  2.],\n                              [ 3.,  4.,  3.,  4.,  3.,  4.],\n                              [ 1.,  2.,  1.,  2.,  1.,  2.],\n                              [ 3.,  4.,  3.,  4.,  3.,  4.]]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\matrix_op.cc:L859",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data array"
      },
      {
        "Name": "reps",
        "TypeInfo": "Shape(tuple), required",
        "Description": "The number of times for repeating the tensor a. Each dim size of reps must be a positive integer. If reps has length d, the result will have dimension of max(d, a.ndim); If a.ndim < d, a is promoted to be d-dimensional by prepending new axes. If a.ndim > d, reps is promoted to a.ndim by pre-pending 1's to it."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_tile",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "reverse",
    "Description": "Reverses the order of elements along given axis while preserving array shape.\n\nNote: reverse and flip are equivalent. We use reverse in the following examples.\n\nExamples::\n\n  x = [[ 0.,  1.,  2.,  3.,  4.],\n       [ 5.,  6.,  7.,  8.,  9.]]\n\n  reverse(x, axis=0) = [[ 5.,  6.,  7.,  8.,  9.],\n                        [ 0.,  1.,  2.,  3.,  4.]]\n\n  reverse(x, axis=1) = [[ 4.,  3.,  2.,  1.,  0.],\n                        [ 9.,  8.,  7.,  6.,  5.]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\matrix_op.cc:L900",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data array"
      },
      {
        "Name": "axis",
        "TypeInfo": "Shape(tuple), required",
        "Description": "The axis which to reverse elements."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_reverse",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "stack",
    "Description": "Join a sequence of arrays along a new axis.\n\nThe axis parameter specifies the index of the new axis in the dimensions of the\nresult. For example, if axis=0 it will be the first dimension and if axis=-1 it\nwill be the last dimension.\n\nExamples::\n\n  x = [1, 2]\n  y = [3, 4]\n\n  stack(x, y) = [[1, 2],\n                 [3, 4]]\n  stack(x, y, axis=1) = [[1, 3],\n                         [2, 4]]\n",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "List of arrays to stack"
      },
      {
        "Name": "axis",
        "TypeInfo": "int, optional, default='0'",
        "Description": "The axis in the result array along which the input arrays are stacked."
      },
      {
        "Name": "num_args",
        "TypeInfo": "int, required",
        "Description": "Number of inputs to be stacked."
      }
    ],
    "KeyVarNumArgs": "num_args",
    "ReturnType": null
  },
  {
    "Name": "_backward_stack",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "squeeze",
    "Description": "Remove single-dimensional entries from the shape of an array.\nSame behavior of defining the output tensor shape as numpy.squeeze for the most of cases.\nSee the following note for exception.\n\nExamples::\n\n  data = [[[0], [1], [2]]]\n  squeeze(data) = [0, 1, 2]\n  squeeze(data, axis=0) = [[0], [1], [2]]\n  squeeze(data, axis=2) = [[0, 1, 2]]\n  squeeze(data, axis=(0, 2)) = [0, 1, 2]\n\n.. Note::\n  The output of this operator will keep at least one dimension not removed. For example,\n  squeeze([[[4]]]) = [4], while in numpy.squeeze, the output will become a scalar.\n",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "data to squeeze"
      },
      {
        "Name": "axis",
        "TypeInfo": "Shape or None, optional, default=None",
        "Description": "Selects a subset of the single-dimensional entries in the shape. If an axis is selected with shape entry greater than one, an error is raised."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_squeeze",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "depth_to_space",
    "Description": "Rearranges(permutes) data from depth into blocks of spatial data.\nSimilar to ONNX DepthToSpace operator:\nhttps://github.com/onnx/onnx/blob/master/docs/Operators.md#DepthToSpace.\nThe output is a new tensor where the values from depth dimension are moved in spatial blocks \nto height and width dimension. The reverse of this operation is ``space_to_depth``.\n\n.. math::\n\n    \\begin{gather*}\n    x \\prime = reshape(x, [N, block\\_size, block\\_size, C / (block\\_size ^ 2), H * block\\_size, W * block\\_size]) \\\\\n    x \\prime \\prime = transpose(x \\prime, [0, 3, 4, 1, 5, 2]) \\\\\n    y = reshape(x \\prime \\prime, [N, C / (block\\_size ^ 2), H * block\\_size, W * block\\_size])\n    \\end{gather*}\n\nwhere :math:`x` is an input tensor with default layout as :math:`[N, C, H, W]`: [batch, channels, height, width] \nand :math:`y` is the output tensor of layout :math:`[N, C / (block\\_size ^ 2), H * block\\_size, W * block\\_size]`\n\nExample::\n\n  x = [[[[0, 1, 2],\n         [3, 4, 5]],\n        [[6, 7, 8],\n         [9, 10, 11]],\n        [[12, 13, 14],\n         [15, 16, 17]],\n        [[18, 19, 20],\n         [21, 22, 23]]]]\n\n  depth_to_space(x, 2) = [[[[0, 6, 1, 7, 2, 8],\n                            [12, 18, 13, 19, 14, 20],\n                            [3, 9, 4, 10, 5, 11],\n                            [15, 21, 16, 22, 17, 23]]]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\matrix_op.cc:L1052",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input ndarray"
      },
      {
        "Name": "block_size",
        "TypeInfo": "int, required",
        "Description": "Blocks of [block_size. block_size] are moved"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "space_to_depth",
    "Description": "Rearranges(permutes) blocks of spatial data into depth.\nSimilar to ONNX SpaceToDepth operator:\nhttps://github.com/onnx/onnx/blob/master/docs/Operators.md#SpaceToDepth \n\nThe output is a new tensor where the values from height and width dimension are \nmoved to the depth dimension. The reverse of this operation is ``depth_to_space``.\n\n.. math::\n\n    \\begin{gather*}\n    x \\prime = reshape(x, [N, C, H / block\\_size, block\\_size, W / block\\_size, block\\_size]) \\\\\n    x \\prime \\prime = transpose(x \\prime, [0, 3, 5, 1, 2, 4]) \\\\\n    y = reshape(x \\prime \\prime, [N, C * (block\\_size ^ 2), H / block\\_size, W / block\\_size])\n    \\end{gather*}\n\nwhere :math:`x` is an input tensor with default layout as :math:`[N, C, H, W]`: [batch, channels, height, width] \nand :math:`y` is the output tensor of layout :math:`[N, C * (block\\_size ^ 2), H / block\\_size, W / block\\_size]`\n\nExample::\n\n  x = [[[[0, 6, 1, 7, 2, 8],\n         [12, 18, 13, 19, 14, 20],\n         [3, 9, 4, 10, 5, 11],\n         [15, 21, 16, 22, 17, 23]]]]\n\n\n  space_to_depth(x, 2) = [[[[0, 1, 2],\n                            [3, 4, 5]],\n                           [[6, 7, 8],\n                            [9, 10, 11]],\n                           [[12, 13, 14],\n                            [15, 16, 17]],\n                           [[18, 19, 20],\n                            [21, 22, 23]]]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\matrix_op.cc:L1106",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input ndarray"
      },
      {
        "Name": "block_size",
        "TypeInfo": "int, required",
        "Description": "Blocks of [block_size. block_size] are moved"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_split_v2",
    "Description": "Splits an array along a particular axis into multiple sub-arrays.\n\nExample::\n\n   x  = [[[ 1.]\n          [ 2.]]\n         [[ 3.]\n          [ 4.]]\n         [[ 5.]\n          [ 6.]]]\n   x.shape = (3, 2, 1)\n\n   y = split_v2(x, axis=1, indices_or_sections=2) // a list of 2 arrays with shape (3, 1, 1)\n   y = [[[ 1.]]\n        [[ 3.]]\n        [[ 5.]]]\n\n       [[[ 2.]]\n        [[ 4.]]\n        [[ 6.]]]\n\n   y[0].shape = (3, 1, 1)\n\n   z = split_v2(x, axis=0, indices_or_sections=3) // a list of 3 arrays with shape (1, 2, 1)\n   z = [[[ 1.]\n         [ 2.]]]\n\n       [[[ 3.]\n         [ 4.]]]\n\n       [[[ 5.]\n         [ 6.]]]\n\n   z[0].shape = (1, 2, 1)\n\n   w = split_v2(x, axis=0, indices_or_sections=(1,)) // a list of 2 arrays with shape [(1, 2, 1), (2, 2, 1)]\n   w = [[[ 1.]\n         [ 2.]]]\n\n       [[[3.]\n         [4.]]\n\n        [[5.]\n         [6.]]]\n\n  w[0].shape = (1, 2, 1)\n  w[1].shape = (2, 2, 1)\n\n`squeeze_axis=True` removes the axis with length 1 from the shapes of the output arrays.\n**Note** that setting `squeeze_axis` to ``1`` removes axis with length 1 only\nalong the `axis` which it is split.\nAlso `squeeze_axis` can be set to true only if ``input.shape[axis] == indices_or_sections``.\n\nExample::\n\n   z = split_v2(x, axis=0, indices_or_sections=3, squeeze_axis=1) // a list of 3 arrays with shape (2, 1)\n   z = [[ 1.]\n        [ 2.]]\n\n       [[ 3.]\n        [ 4.]]\n\n       [[ 5.]\n        [ 6.]]\n   z[0].shape = (2, 1)\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\matrix_op.cc:L1192",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      },
      {
        "Name": "indices",
        "TypeInfo": "Shape(tuple), required",
        "Description": "Indices of splits. The elements should denote the boundaries of at which split is performed along the `axis`."
      },
      {
        "Name": "axis",
        "TypeInfo": "int, optional, default='1'",
        "Description": "Axis along which to split."
      },
      {
        "Name": "squeeze_axis",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If true, Removes the axis with length 1 from the shapes of the output arrays. **Note** that setting `squeeze_axis` to ``true`` removes axis with length 1 only along the `axis` which it is split. Also `squeeze_axis` can be set to ``true`` only if ``input.shape[axis] == num_outputs``."
      },
      {
        "Name": "sections",
        "TypeInfo": "int, optional, default='0'",
        "Description": "Number of sections if equally splitted. Default to 0 which means split by indices."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_split_v2_backward",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "topk",
    "Description": "Returns the top *k* elements in an input array along the given axis.\n The returned elements will be sorted.\n\nExamples::\n\n  x = [[ 0.3,  0.2,  0.4],\n       [ 0.1,  0.3,  0.2]]\n\n  // returns an index of the largest element on last axis\n  topk(x) = [[ 2.],\n             [ 1.]]\n\n  // returns the value of top-2 largest elements on last axis\n  topk(x, ret_typ='value', k=2) = [[ 0.4,  0.3],\n                                   [ 0.3,  0.2]]\n\n  // returns the value of top-2 smallest elements on last axis\n  topk(x, ret_typ='value', k=2, is_ascend=1) = [[ 0.2 ,  0.3],\n                                               [ 0.1 ,  0.2]]\n\n  // returns the value of top-2 largest elements on axis 0\n  topk(x, axis=0, ret_typ='value', k=2) = [[ 0.3,  0.3,  0.4],\n                                           [ 0.1,  0.2,  0.2]]\n\n  // flattens and then returns list of both values and indices\n  topk(x, ret_typ='both', k=2) = [[[ 0.4,  0.3], [ 0.3,  0.2]] ,  [[ 2.,  0.], [ 1.,  2.]]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\ordering_op.cc:L64",
    "NumArgs": 6,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array"
      },
      {
        "Name": "axis",
        "TypeInfo": "int or None, optional, default='-1'",
        "Description": "Axis along which to choose the top k indices. If not given, the flattened array is used. Default is -1."
      },
      {
        "Name": "k",
        "TypeInfo": "int, optional, default='1'",
        "Description": "Number of top elements to select, should be always smaller than or equal to the element number in the given axis. A global sort is performed if set k < 1."
      },
      {
        "Name": "ret_typ",
        "TypeInfo": "{'both', 'indices', 'mask', 'value'},optional, default='indices'",
        "Description": "The return type.\n \"value\" means to return the top k values, \"indices\" means to return the indices of the top k values, \"mask\" means to return a mask array containing 0 and 1. 1 means the top k values. \"both\" means to return a list of both values and indices of top k elements."
      },
      {
        "Name": "is_ascend",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether to choose k largest or k smallest elements. Top K largest elements will be chosen if set to false."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'float16', 'float32', 'float64', 'int32', 'uint8'},optional, default='float32'",
        "Description": "DType of the output indices when ret_typ is \"indices\" or \"both\". An error will be raised if the selected data type cannot precisely represent the indices."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_topk",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "sort",
    "Description": "Returns a sorted copy of an input array along the given axis.\n\nExamples::\n\n  x = [[ 1, 4],\n       [ 3, 1]]\n\n  // sorts along the last axis\n  sort(x) = [[ 1.,  4.],\n             [ 1.,  3.]]\n\n  // flattens and then sorts\n  sort(x) = [ 1.,  1.,  3.,  4.]\n\n  // sorts along the first axis\n  sort(x, axis=0) = [[ 1.,  1.],\n                     [ 3.,  4.]]\n\n  // in a descend order\n  sort(x, is_ascend=0) = [[ 4.,  1.],\n                          [ 3.,  1.]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\ordering_op.cc:L127",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array"
      },
      {
        "Name": "axis",
        "TypeInfo": "int or None, optional, default='-1'",
        "Description": "Axis along which to choose sort the input tensor. If not given, the flattened array is used. Default is -1."
      },
      {
        "Name": "is_ascend",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "Whether to sort in ascending or descending order."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "argsort",
    "Description": "Returns the indices that would sort an input array along the given axis.\n\nThis function performs sorting along the given axis and returns an array of indices having same shape\nas an input array that index data in sorted order.\n\nExamples::\n\n  x = [[ 0.3,  0.2,  0.4],\n       [ 0.1,  0.3,  0.2]]\n\n  // sort along axis -1\n  argsort(x) = [[ 1.,  0.,  2.],\n                [ 0.,  2.,  1.]]\n\n  // sort along axis 0\n  argsort(x, axis=0) = [[ 1.,  0.,  1.]\n                        [ 0.,  1.,  0.]]\n\n  // flatten and then sort\n  argsort(x) = [ 3.,  1.,  5.,  0.,  4.,  2.]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\ordering_op.cc:L177",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array"
      },
      {
        "Name": "axis",
        "TypeInfo": "int or None, optional, default='-1'",
        "Description": "Axis along which to sort the input tensor. If not given, the flattened array is used. Default is -1."
      },
      {
        "Name": "is_ascend",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "Whether to sort in ascending or descending order."
      },
      {
        "Name": "dtype",
        "TypeInfo": "{'float16', 'float32', 'float64', 'int32', 'uint8'},optional, default='float32'",
        "Description": "DType of the output indices. It is only valid when ret_typ is \"indices\" or \"both\". An error will be raised if the selected data type cannot precisely represent the indices."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_ravel_multi_index",
    "Description": "Converts a batch of index arrays into an array of flat indices. The operator follows numpy conventions so a single multi index is given by a column of the input matrix. The leading dimension may be left unspecified by using -1 as placeholder.  \n\nExamples::\n   \n   A = [[3,6,6],[4,5,1]]\n   ravel(A, shape=(7,6)) = [22,41,37]\n   ravel(A, shape=(-1,6)) = [22,41,37]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\ravel.cc:L42",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Batch of multi-indices"
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=None",
        "Description": "Shape of the array into which the multi-indices apply."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_unravel_index",
    "Description": "Converts an array of flat indices into a batch of index arrays. The operator follows numpy conventions so a single multi index is given by a column of the output matrix. The leading dimension may be left unspecified by using -1 as placeholder.  \n\nExamples::\n\n   A = [22,41,37]\n   unravel(A, shape=(7,6)) = [[3,6,6],[4,5,1]]\n   unravel(A, shape=(-1,6)) = [[3,6,6],[4,5,1]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\ravel.cc:L67",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Array of flat indices"
      },
      {
        "Name": "shape",
        "TypeInfo": "Shape(tuple), optional, default=None",
        "Description": "Shape of the array into which the multi-indices apply."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_sparse_retain",
    "Description": "pick rows specified by user input index array from a row sparse matrix\nand save them in the output sparse matrix.\n\nExample::\n\n  data = [[1, 2], [3, 4], [5, 6]]\n  indices = [0, 1, 3]\n  shape = (4, 2)\n  rsp_in = row_sparse(data, indices)\n  to_retain = [0, 3]\n  rsp_out = retain(rsp_in, to_retain)\n  rsp_out.values = [[1, 2], [5, 6]]\n  rsp_out.indices = [0, 3]\n\nThe storage type of ``retain`` output depends on storage types of inputs\n\n- retain(row_sparse, default) = row_sparse\n- otherwise, ``retain`` is not supported\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\sparse_retain.cc:L53",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array for sparse_retain operator."
      },
      {
        "Name": "indices",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The index array of rows ids that will be retained."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_sparse_retain",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_square_sum",
    "Description": "Computes the square sum of array elements over a given axis\nfor row-sparse matrix. This is a temporary solution for fusing ops square and\nsum together for row-sparse matrix to save memory for storing gradients.\nIt will become deprecated once the functionality of fusing operators is finished\nin the future.\n\nExample::\n\n  dns = mx.nd.array([[0, 0], [1, 2], [0, 0], [3, 4], [0, 0]])\n  rsp = dns.tostype('row_sparse')\n  sum = mx.nd._internal._square_sum(rsp, axis=1)\n  sum = [0, 5, 0, 25, 0]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\tensor\\square_sum.cc:L63",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input"
      },
      {
        "Name": "axis",
        "TypeInfo": "Shape or None, optional, default=None",
        "Description": "The axis or axes along which to perform the reduction.\n\n      The default, `axis=()`, will compute over all elements into a\n      scalar array with shape `(1,)`.\n\n      If `axis` is int, a reduction is performed on a particular axis.\n\n      If `axis` is a tuple of ints, a reduction is performed on all the axes\n      specified in the tuple.\n\n      If `exclude` is true, reduction will be performed on the axes that are\n      NOT in axis instead.\n\n      Negative values means indexing from right to left."
      },
      {
        "Name": "keepdims",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If this is set to `True`, the reduced axes are left in the result as dimension with size one."
      },
      {
        "Name": "exclude",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether to perform reduction on axis that are NOT in axis instead."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_square_sum",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_BatchNorm_v1",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "BilinearSampler",
    "Description": "Applies bilinear sampling to input feature map.\n\nBilinear Sampling is the key of  [NIPS2015] \\\"Spatial Transformer Networks\\\". The usage of the operator is very similar to remap function in OpenCV,\nexcept that the operator has the backward pass.\n\nGiven :math:`data` and :math:`grid`, then the output is computed by\n\n.. math::\n  x_{src} = grid[batch, 0, y_{dst}, x_{dst}] \\\\\n  y_{src} = grid[batch, 1, y_{dst}, x_{dst}] \\\\\n  output[batch, channel, y_{dst}, x_{dst}] = G(data[batch, channel, y_{src}, x_{src})\n\n:math:`x_{dst}`, :math:`y_{dst}` enumerate all spatial locations in :math:`output`, and :math:`G()` denotes the bilinear interpolation kernel.\nThe out-boundary points will be padded with zeros.The shape of the output will be (data.shape[0], data.shape[1], grid.shape[2], grid.shape[3]).\n\nThe operator assumes that :math:`data` has 'NCHW' layout and :math:`grid` has been normalized to [-1, 1].\n\nBilinearSampler often cooperates with GridGenerator which generates sampling grids for BilinearSampler.\nGridGenerator supports two kinds of transformation: ``affine`` and ``warp``.\nIf users want to design a CustomOp to manipulate :math:`grid`, please firstly refer to the code of GridGenerator.\n\nExample 1::\n\n  ## Zoom out data two times\n  data = array([[[[1, 4, 3, 6],\n                  [1, 8, 8, 9],\n                  [0, 4, 1, 5],\n                  [1, 0, 1, 3]]]])\n\n  affine_matrix = array([[2, 0, 0],\n                         [0, 2, 0]])\n\n  affine_matrix = reshape(affine_matrix, shape=(1, 6))\n\n  grid = GridGenerator(data=affine_matrix, transform_type='affine', target_shape=(4, 4))\n\n  out = BilinearSampler(data, grid)\n\n  out\n  [[[[ 0,   0,     0,   0],\n     [ 0,   3.5,   6.5, 0],\n     [ 0,   1.25,  2.5, 0],\n     [ 0,   0,     0,   0]]]\n\n\nExample 2::\n\n  ## shift data horizontally by -1 pixel\n\n  data = array([[[[1, 4, 3, 6],\n                  [1, 8, 8, 9],\n                  [0, 4, 1, 5],\n                  [1, 0, 1, 3]]]])\n\n  warp_maxtrix = array([[[[1, 1, 1, 1],\n                          [1, 1, 1, 1],\n                          [1, 1, 1, 1],\n                          [1, 1, 1, 1]],\n                         [[0, 0, 0, 0],\n                          [0, 0, 0, 0],\n                          [0, 0, 0, 0],\n                          [0, 0, 0, 0]]]])\n\n  grid = GridGenerator(data=warp_matrix, transform_type='warp')\n  out = BilinearSampler(data, grid)\n\n  out\n  [[[[ 4,  3,  6,  0],\n     [ 8,  8,  9,  0],\n     [ 4,  1,  5,  0],\n     [ 0,  1,  3,  0]]]\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\bilinear_sampler.cc:L256",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data to the BilinearsamplerOp."
      },
      {
        "Name": "grid",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input grid to the BilinearsamplerOp.grid has two channels: x_src, y_src"
      },
      {
        "Name": "cudnn_off",
        "TypeInfo": "boolean or None, optional, default=None",
        "Description": "whether to turn cudnn off"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_BilinearSampler",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_count_sketch",
    "Description": "Apply CountSketch to input: map a d-dimension data to k-dimension data\"\n\n.. note:: `count_sketch` is only available on GPU.\n\nAssume input data has shape (N, d), sign hash table s has shape (N, d),\nindex hash table h has shape (N, d) and mapping dimension out_dim = k,\neach element in s is either +1 or -1, each element in h is random integer from 0 to k-1.\nThen the operator computs:\n\n.. math::\n   out[h[i]] += data[i] * s[i]\n\nExample::\n\n   out_dim = 5\n   x = [[1.2, 2.5, 3.4],[3.2, 5.7, 6.6]]\n   h = [[0, 3, 4]]\n   s = [[1, -1, 1]]\n   mx.contrib.ndarray.count_sketch(data=x, h=h, s=s, out_dim = 5) = [[1.2, 0, 0, -2.5, 3.4],\n                                                                     [3.2, 0, 0, -5.7, 6.6]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\count_sketch.cc:L67",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data to the CountSketchOp."
      },
      {
        "Name": "h",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The index vector"
      },
      {
        "Name": "s",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The sign vector"
      },
      {
        "Name": "out_dim",
        "TypeInfo": "int, required",
        "Description": "The output dimension."
      },
      {
        "Name": "processing_batch_size",
        "TypeInfo": "int, optional, default='32'",
        "Description": "How many sketch vectors to process at one time."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward__contrib_count_sketch",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_DeformableConvolution",
    "Description": "Compute 2-D deformable convolution on 4-D input.\n\nThe deformable convolution operation is described in https://arxiv.org/abs/1703.06211\n\nFor 2-D deformable convolution, the shapes are\n\n- **data**: *(batch_size, channel, height, width)*\n- **offset**: *(batch_size, num_deformable_group * kernel[0] * kernel[1] * 2, height, width)*\n- **weight**: *(num_filter, channel, kernel[0], kernel[1])*\n- **bias**: *(num_filter,)*\n- **out**: *(batch_size, num_filter, out_height, out_width)*.\n\nDefine::\n\n  f(x,k,p,s,d) = floor((x+2*p-d*(k-1)-1)/s)+1\n\nthen we have::\n\n  out_height=f(height, kernel[0], pad[0], stride[0], dilate[0])\n  out_width=f(width, kernel[1], pad[1], stride[1], dilate[1])\n\nIf ``no_bias`` is set to be true, then the ``bias`` term is ignored.\n\nThe default data ``layout`` is *NCHW*, namely *(batch_size, channle, height,\nwidth)*.\n\nIf ``num_group`` is larger than 1, denoted by *g*, then split the input ``data``\nevenly into *g* parts along the channel axis, and also evenly split ``weight``\nalong the first dimension. Next compute the convolution on the *i*-th part of\nthe data with the *i*-th weight part. The output is obtained by concating all\nthe *g* results.\n\nIf ``num_deformable_group`` is larger than 1, denoted by *dg*, then split the\ninput ``offset`` evenly into *dg* parts along the channel axis, and also evenly\nsplit ``data`` into *dg* parts along the channel axis. Next compute the\ndeformable convolution, apply the *i*-th part of the offset on the *i*-th part\nof the data.\n\n\nBoth ``weight`` and ``bias`` are learnable parameters.\n\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\deformable_convolution.cc:L100",
    "NumArgs": 14,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data to the DeformableConvolutionOp."
      },
      {
        "Name": "offset",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input offset to the DeformableConvolutionOp."
      },
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight matrix."
      },
      {
        "Name": "bias",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Bias parameter."
      },
      {
        "Name": "kernel",
        "TypeInfo": "Shape(tuple), required",
        "Description": "Convolution kernel size: (h, w) or (d, h, w)"
      },
      {
        "Name": "stride",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "Convolution stride: (h, w) or (d, h, w). Defaults to 1 for each dimension."
      },
      {
        "Name": "dilate",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "Convolution dilate: (h, w) or (d, h, w). Defaults to 1 for each dimension."
      },
      {
        "Name": "pad",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "Zero pad for convolution: (h, w) or (d, h, w). Defaults to no padding."
      },
      {
        "Name": "num_filter",
        "TypeInfo": "int, required",
        "Description": "Convolution filter(channel) number"
      },
      {
        "Name": "num_group",
        "TypeInfo": "int, optional, default='1'",
        "Description": "Number of group partitions."
      },
      {
        "Name": "num_deformable_group",
        "TypeInfo": "int, optional, default='1'",
        "Description": "Number of deformable group partitions."
      },
      {
        "Name": "workspace",
        "TypeInfo": "long (non-negative), optional, default=1024",
        "Description": "Maximum temperal workspace allowed for convolution (MB)."
      },
      {
        "Name": "no_bias",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether to disable bias parameter."
      },
      {
        "Name": "layout",
        "TypeInfo": "{None, 'NCDHW', 'NCHW', 'NCW'},optional, default='None'",
        "Description": "Set layout for input, output and weight. Empty for\n    default layout: NCW for 1d, NCHW for 2d and NCDHW for 3d."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward__contrib_DeformableConvolution",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_DeformablePSROIPooling",
    "Description": "Performs deformable position-sensitive region-of-interest pooling on inputs.\nThe DeformablePSROIPooling operation is described in https://arxiv.org/abs/1703.06211 .batch_size will change to the number of region bounding boxes after DeformablePSROIPooling",
    "NumArgs": 11,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "Symbol",
        "Description": "Input data to the pooling operator, a 4D Feature maps"
      },
      {
        "Name": "rois",
        "TypeInfo": "Symbol",
        "Description": "Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]]. (x1, y1) and (x2, y2) are top left and down right corners of designated region of interest. batch_index indicates the index of corresponding image in the input data"
      },
      {
        "Name": "trans",
        "TypeInfo": "Symbol",
        "Description": "transition parameter"
      },
      {
        "Name": "spatial_scale",
        "TypeInfo": "float, required",
        "Description": "Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers"
      },
      {
        "Name": "output_dim",
        "TypeInfo": "int, required",
        "Description": "fix output dim"
      },
      {
        "Name": "group_size",
        "TypeInfo": "int, required",
        "Description": "fix group size"
      },
      {
        "Name": "pooled_size",
        "TypeInfo": "int, required",
        "Description": "fix pooled size"
      },
      {
        "Name": "part_size",
        "TypeInfo": "int, optional, default='0'",
        "Description": "fix part size"
      },
      {
        "Name": "sample_per_part",
        "TypeInfo": "int, optional, default='1'",
        "Description": "fix samples per part"
      },
      {
        "Name": "trans_std",
        "TypeInfo": "float, optional, default=0",
        "Description": "fix transition std"
      },
      {
        "Name": "no_trans",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether to disable trans parameter."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward__contrib_DeformablePSROIPooling",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_fft",
    "Description": "Apply 1D FFT to input\"\n\n.. note:: `fft` is only available on GPU.\n\nCurrently accept 2 input data shapes: (N, d) or (N1, N2, N3, d), data can only be real numbers.\nThe output data has shape: (N, 2*d) or (N1, N2, N3, 2*d). The format is: [real0, imag0, real1, imag1, ...].\n\nExample::\n\n   data = np.random.normal(0,1,(3,4))\n   out = mx.contrib.ndarray.fft(data = mx.nd.array(data,ctx = mx.gpu(0)))\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\fft.cc:L56",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data to the FFTOp."
      },
      {
        "Name": "compute_size",
        "TypeInfo": "int, optional, default='128'",
        "Description": "Maximum size of sub-batch to be forwarded at one time"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward__contrib_fft",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_ifft",
    "Description": "Apply 1D ifft to input\"\n\n.. note:: `ifft` is only available on GPU.\n\nCurrently accept 2 input data shapes: (N, d) or (N1, N2, N3, d). Data is in format: [real0, imag0, real1, imag1, ...].\nLast dimension must be an even number.\nThe output data has shape: (N, d/2) or (N1, N2, N3, d/2). It is only the real part of the result.\n\nExample::\n\n   data = np.random.normal(0,1,(3,4))\n   out = mx.contrib.ndarray.ifft(data = mx.nd.array(data,ctx = mx.gpu(0)))\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\contrib\\ifft.cc:L58",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data to the IFFTOp."
      },
      {
        "Name": "compute_size",
        "TypeInfo": "int, optional, default='128'",
        "Description": "Maximum size of sub-batch to be forwarded at one time"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward__contrib_ifft",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_MultiProposal",
    "Description": "Generate region proposals via RPN",
    "NumArgs": 12,
    "Arguments": [
      {
        "Name": "cls_prob",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Score of how likely proposal is object."
      },
      {
        "Name": "bbox_pred",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "BBox Predicted deltas from anchors for proposals"
      },
      {
        "Name": "im_info",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Image size and scale."
      },
      {
        "Name": "rpn_pre_nms_top_n",
        "TypeInfo": "int, optional, default='6000'",
        "Description": "Number of top scoring boxes to keep before applying NMS to RPN proposals"
      },
      {
        "Name": "rpn_post_nms_top_n",
        "TypeInfo": "int, optional, default='300'",
        "Description": "Number of top scoring boxes to keep after applying NMS to RPN proposals"
      },
      {
        "Name": "threshold",
        "TypeInfo": "float, optional, default=0.699999988",
        "Description": "NMS value, below which to suppress."
      },
      {
        "Name": "rpn_min_size",
        "TypeInfo": "int, optional, default='16'",
        "Description": "Minimum height or width in proposal"
      },
      {
        "Name": "scales",
        "TypeInfo": ", optional, default=[4,8,16,32]",
        "Description": "Used to generate anchor windows by enumerating scales"
      },
      {
        "Name": "ratios",
        "TypeInfo": ", optional, default=[0.5,1,2]",
        "Description": "Used to generate anchor windows by enumerating ratios"
      },
      {
        "Name": "feature_stride",
        "TypeInfo": "int, optional, default='16'",
        "Description": "The size of the receptive field each unit in the convolution layer of the rpn,for example the product of all stride's prior to this layer."
      },
      {
        "Name": "output_score",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Add score to outputs"
      },
      {
        "Name": "iou_loss",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Usage of IoU Loss"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward__contrib_MultiProposal",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_MultiBoxDetection",
    "Description": "Convert multibox detection predictions.",
    "NumArgs": 10,
    "Arguments": [
      {
        "Name": "cls_prob",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Class probabilities."
      },
      {
        "Name": "loc_pred",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Location regression predictions."
      },
      {
        "Name": "anchor",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Multibox prior anchor boxes"
      },
      {
        "Name": "clip",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "Clip out-of-boundary boxes."
      },
      {
        "Name": "threshold",
        "TypeInfo": "float, optional, default=0.00999999978",
        "Description": "Threshold to be a positive prediction."
      },
      {
        "Name": "background_id",
        "TypeInfo": "int, optional, default='0'",
        "Description": "Background id."
      },
      {
        "Name": "nms_threshold",
        "TypeInfo": "float, optional, default=0.5",
        "Description": "Non-maximum suppression threshold."
      },
      {
        "Name": "force_suppress",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Suppress all detections regardless of class_id."
      },
      {
        "Name": "variances",
        "TypeInfo": ", optional, default=[0.1,0.1,0.2,0.2]",
        "Description": "Variances to be decoded from box regression output."
      },
      {
        "Name": "nms_topk",
        "TypeInfo": "int, optional, default='-1'",
        "Description": "Keep maximum top k detections before nms, -1 for no limit."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward__contrib_MultiBoxDetection",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_MultiBoxPrior",
    "Description": "Generate prior(anchor) boxes from data, sizes and ratios.",
    "NumArgs": 6,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data."
      },
      {
        "Name": "sizes",
        "TypeInfo": ", optional, default=[1]",
        "Description": "List of sizes of generated MultiBoxPriores."
      },
      {
        "Name": "ratios",
        "TypeInfo": ", optional, default=[1]",
        "Description": "List of aspect ratios of generated MultiBoxPriores."
      },
      {
        "Name": "clip",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether to clip out-of-boundary boxes."
      },
      {
        "Name": "steps",
        "TypeInfo": ", optional, default=[-1,-1]",
        "Description": "Priorbox step across y and x, -1 for auto calculation."
      },
      {
        "Name": "offsets",
        "TypeInfo": ", optional, default=[0.5,0.5]",
        "Description": "Priorbox center offsets, y and x respectively"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward__contrib_MultiBoxPrior",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_MultiBoxTarget",
    "Description": "Compute Multibox training targets",
    "NumArgs": 9,
    "Arguments": [
      {
        "Name": "anchor",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Generated anchor boxes."
      },
      {
        "Name": "label",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Object detection labels."
      },
      {
        "Name": "cls_pred",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Class predictions."
      },
      {
        "Name": "overlap_threshold",
        "TypeInfo": "float, optional, default=0.5",
        "Description": "Anchor-GT overlap threshold to be regarded as a positive match."
      },
      {
        "Name": "ignore_label",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Label for ignored anchors."
      },
      {
        "Name": "negative_mining_ratio",
        "TypeInfo": "float, optional, default=-1",
        "Description": "Max negative to positive samples ratio, use -1 to disable mining"
      },
      {
        "Name": "negative_mining_thresh",
        "TypeInfo": "float, optional, default=0.5",
        "Description": "Threshold used for negative mining."
      },
      {
        "Name": "minimum_negative_samples",
        "TypeInfo": "int, optional, default='0'",
        "Description": "Minimum number of negative samples."
      },
      {
        "Name": "variances",
        "TypeInfo": ", optional, default=[0.1,0.1,0.2,0.2]",
        "Description": "Variances to be encoded in box regression target."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward__contrib_MultiBoxTarget",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_Proposal",
    "Description": "Generate region proposals via RPN",
    "NumArgs": 12,
    "Arguments": [
      {
        "Name": "cls_prob",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Score of how likely proposal is object."
      },
      {
        "Name": "bbox_pred",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "BBox Predicted deltas from anchors for proposals"
      },
      {
        "Name": "im_info",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Image size and scale."
      },
      {
        "Name": "rpn_pre_nms_top_n",
        "TypeInfo": "int, optional, default='6000'",
        "Description": "Number of top scoring boxes to keep before applying NMS to RPN proposals"
      },
      {
        "Name": "rpn_post_nms_top_n",
        "TypeInfo": "int, optional, default='300'",
        "Description": "Number of top scoring boxes to keep after applying NMS to RPN proposals"
      },
      {
        "Name": "threshold",
        "TypeInfo": "float, optional, default=0.699999988",
        "Description": "NMS value, below which to suppress."
      },
      {
        "Name": "rpn_min_size",
        "TypeInfo": "int, optional, default='16'",
        "Description": "Minimum height or width in proposal"
      },
      {
        "Name": "scales",
        "TypeInfo": ", optional, default=[4,8,16,32]",
        "Description": "Used to generate anchor windows by enumerating scales"
      },
      {
        "Name": "ratios",
        "TypeInfo": ", optional, default=[0.5,1,2]",
        "Description": "Used to generate anchor windows by enumerating ratios"
      },
      {
        "Name": "feature_stride",
        "TypeInfo": "int, optional, default='16'",
        "Description": "The size of the receptive field each unit in the convolution layer of the rpn,for example the product of all stride's prior to this layer."
      },
      {
        "Name": "output_score",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Add score to outputs"
      },
      {
        "Name": "iou_loss",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Usage of IoU Loss"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward__contrib_Proposal",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_contrib_PSROIPooling",
    "Description": "Performs region-of-interest pooling on inputs. Resize bounding box coordinates by spatial_scale and crop input feature maps accordingly. The cropped feature maps are pooled by max pooling to a fixed size output indicated by pooled_size. batch_size will change to the number of region bounding boxes after PSROIPooling",
    "NumArgs": 6,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "Symbol",
        "Description": "Input data to the pooling operator, a 4D Feature maps"
      },
      {
        "Name": "rois",
        "TypeInfo": "Symbol",
        "Description": "Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]]. (x1, y1) and (x2, y2) are top left and down right corners of designated region of interest. batch_index indicates the index of corresponding image in the input data"
      },
      {
        "Name": "spatial_scale",
        "TypeInfo": "float, required",
        "Description": "Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers"
      },
      {
        "Name": "output_dim",
        "TypeInfo": "int, required",
        "Description": "fix output dim"
      },
      {
        "Name": "pooled_size",
        "TypeInfo": "int, required",
        "Description": "fix pooled size"
      },
      {
        "Name": "group_size",
        "TypeInfo": "int, optional, default='0'",
        "Description": "fix group size"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward__contrib_PSROIPooling",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward__contrib_SyncBatchNorm",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "Convolution_v1",
    "Description": "This operator is DEPRECATED. Apply convolution to input then add a bias.",
    "NumArgs": 14,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data to the ConvolutionV1Op."
      },
      {
        "Name": "weight",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Weight matrix."
      },
      {
        "Name": "bias",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Bias parameter."
      },
      {
        "Name": "kernel",
        "TypeInfo": "Shape(tuple), required",
        "Description": "convolution kernel size: (h, w) or (d, h, w)"
      },
      {
        "Name": "stride",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "convolution stride: (h, w) or (d, h, w)"
      },
      {
        "Name": "dilate",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "convolution dilate: (h, w) or (d, h, w)"
      },
      {
        "Name": "pad",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "pad for convolution: (h, w) or (d, h, w)"
      },
      {
        "Name": "num_filter",
        "TypeInfo": "int (non-negative), required",
        "Description": "convolution filter(channel) number"
      },
      {
        "Name": "num_group",
        "TypeInfo": "int (non-negative), optional, default=1",
        "Description": "Number of group partitions. Equivalent to slicing input into num_group\n    partitions, apply convolution on each, then concatenate the results"
      },
      {
        "Name": "workspace",
        "TypeInfo": "long (non-negative), optional, default=1024",
        "Description": "Maximum temporary workspace allowed for convolution (MB).This parameter determines the effective batch size of the convolution kernel, which may be smaller than the given batch size. Also, the workspace will be automatically enlarged to make sure that we can run the kernel with batch_size=1"
      },
      {
        "Name": "no_bias",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether to disable bias parameter."
      },
      {
        "Name": "cudnn_tune",
        "TypeInfo": "{None, 'fastest', 'limited_workspace', 'off'},optional, default='None'",
        "Description": "Whether to pick convolution algo by running performance test.\n    Leads to higher startup time but may give faster speed. Options are:\n    'off': no tuning\n    'limited_workspace': run test and pick the fastest algorithm that doesn't exceed workspace limit.\n    'fastest': pick the fastest algorithm and ignore workspace limit.\n    If set to None (default), behavior is determined by environment\n    variable MXNET_CUDNN_AUTOTUNE_DEFAULT: 0 for off,\n    1 for limited workspace (default), 2 for fastest."
      },
      {
        "Name": "cudnn_off",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Turn off cudnn for this layer."
      },
      {
        "Name": "layout",
        "TypeInfo": "{None, 'NCDHW', 'NCHW', 'NDHWC', 'NHWC'},optional, default='None'",
        "Description": "Set layout for input, output and weight. Empty for\n    default layout: NCHW for 2d and NCDHW for 3d."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_Convolution_v1",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "Correlation",
    "Description": "Applies correlation to inputs.\n\nThe correlation layer performs multiplicative patch comparisons between two feature maps.\n\nGiven two multi-channel feature maps :math:`f_{1}, f_{2}`, with :math:`w`, :math:`h`, and :math:`c` being their width, height, and number of channels,\nthe correlation layer lets the network compare each patch from :math:`f_{1}` with each patch from :math:`f_{2}`.\n\nFor now we consider only a single comparison of two patches. The 'correlation' of two patches centered at :math:`x_{1}` in the first map and\n:math:`x_{2}` in the second map is then defined as:\n\n.. math::\n\n   c(x_{1}, x_{2}) = \\sum_{o \\in [-k,k] \\times [-k,k]} <f_{1}(x_{1} + o), f_{2}(x_{2} + o)>\n\nfor a square patch of size :math:`K:=2k+1`.\n\nNote that the equation above is identical to one step of a convolution in neural networks, but instead of convolving data with a filter, it convolves data with other\ndata. For this reason, it has no training weights.\n\nComputing :math:`c(x_{1}, x_{2})` involves :math:`c * K^{2}` multiplications. Comparing all patch combinations involves :math:`w^{2}*h^{2}` such computations.\n\nGiven a maximum displacement :math:`d`, for each location :math:`x_{1}` it computes correlations :math:`c(x_{1}, x_{2})` only in a neighborhood of size :math:`D:=2d+1`,\nby limiting the range of :math:`x_{2}`. We use strides :math:`s_{1}, s_{2}`, to quantize :math:`x_{1}` globally and to quantize :math:`x_{2}` within the neighborhood\ncentered around :math:`x_{1}`.\n\nThe final output is defined by the following expression:\n\n.. math::\n  out[n, q, i, j] = c(x_{i, j}, x_{q})\n\nwhere :math:`i` and :math:`j` enumerate spatial locations in :math:`f_{1}`, and :math:`q` denotes the :math:`q^{th}` neighborhood of :math:`x_{i,j}`.\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\correlation.cc:L198",
    "NumArgs": 8,
    "Arguments": [
      {
        "Name": "data1",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data1 to the correlation."
      },
      {
        "Name": "data2",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data2 to the correlation."
      },
      {
        "Name": "kernel_size",
        "TypeInfo": "int (non-negative), optional, default=1",
        "Description": "kernel size for Correlation must be an odd number"
      },
      {
        "Name": "max_displacement",
        "TypeInfo": "int (non-negative), optional, default=1",
        "Description": "Max displacement of Correlation "
      },
      {
        "Name": "stride1",
        "TypeInfo": "int (non-negative), optional, default=1",
        "Description": "stride1 quantize data1 globally"
      },
      {
        "Name": "stride2",
        "TypeInfo": "int (non-negative), optional, default=1",
        "Description": "stride2 quantize data2 within the neighborhood centered around data1"
      },
      {
        "Name": "pad_size",
        "TypeInfo": "int (non-negative), optional, default=0",
        "Description": "pad for Correlation"
      },
      {
        "Name": "is_multiply",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "operation type is either multiplication or subduction"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_Correlation",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "Crop",
    "Description": "\n\n.. note:: `Crop` is deprecated. Use `slice` instead.\n\nCrop the 2nd and 3rd dim of input data, with the corresponding size of h_w or\nwith width and height of the second input symbol, i.e., with one input, we need h_w to\nspecify the crop height and width, otherwise the second input symbol's size will be used\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\crop.cc:L50",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "Symbol or Symbol[]",
        "Description": "Tensor or List of Tensors, the second input will be used as crop_like shape reference"
      },
      {
        "Name": "num_args",
        "TypeInfo": "int, required",
        "Description": "Number of inputs for crop, if equals one, then we will use the h_wfor crop height and width, else if equals two, then we will use the heightand width of the second input symbol, we name crop_like here"
      },
      {
        "Name": "offset",
        "TypeInfo": "Shape(tuple), optional, default=[0,0]",
        "Description": "crop offset coordinate: (y, x)"
      },
      {
        "Name": "h_w",
        "TypeInfo": "Shape(tuple), optional, default=[0,0]",
        "Description": "crop height and width: (h, w)"
      },
      {
        "Name": "center_crop",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If set to true, then it will use be the center_crop,or it will crop using the shape of crop_like"
      }
    ],
    "KeyVarNumArgs": "num_args",
    "ReturnType": null
  },
  {
    "Name": "_backward_Crop",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_CrossDeviceCopy",
    "Description": "Special op to copy data cross device",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward__CrossDeviceCopy",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_Native",
    "Description": "Stub for implementing an operator implemented in native frontend language.",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "Input data for the custom operator."
      },
      {
        "Name": "info",
        "TypeInfo": "ptr, required",
        "Description": ""
      },
      {
        "Name": "need_top_grad",
        "TypeInfo": "boolean, optional, default=1",
        "Description": "Whether this layer needs out grad for backward. Should be false for loss layers."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward__Native",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_NDArray",
    "Description": "Stub for implementing an operator implemented in native frontend language with ndarray.",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol[]",
        "Description": "Input data for the custom operator."
      },
      {
        "Name": "info",
        "TypeInfo": "ptr, required",
        "Description": ""
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward__NDArray",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "GridGenerator",
    "Description": "Generates 2D sampling grid for bilinear sampling.",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data to the function."
      },
      {
        "Name": "transform_type",
        "TypeInfo": "{'affine', 'warp'}, required",
        "Description": "The type of transformation. For `affine`, input data should be an affine matrix of size (batch, 6). For `warp`, input data should be an optical flow of size (batch, 2, h, w)."
      },
      {
        "Name": "target_shape",
        "TypeInfo": "Shape(tuple), optional, default=[0,0]",
        "Description": "Specifies the output shape (H, W). This is required if transformation type is `affine`. If transformation type is `warp`, this parameter is ignored."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_GridGenerator",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_IdentityAttachKLSparseReg",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "InstanceNorm",
    "Description": "Applies instance normalization to the n-dimensional input array.\n\nThis operator takes an n-dimensional input array where (n>2) and normalizes\nthe input using the following formula:\n\n.. math::\n\n  out = \\frac{x - mean[data]}{ \\sqrt{Var[data]} + \\epsilon} * gamma + beta\n\nThis layer is similar to batch normalization layer (`BatchNorm`)\nwith two differences: first, the normalization is\ncarried out per example (instance), not over a batch. Second, the\nsame normalization is applied both at test and train time. This\noperation is also known as `contrast normalization`.\n\nIf the input data is of shape [batch, channel, spacial_dim1, spacial_dim2, ...],\n`gamma` and `beta` parameters must be vectors of shape [channel].\n\nThis implementation is based on paper:\n\n.. [1] Instance Normalization: The Missing Ingredient for Fast Stylization,\n   D. Ulyanov, A. Vedaldi, V. Lempitsky, 2016 (arXiv:1607.08022v2).\n\nExamples::\n\n  // Input of shape (2,1,2)\n  x = [[[ 1.1,  2.2]],\n       [[ 3.3,  4.4]]]\n\n  // gamma parameter of length 1\n  gamma = [1.5]\n\n  // beta parameter of length 1\n  beta = [0.5]\n\n  // Instance normalization is calculated with the above formula\n  InstanceNorm(x,gamma,beta) = [[[-0.997527  ,  1.99752665]],\n                                [[-0.99752653,  1.99752724]]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\instance_norm.cc:L95",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "An n-dimensional input array (n > 2) of the form [batch, channel, spatial_dim1, spatial_dim2, ...]."
      },
      {
        "Name": "gamma",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "A vector of length 'channel', which multiplies the normalized input."
      },
      {
        "Name": "beta",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "A vector of length 'channel', which is added to the product of the normalized input and the weight."
      },
      {
        "Name": "eps",
        "TypeInfo": "float, optional, default=0.00100000005",
        "Description": "An `epsilon` parameter to prevent division by 0."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_InstanceNorm",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "L2Normalization",
    "Description": "Normalize the input array using the L2 norm.\n\nFor 1-D NDArray, it computes::\n\n  out = data / sqrt(sum(data ** 2) + eps)\n\nFor N-D NDArray, if the input array has shape (N, N, ..., N),\n\nwith ``mode`` = ``instance``, it normalizes each instance in the multidimensional\narray by its L2 norm.::\n\n  for i in 0...N\n    out[i,:,:,...,:] = data[i,:,:,...,:] / sqrt(sum(data[i,:,:,...,:] ** 2) + eps)\n\nwith ``mode`` = ``channel``, it normalizes each channel in the array by its L2 norm.::\n\n  for i in 0...N\n    out[:,i,:,...,:] = data[:,i,:,...,:] / sqrt(sum(data[:,i,:,...,:] ** 2) + eps)\n\nwith ``mode`` = ``spatial``, it normalizes the cross channel norm for each position\nin the array by its L2 norm.::\n\n  for dim in 2...N\n    for i in 0...N\n      out[.....,i,...] = take(out, indices=i, axis=dim) / sqrt(sum(take(out, indices=i, axis=dim) ** 2) + eps)\n          -dim-\n\nExample::\n\n  x = [[[1,2],\n        [3,4]],\n       [[2,2],\n        [5,6]]]\n\n  L2Normalization(x, mode='instance')\n  =[[[ 0.18257418  0.36514837]\n     [ 0.54772252  0.73029673]]\n    [[ 0.24077171  0.24077171]\n     [ 0.60192931  0.72231513]]]\n\n  L2Normalization(x, mode='channel')\n  =[[[ 0.31622776  0.44721359]\n     [ 0.94868326  0.89442718]]\n    [[ 0.37139067  0.31622776]\n     [ 0.92847669  0.94868326]]]\n\n  L2Normalization(x, mode='spatial')\n  =[[[ 0.44721359  0.89442718]\n     [ 0.60000002  0.80000001]]\n    [[ 0.70710677  0.70710677]\n     [ 0.6401844   0.76822126]]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\l2_normalization.cc:L196",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input array to normalize."
      },
      {
        "Name": "eps",
        "TypeInfo": "float, optional, default=1.00000001e-10",
        "Description": "A small constant for numerical stability."
      },
      {
        "Name": "mode",
        "TypeInfo": "{'channel', 'instance', 'spatial'},optional, default='instance'",
        "Description": "Specify the dimension along which to compute L2 norm."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_L2Normalization",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_LeakyReLU",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "MakeLoss",
    "Description": "Make your own loss function in network construction.\n\nThis operator accepts a customized loss function symbol as a terminal loss and\nthe symbol should be an operator with no backward dependency.\nThe output of this function is the gradient of loss with respect to the input data.\n\nFor example, if you are a making a cross entropy loss function. Assume ``out`` is the\npredicted output and ``label`` is the true label, then the cross entropy can be defined as::\n\n  cross_entropy = label * log(out) + (1 - label) * log(1 - out)\n  loss = MakeLoss(cross_entropy)\n\nWe will need to use ``MakeLoss`` when we are creating our own loss function or we want to\ncombine multiple loss functions. Also we may want to stop some variables' gradients\nfrom backpropagation. See more detail in ``BlockGrad`` or ``stop_gradient``.\n\nIn addition, we can give a scale to the loss by setting ``grad_scale``,\nso that the gradient of the loss will be rescaled in the backpropagation.\n\n.. note:: This operator should be used as a Symbol instead of NDArray.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\make_loss.cc:L71",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input array."
      },
      {
        "Name": "grad_scale",
        "TypeInfo": "float, optional, default=1",
        "Description": "Gradient scale as a supplement to unary and binary operators"
      },
      {
        "Name": "valid_thresh",
        "TypeInfo": "float, optional, default=0",
        "Description": "clip each element in the array to 0 when it is less than ``valid_thresh``. This is used when ``normalization`` is set to ``'valid'``."
      },
      {
        "Name": "normalization",
        "TypeInfo": "{'batch', 'null', 'valid'},optional, default='null'",
        "Description": "If this is set to null, the output gradient will not be normalized. If this is set to batch, the output gradient will be divided by the batch size. If this is set to valid, the output gradient will be divided by the number of valid input elements."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_MakeLoss",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_Pad",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "Pooling_v1",
    "Description": "This operator is DEPRECATED.\nPerform pooling on the input.\n\nThe shapes for 2-D pooling is\n\n- **data**: *(batch_size, channel, height, width)*\n- **out**: *(batch_size, num_filter, out_height, out_width)*, with::\n\n    out_height = f(height, kernel[0], pad[0], stride[0])\n    out_width = f(width, kernel[1], pad[1], stride[1])\n\nThe definition of *f* depends on ``pooling_convention``, which has two options:\n\n- **valid** (default)::\n\n    f(x, k, p, s) = floor((x+2*p-k)/s)+1\n\n- **full**, which is compatible with Caffe::\n\n    f(x, k, p, s) = ceil((x+2*p-k)/s)+1\n\nBut ``global_pool`` is set to be true, then do a global pooling, namely reset\n``kernel=(height, width)``.\n\nThree pooling options are supported by ``pool_type``:\n\n- **avg**: average pooling\n- **max**: max pooling\n- **sum**: sum pooling\n\n1-D pooling is special case of 2-D pooling with *weight=1* and\n*kernel[1]=1*.\n\nFor 3-D pooling, an additional *depth* dimension is added before\n*height*. Namely the input data will have shape *(batch_size, channel, depth,\nheight, width)*.\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\pooling_v1.cc:L104",
    "NumArgs": 7,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data to the pooling operator."
      },
      {
        "Name": "kernel",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "pooling kernel size: (y, x) or (d, y, x)"
      },
      {
        "Name": "pool_type",
        "TypeInfo": "{'avg', 'max', 'sum'},optional, default='max'",
        "Description": "Pooling type to be applied."
      },
      {
        "Name": "global_pool",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Ignore kernel size, do global pooling based on current input feature map. "
      },
      {
        "Name": "pooling_convention",
        "TypeInfo": "{'full', 'valid'},optional, default='valid'",
        "Description": "Pooling convention to be applied."
      },
      {
        "Name": "stride",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "stride: for pooling (y, x) or (d, y, x)"
      },
      {
        "Name": "pad",
        "TypeInfo": "Shape(tuple), optional, default=[]",
        "Description": "pad for pooling: (y, x) or (d, y, x)"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_Pooling_v1",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "ROIPooling",
    "Description": "Performs region of interest(ROI) pooling on the input array.\n\nROI pooling is a variant of a max pooling layer, in which the output size is fixed and\nregion of interest is a parameter. Its purpose is to perform max pooling on the inputs\nof non-uniform sizes to obtain fixed-size feature maps. ROI pooling is a neural-net\nlayer mostly used in training a `Fast R-CNN` network for object detection.\n\nThis operator takes a 4D feature map as an input array and region proposals as `rois`,\nthen it pools over sub-regions of input and produces a fixed-sized output array\nregardless of the ROI size.\n\nTo crop the feature map accordingly, you can resize the bounding box coordinates\nby changing the parameters `rois` and `spatial_scale`.\n\nThe cropped feature maps are pooled by standard max pooling operation to a fixed size output\nindicated by a `pooled_size` parameter. batch_size will change to the number of region\nbounding boxes after `ROIPooling`.\n\nThe size of each region of interest doesn't have to be perfectly divisible by\nthe number of pooling sections(`pooled_size`).\n\nExample::\n\n  x = [[[[  0.,   1.,   2.,   3.,   4.,   5.],\n         [  6.,   7.,   8.,   9.,  10.,  11.],\n         [ 12.,  13.,  14.,  15.,  16.,  17.],\n         [ 18.,  19.,  20.,  21.,  22.,  23.],\n         [ 24.,  25.,  26.,  27.,  28.,  29.],\n         [ 30.,  31.,  32.,  33.,  34.,  35.],\n         [ 36.,  37.,  38.,  39.,  40.,  41.],\n         [ 42.,  43.,  44.,  45.,  46.,  47.]]]]\n\n  // region of interest i.e. bounding box coordinates.\n  y = [[0,0,0,4,4]]\n\n  // returns array of shape (2,2) according to the given roi with max pooling.\n  ROIPooling(x, y, (2,2), 1.0) = [[[[ 14.,  16.],\n                                    [ 26.,  28.]]]]\n\n  // region of interest is changed due to the change in `spacial_scale` parameter.\n  ROIPooling(x, y, (2,2), 0.7) = [[[[  7.,   9.],\n                                    [ 19.,  21.]]]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\roi_pooling.cc:L295",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "The input array to the pooling operator,  a 4D Feature maps "
      },
      {
        "Name": "rois",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Bounding box coordinates, a 2D array of [[batch_index, x1, y1, x2, y2]], where (x1, y1) and (x2, y2) are top left and bottom right corners of designated region of interest. `batch_index` indicates the index of corresponding image in the input array"
      },
      {
        "Name": "pooled_size",
        "TypeInfo": "Shape(tuple), required",
        "Description": "ROI pooling output shape (h,w) "
      },
      {
        "Name": "spatial_scale",
        "TypeInfo": "float, required",
        "Description": "Ratio of input feature map height (or w) to raw image height (or w). Equals the reciprocal of total stride in convolutional layers"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_ROIPooling",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "SequenceLast",
    "Description": "Takes the last element of a sequence.\n\nThis function takes an n-dimensional input array of the form\n[max_sequence_length, batch_size, other_feature_dims] and returns a (n-1)-dimensional array\nof the form [batch_size, other_feature_dims].\n\nParameter `sequence_length` is used to handle variable-length sequences. `sequence_length` should be\nan input array of positive ints of dimension [batch_size]. To use this parameter,\nset `use_sequence_length` to `True`, otherwise each example in the batch is assumed\nto have the max sequence length.\n\n.. note:: Alternatively, you can also use `take` operator.\n\nExample::\n\n   x = [[[  1.,   2.,   3.],\n         [  4.,   5.,   6.],\n         [  7.,   8.,   9.]],\n\n        [[ 10.,   11.,   12.],\n         [ 13.,   14.,   15.],\n         [ 16.,   17.,   18.]],\n\n        [[  19.,   20.,   21.],\n         [  22.,   23.,   24.],\n         [  25.,   26.,   27.]]]\n\n   // returns last sequence when sequence_length parameter is not used\n   SequenceLast(x) = [[  19.,   20.,   21.],\n                      [  22.,   23.,   24.],\n                      [  25.,   26.,   27.]]\n\n   // sequence_length is used\n   SequenceLast(x, sequence_length=[1,1,1], use_sequence_length=True) =\n            [[  1.,   2.,   3.],\n             [  4.,   5.,   6.],\n             [  7.,   8.,   9.]]\n\n   // sequence_length is used\n   SequenceLast(x, sequence_length=[1,2,3], use_sequence_length=True) =\n            [[  1.,    2.,   3.],\n             [  13.,  14.,  15.],\n             [  25.,  26.,  27.]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\sequence_last.cc:L100",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims] where n>2"
      },
      {
        "Name": "sequence_length",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "vector of sequence lengths of the form [batch_size]"
      },
      {
        "Name": "use_sequence_length",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence"
      },
      {
        "Name": "axis",
        "TypeInfo": "int, optional, default='0'",
        "Description": "The sequence axis. Only values of 0 and 1 are currently supported."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_SequenceLast",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "SequenceMask",
    "Description": "Sets all elements outside the sequence to a constant value.\n\nThis function takes an n-dimensional input array of the form\n[max_sequence_length, batch_size, other_feature_dims] and returns an array of the same shape.\n\nParameter `sequence_length` is used to handle variable-length sequences. `sequence_length`\nshould be an input array of positive ints of dimension [batch_size].\nTo use this parameter, set `use_sequence_length` to `True`,\notherwise each example in the batch is assumed to have the max sequence length and\nthis operator works as the `identity` operator.\n\nExample::\n\n   x = [[[  1.,   2.,   3.],\n         [  4.,   5.,   6.]],\n\n        [[  7.,   8.,   9.],\n         [ 10.,  11.,  12.]],\n\n        [[ 13.,  14.,   15.],\n         [ 16.,  17.,   18.]]]\n\n   // Batch 1\n   B1 = [[  1.,   2.,   3.],\n         [  7.,   8.,   9.],\n         [ 13.,  14.,  15.]]\n\n   // Batch 2\n   B2 = [[  4.,   5.,   6.],\n         [ 10.,  11.,  12.],\n         [ 16.,  17.,  18.]]\n\n   // works as identity operator when sequence_length parameter is not used\n   SequenceMask(x) = [[[  1.,   2.,   3.],\n                       [  4.,   5.,   6.]],\n\n                      [[  7.,   8.,   9.],\n                       [ 10.,  11.,  12.]],\n\n                      [[ 13.,  14.,   15.],\n                       [ 16.,  17.,   18.]]]\n\n   // sequence_length [1,1] means 1 of each batch will be kept\n   // and other rows are masked with default mask value = 0\n   SequenceMask(x, sequence_length=[1,1], use_sequence_length=True) =\n                [[[  1.,   2.,   3.],\n                  [  4.,   5.,   6.]],\n\n                 [[  0.,   0.,   0.],\n                  [  0.,   0.,   0.]],\n\n                 [[  0.,   0.,   0.],\n                  [  0.,   0.,   0.]]]\n\n   // sequence_length [2,3] means 2 of batch B1 and 3 of batch B2 will be kept\n   // and other rows are masked with value = 1\n   SequenceMask(x, sequence_length=[2,3], use_sequence_length=True, value=1) =\n                [[[  1.,   2.,   3.],\n                  [  4.,   5.,   6.]],\n\n                 [[  7.,   8.,   9.],\n                  [  10.,  11.,  12.]],\n\n                 [[   1.,   1.,   1.],\n                  [  16.,  17.,  18.]]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\sequence_mask.cc:L186",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims] where n>2"
      },
      {
        "Name": "sequence_length",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "vector of sequence lengths of the form [batch_size]"
      },
      {
        "Name": "use_sequence_length",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence"
      },
      {
        "Name": "value",
        "TypeInfo": "float, optional, default=0",
        "Description": "The value to be used as a mask."
      },
      {
        "Name": "axis",
        "TypeInfo": "int, optional, default='0'",
        "Description": "The sequence axis. Only values of 0 and 1 are currently supported."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_SequenceMask",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "SequenceReverse",
    "Description": "Reverses the elements of each sequence.\n\nThis function takes an n-dimensional input array of the form [max_sequence_length, batch_size, other_feature_dims]\nand returns an array of the same shape.\n\nParameter `sequence_length` is used to handle variable-length sequences.\n`sequence_length` should be an input array of positive ints of dimension [batch_size].\nTo use this parameter, set `use_sequence_length` to `True`,\notherwise each example in the batch is assumed to have the max sequence length.\n\nExample::\n\n   x = [[[  1.,   2.,   3.],\n         [  4.,   5.,   6.]],\n\n        [[  7.,   8.,   9.],\n         [ 10.,  11.,  12.]],\n\n        [[ 13.,  14.,   15.],\n         [ 16.,  17.,   18.]]]\n\n   // Batch 1\n   B1 = [[  1.,   2.,   3.],\n         [  7.,   8.,   9.],\n         [ 13.,  14.,  15.]]\n\n   // Batch 2\n   B2 = [[  4.,   5.,   6.],\n         [ 10.,  11.,  12.],\n         [ 16.,  17.,  18.]]\n\n   // returns reverse sequence when sequence_length parameter is not used\n   SequenceReverse(x) = [[[ 13.,  14.,   15.],\n                          [ 16.,  17.,   18.]],\n\n                         [[  7.,   8.,   9.],\n                          [ 10.,  11.,  12.]],\n\n                         [[  1.,   2.,   3.],\n                          [  4.,   5.,   6.]]]\n\n   // sequence_length [2,2] means 2 rows of\n   // both batch B1 and B2 will be reversed.\n   SequenceReverse(x, sequence_length=[2,2], use_sequence_length=True) =\n                     [[[  7.,   8.,   9.],\n                       [ 10.,  11.,  12.]],\n\n                      [[  1.,   2.,   3.],\n                       [  4.,   5.,   6.]],\n\n                      [[ 13.,  14.,   15.],\n                       [ 16.,  17.,   18.]]]\n\n   // sequence_length [2,3] means 2 of batch B2 and 3 of batch B3\n   // will be reversed.\n   SequenceReverse(x, sequence_length=[2,3], use_sequence_length=True) =\n                    [[[  7.,   8.,   9.],\n                      [ 16.,  17.,  18.]],\n\n                     [[  1.,   2.,   3.],\n                      [ 10.,  11.,  12.]],\n\n                     [[ 13.,  14,   15.],\n                      [  4.,   5.,   6.]]]\n\n\n\nDefined in C:\\Jenkins\\workspace\\mxnet-tag\\mxnet\\src\\operator\\sequence_reverse.cc:L122",
    "NumArgs": 4,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "n-dimensional input array of the form [max_sequence_length, batch_size, other dims] where n>2 "
      },
      {
        "Name": "sequence_length",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "vector of sequence lengths of the form [batch_size]"
      },
      {
        "Name": "use_sequence_length",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "If set to true, this layer takes in an extra input parameter `sequence_length` to specify variable length sequence"
      },
      {
        "Name": "axis",
        "TypeInfo": "int, optional, default='0'",
        "Description": "The sequence axis. Only 0 is currently supported."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_SequenceReverse",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_SliceChannel",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "SpatialTransformer",
    "Description": "Applies a spatial transformer to input feature map.",
    "NumArgs": 6,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data to the SpatialTransformerOp."
      },
      {
        "Name": "loc",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "localisation net, the output dim should be 6 when transform_type is affine. You shold initialize the weight and bias with identity tranform."
      },
      {
        "Name": "target_shape",
        "TypeInfo": "Shape(tuple), optional, default=[0,0]",
        "Description": "output shape(h, w) of spatial transformer: (y, x)"
      },
      {
        "Name": "transform_type",
        "TypeInfo": "{'affine'}, required",
        "Description": "transformation type"
      },
      {
        "Name": "sampler_type",
        "TypeInfo": "{'bilinear'}, required",
        "Description": "sampling type"
      },
      {
        "Name": "cudnn_off",
        "TypeInfo": "boolean or None, optional, default=None",
        "Description": "whether to turn cudnn off"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_SpatialTransformer",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "SVMOutput",
    "Description": "Computes support vector machine based transformation of the input.\n\nThis tutorial demonstrates using SVM as output layer for classification instead of softmax:\nhttps://github.com/dmlc/mxnet/tree/master/example/svm_mnist.\n\n",
    "NumArgs": 5,
    "Arguments": [
      {
        "Name": "data",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Input data for SVM transformation."
      },
      {
        "Name": "label",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "Class label for the input data."
      },
      {
        "Name": "margin",
        "TypeInfo": "float, optional, default=1",
        "Description": "The loss function penalizes outputs that lie outside this margin. Default margin is 1."
      },
      {
        "Name": "regularization_coefficient",
        "TypeInfo": "float, optional, default=1",
        "Description": "Regularization parameter for the SVM. This balances the tradeoff between coefficient size and error."
      },
      {
        "Name": "use_linear",
        "TypeInfo": "boolean, optional, default=0",
        "Description": "Whether to use L1-SVM objective. L2-SVM objective is used by default."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_SVMOutput",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_backward_SwapAxis",
    "Description": "",
    "NumArgs": 0,
    "Arguments": [],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_set_value",
    "Description": "",
    "NumArgs": 1,
    "Arguments": [
      {
        "Name": "src",
        "TypeInfo": "real_t",
        "Description": "Source input to the function."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_onehot_encode",
    "Description": "",
    "NumArgs": 2,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray",
        "Description": "Left operand to the function."
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray",
        "Description": "Right operand to the function."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "fill_element_0index",
    "Description": "Fill one element of each line(row for python, column for R/Julia) in lhs according to index indicated by rhs and values indicated by mhs. This function assume rhs uses 0-based index.",
    "NumArgs": 3,
    "Arguments": [
      {
        "Name": "lhs",
        "TypeInfo": "NDArray",
        "Description": "Left operand to the function."
      },
      {
        "Name": "mhs",
        "TypeInfo": "NDArray",
        "Description": "Middle operand to the function."
      },
      {
        "Name": "rhs",
        "TypeInfo": "NDArray",
        "Description": "Right operand to the function."
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  },
  {
    "Name": "_imdecode",
    "Description": "Decode an image, clip to (x0, y0, x1, y1), subtract mean, and write to buffer",
    "NumArgs": 8,
    "Arguments": [
      {
        "Name": "mean",
        "TypeInfo": "NDArray-or-Symbol",
        "Description": "image mean"
      },
      {
        "Name": "index",
        "TypeInfo": "int",
        "Description": "buffer position for output"
      },
      {
        "Name": "x0",
        "TypeInfo": "int",
        "Description": "x0"
      },
      {
        "Name": "y0",
        "TypeInfo": "int",
        "Description": "y0"
      },
      {
        "Name": "x1",
        "TypeInfo": "int",
        "Description": "x1"
      },
      {
        "Name": "y1",
        "TypeInfo": "int",
        "Description": "y1"
      },
      {
        "Name": "c",
        "TypeInfo": "int",
        "Description": "channel"
      },
      {
        "Name": "size",
        "TypeInfo": "int",
        "Description": "length of str_img"
      }
    ],
    "KeyVarNumArgs": "",
    "ReturnType": null
  }
]